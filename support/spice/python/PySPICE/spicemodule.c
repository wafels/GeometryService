/*
THIS IS AUTOMATICALLY GENERATED CODE.  IF THERE IS AN ERROR, PLEASE
MAKE ANY NECESSARY CHANGES IN THE PYTHON SCRIPT NAMED mkwrapper.py.

THIS CODE HAS NOT BEEN THOROUGHLY TESTED, USE AT YOUR OWN RISK, THE
AUTHOR(S) IS/ARE NOT RESPONSIBLE IF YOUR CRAFT GOES DOWN, BLAH BLAH
BLAH.  SEE FILE "LICENSE" FOR MORE INFO.
*/

#include "pyspice.h"

PyObject *SpiceException;


/* void axisar_c ( ConstSpiceDouble axis [3],SpiceDouble angle,
SpiceDouble r [3][3] ); */
static PyObject * spice_axisar(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble r[3][3];
  /* variables for inputs */
  double axis[3];
  double angle;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)d", &axis[0], &axis[1], &axis[2], &angle));
  axisar_c(axis, angle, r);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, r[0][0], r[0][1], r[0][2], r[1][0], r[1][1], r[1][2], r[2][0], r[2][1], r[2][2]);
  return returnVal;
}
PyDoc_STRVAR(axisar_doc, "-Abstract\n\n   Construct a rotation matrix that rotates vectors by a specified\n   angle about a specified axis.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   axis       I   Rotation axis.\n   angle      I   Rotation angle, in radians.\n   r          O   Rotation matrix corresponding to axis and angle.\n\n-Detailed_Input\n\n   axis,\n   angle          are, respectively, a rotation axis and a rotation\n                  angle.  axis and angle determine a coordinate\n                  transformation whose effect on any vector v is to\n                  rotate v by angle radians about the vector axis.\n\n-Detailed_Output\n\n   r              is a rotation matrix representing the coordinate\n                  transformation determined by axis and angle:  for\n                  each vector v, r*v is the vector resulting from\n                  rotating v by angle radians about axis.\n\n");

/* SpiceBoolean badkpv_c ( ConstSpiceChar *caller,ConstSpiceChar *name,
ConstSpiceChar *comp,SpiceInt size,SpiceInt divby,SpiceChar type ); */
static PyObject * spice_badkpv(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * caller;
  char * name;
  char * comp;
  int size;
  int divby;
  char type;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sssiis", &caller, &name, &comp, &size, &divby, &type));
  result = badkpv_c(caller, name, comp, size, divby, type);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(badkpv_doc, "-Abstract\n\n   Determine if a kernel pool variable is present and if so\n   that it has the correct size and type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   caller     I   Name of the routine calling this routine.\n   name       I   Name of a kernel pool variable\n   comp       I   Comparison operator.\n   size       I   Expected size of the kernel pool variable\n   divby      I   A divisor of the size of the kernel pool variable.\n   type       I   Expected type of the kernel pool variable\n\n   The function returns SPICEFALSE if the kernel pool variable is OK.\n\n-Detailed_Input\n\n   caller     is the name of the routine calling this routine\n              to check correctness of kernel pool variables.\n\n   name       is the name of a kernel pool variable that the\n              calling program expects to be present in the\n              kernel pool.\n\n   comp       is the comparison operator to use when comparing\n              the number of components of the kernel pool variable\n              specified by name with the integer size.  If dim is\n              is the actual size of the kernel pool variable then\n              badkpv_c will check that the sentence\n\n                  dim comp size\n\n              is a true statement.  If it is not a true statement\n              an error will be signaled.\n\n              Allowed values for comp and their meanings are:\n\n                 \"=\"      dim == size\n                 \"<\"      dim <  size\n                 \">\"      dim >  size\n                 \"=>\"     dim >= size\n                 \"<=\"     dim <= size\n\n\n   size       is an integer to compare with the actual\n              number of components of the kernel pool variable\n              specified by name.\n\n   divby      is an integer that is one of the factors of the\n              actual dimension of the specified kernel pool variable.\n              In other words, it is expected that divby evenly\n              divides the actual dimension of name. In those\n              cases in which the factors of the dimension of name\n              are not important, set divby to 1 in the calling\n              program.\n\n   type       is the expected type of the kernel pool variable.\n              Recognized values are\n\n                'C' for character type\n                'N' for numeric type (integer and double precision)\n\n              The case of type is insignificant.  If the value\n              of TYPE is not one of the 2 values given above\n              no check for the type of the variable will be\n              performed.\n\n\n-Detailed_Output\n\n   The function returns the value SPICEFALSE if the kernel pool variable\n   has the expected properties.  Otherwise the routine signals\n   an error and returns the value SPICETRUE.\n\n");

/* void bodc2n_c ( SpiceInt code,SpiceInt namelen,SpiceChar * name,
SpiceBoolean * found ); */
static PyObject * spice_bodc2n(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar name[STRING_LEN];
  SpiceBoolean found;
  /* variables for inputs */
  int code;
  int namelen = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &code));
  bodc2n_c(code, namelen, name, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, name);
  return returnVal;
  }

}
PyDoc_STRVAR(bodc2n_doc, "-Abstract\n\n   Translate the SPICE integer code of a body into a common name\n   for that body.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   code       I   Integer ID code to be translated into a name.\n   lenout     I   Maximum length of output name.\n   name       O   A common name for the body identified by code.\n   found      O   True if translated, otherwise false.\n\n-Detailed_Input\n\n   code        is an integer code for a body ---\n               a planet, satellite, barycenter, spacecraft,\n               asteroid, comet, or other ephemeris object.\n\n   lenout      is the maximum allowed length of the output name,\n               including the terminating null character.  For example,\n               if the caller wishes to be able to accept a 32-character\n               name, lenout must be set to (at least) 33.  The current\n               maximum name length is 32 characters, so a value of 33\n               for lenout will suffice.\n\n-Detailed_Output\n\n   name        is a common name of the body identified by code.\n               If code has more than one translation, then the\n               most recently defined name corresponding to code\n               is returned.  'name' will have the exact format (case\n               and blanks) as when the name/code pair was defined.\n\n               No more than lenout characters, including the\n               terminating null, will be written to name.  A terminating\n               null will always be written.\n\n   found       is SPICETRUE if code has a translation.  Otherwise, found\n               is SPICEFALSE.\n\n");

/* void bodc2s_c ( SpiceInt code,SpiceInt lenout,SpiceChar * name ); */
static PyObject * spice_bodc2s(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar name[STRING_LEN];
  /* variables for inputs */
  int code;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &code));
  bodc2s_c(code, lenout, name);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, name);
  return returnVal;
}
PyDoc_STRVAR(bodc2s_doc, "-Abstract\n\n   Translate a body ID code to either the corresponding name or if no\n   name to ID code mapping exists, the string representation of the\n   body ID value.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   code       I   Integer ID code to translate to a string.\n   lenout     I   Maximum length of output name.\n   name       O   String corresponding to 'code'.\n\n-Detailed_Input\n\n   code        the integer code for a body: planet, satellite,\n               barycenter, spacecraft, asteroid, comet, or\n               other ephemeris object.\n\n   lenout      is the maximum allowed length of the output name,\n               including the terminating null character.  For example,\n               if the caller wishes to be able to accept a 32-character\n               name, lenout must be set to (at least) 33. The current\n               maximum name length is 32 characters, so a value of 33\n               for lenout will suffice.\n\n-Detailed_Output\n\n   name        the string name of the body identified by 'code'\n               if a mapping between 'code' and a body name exists\n               within SPICE.\n\n               If 'code' has more than one translation, then the\n               most recently defined 'name' corresponding to 'code'\n               is returned. 'name' will have the exact format (case\n               and blanks) as when the name/code pair was defined.\n\n               If the input value of 'code' does not map to a body\n               name, 'name' returns with the string representation\n               of 'code'.\n\n");

/* void boddef_c ( ConstSpiceChar * name,SpiceInt code ); */
static PyObject * spice_boddef(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * name;
  int code;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &name, &code));
  boddef_c(name, code);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(boddef_doc, "-Abstract\n\n   Define a body name/ID code pair for later translation via\n   bodn2c_c or bodc2n_c.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   name       I   Common name of some body.\n   code       I   Integer code for that body.\n\n-Detailed_Input\n\n   name        is an arbitrary name of a body which could be\n               a planet, satellite, barycenter, spacecraft,\n               asteroid, comet, or other ephemeris object.\n\n               The case and positions of blanks in a name are\n               significant. bodc2n_c returns the same string\n               (case and space) most recently mapped to a code.\n               When 'name' consists of more than one word, the\n               words require separation by at least one blank.\n\n               The kernel sub-system stores 'name' as described in\n               the boddef_c call, but creates an equivalence class\n               based on 'name for comparisons in bodn2c_c. This class\n               ignores leading/trailing whitespace, compresses\n               interior whitespace to a single space, and ignores\n               character case.\n\n               The following strings belong to the same equivalence\n               class:\n\n                       \"JUPITER BARYCENTER\"\n                       \"Jupiter Barycenter\"\n                       \"JUPITER BARYCENTER   \"\n                       \"JUPITER    BARYCENTER\"\n                       \"   JUPITER BARYCENTER\"\n\n               However, \"JUPITERBARYCENTER\" is distinct from\n               the names above.\n\n               When ignoring trailing blanks, NAME must be short\n               enough to fit into the space defined by parameter\n               MAXL.The value may be found in the C file\n               zzbodtrn.c. Due to the way in which f2c converts\n               FORTRAN code to C, you must examine the dimensions\n               assigned to the variables:\n\n                   defnam\n                   defnor\n                   kernam\n                   kernor\n\n                to obtain the MAXL value. These variables have a\n                declaration of the form:\n\n                   static char variable_name[MAXL*array_length]\n\n                  (note MAXL is this first value).\n\n               The maximum allowed length of a name is in any case\n               at least 32 characters.\n\n   code        is the integer ID code for assignment to body 'name'.\n\n-Detailed_Output\n\n   None.\n\n");

/* SpiceBoolean bodfnd_c ( SpiceInt body,ConstSpiceChar * item ); */
static PyObject * spice_bodfnd(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int body;
  char * item;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "is", &body, &item));
  result = bodfnd_c(body, item);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(bodfnd_doc, "-Abstract\n\n   Determine whether values exist for some item for any body\n   in the kernel pool.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   body       I   ID code of body.\n   item       I   Item to find (\"RADII\", \"NUT_AMP_RA\", etc.).\n\n   The function returns the value SPICETRUE if the item is in the\n   kernel pool, and is SPICEFALSE if it is not.\n\n-Detailed_Input\n\n   body       is the ID code of the body for which the item is\n              requested. Bodies are numbered according to the\n              standard NAIF numbering scheme.\n\n   item       is the item to be returned. Together, the body and\n              item name combine to form a variable name, e.g.,\n\n                    \"BODY599_RADII\"\n                    \"BODY4_POLE_RA\"\n\n-Detailed_Output\n\n   The function returns the value SPICETRUE if the item is in the\n   kernel pool, and is SPICEFALSE if it is not.\n\n");

/* void bodn2c_c ( ConstSpiceChar * name,SpiceInt * code,
SpiceBoolean * found ); */
static PyObject * spice_bodn2c(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt code;
  SpiceBoolean found;
  /* variables for inputs */
  char * name;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &name));
  bodn2c_c(name, &code, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, code);
  return returnVal;
  }

}
PyDoc_STRVAR(bodn2c_doc, "-Abstract\n\n   Translate the name of a body or object to the corresponding SPICE\n   integer ID code.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   name       I   Body name to be translated into a SPICE ID code.\n   code       O   SPICE integer ID code for the named body.\n   found      O   SPICETRUE if translated, otherwise SPICEFALSE.\n\n-Detailed_Input\n\n   name        is the name of a body or object, such as a planet,\n               satellite, comet, asteroid, barycenter, DSN station,\n               spacecraft, or instrument, that is \"known\" to the SPICE\n               system, whether through hard-coded registration or\n               run-time registration in the SPICE kernel pool.\n\n               Case and leading and trailing blanks in `name'\n               are not significant.  However when a name is made\n               up of more than one word, they must be separated by\n               at least one blank.  That is, all of the following\n               strings are equivalent names:\n\n                       \"JUPITER BARYCENTER\"\n                       \"Jupiter Barycenter\"\n                       \"JUPITER BARYCENTER   \"\n                       \"JUPITER    BARYCENTER\"\n                       \"   JUPITER BARYCENTER\"\n\n               However, \"JUPITERBARYCENTER\" is not equivalent to\n               the names above.\n\n-Detailed_Output\n\n   code        is the SPICE or user-defined integer ID code for the\n               named body.\n\n   found       is SPICETRUE if `name' has a translation.  Otherwise,\n               `found' is SPICEFALSE.\n\n");

/* void bods2c_c ( ConstSpiceChar * name,SpiceInt * code,
SpiceBoolean * found ); */
static PyObject * spice_bods2c(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt code;
  SpiceBoolean found;
  /* variables for inputs */
  char * name;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &name));
  bods2c_c(name, &code, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, code);
  return returnVal;
  }

}
PyDoc_STRVAR(bods2c_doc, "-Abstract\n\n   Translate a string containing a body name or ID code to an integer\n   code.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   name       I   String to be translated to an ID code.\n   code       O   Integer ID code corresponding to `name'.\n   found      O   Flag indicating whether translation succeeded.\n\n-Detailed_Input\n\n   name        is a string containing the name or ID code of a body or\n               object, such as a planet, satellite, comet, asteroid,\n               barycenter, DSN station, spacecraft, or instrument.\n\n               If `name' contains the name of a body or object, that\n               name must be \"known\" to the SPICE system, whether\n               through hard-coded registration or run-time registration\n               in the SPICE kernel pool.\n\n               Case and leading and trailing blanks in `name'\n               are not significant.  However when a name is made\n               up of more than one word, they must be separated by\n               at least one blank.  That is, all of the following\n               strings are equivalent names:\n\n                       \"JUPITER BARYCENTER\"\n                       \"Jupiter Barycenter\"\n                       \"JUPITER BARYCENTER   \"\n                       \"JUPITER    BARYCENTER\"\n                       \"   JUPITER BARYCENTER\"\n\n               However, \"JUPITERBARYCENTER\" is not equivalent to\n               the names above.\n\n               If NAME is a string representation of an integer,\n               for example\n\n                  \"399\"\n\n               the string will be translated to the equivalent SpiceInt\n               datum.  The input integer need not be one recognized by\n               the SPICE system:  the integer need not be a built-in\n               NAIF ID code, nor need it be associated with a name via\n               run-time registration.\n\n-Detailed_Output\n\n   code         is, if `name' contains the name of a body or object,\n                the corresponding NAIF or user-defined integer ID code,\n                as determined by the SPICE name-code mapping subsystem.\n                If the input argument `name' represents an integer, the\n                same integer is returned in `code'.\n\n               `code' is assigned a value only if `found' is returned\n               as SPICETRUE; otherwise it is returned unchanged.\n\n\n   found       is SPICETRUE if `name' has a translation.  Otherwise,\n               `found' is SPICEFALSE.\n\n");

/* void bodvcd_c ( SpiceInt body,ConstSpiceChar * item,SpiceInt maxn,
SpiceInt * dim ,SpiceDouble * values ); */
static PyObject * spice_bodvcd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt dim;
  SpiceDouble * values;
  /* variables for inputs */
  int body;
  char * item;
  int maxn;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "isi", &body, &item, &maxn));

  values = PyMem_Malloc(sizeof(SpiceDouble) * maxn);
  bodvcd_c(body, item, maxn, &dim, values);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    PyMem_Free(values);
    return NULL;
  }

  int i = 0;
  PyObject *t = NULL;
  PyObject *returnVal = PyTuple_New(2);
  PyTuple_SET_ITEM(returnVal, 0, Py_BuildValue("i", dim));
  t = PyTuple_New(dim);
  for(i = 0; i < dim; ++ i) {
    PyTuple_SET_ITEM(t, i, Py_BuildValue("d", values[i]));
  }
  PyTuple_SET_ITEM(returnVal, 1, t);
  return returnVal;
}
PyDoc_STRVAR(bodvcd_doc, "-Abstract\n\n   Fetch from the kernel pool the double precision values of an item\n   associated with a body, where the body is specified by an integer ID\n   code.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   bodyid     I   Body ID code.\n   item       I   Item for which values are desired. (\"RADII\",\n                  \"NUT_PREC_ANGLES\", etc. )\n   maxn       I   Maximum number of values that may be returned.\n   dim        O   Number of values returned.\n   values     O   Values.\n\n-Detailed_Input\n\n   bodyid     is the NAIF integer ID code for a body of interest.\n              For example, if the body is the earth, the code is\n              399.\n\n   item       is the item to be returned. Together, the NAIF ID\n              code of the body and the item name combine to form a\n              kernel variable name, e.g.,\n\n                 \"BODY599_RADII\"\n                 \"BODY401_POLE_RA\"\n\n              The values associated with the kernel variable having\n              the name constructed as shown are sought.  Below\n              we'll take the shortcut of calling this kernel variable\n              the \"requested kernel variable.\"\n\n              Note that `item' *is* case-sensitive.  This attribute\n              is inherited from the case-sensitivity of kernel\n              variable names.\n\n   maxn       is the maximum number of values that may be returned.\n              The output array `values' must be declared with size at\n              least `maxn'.  It's an error to supply an output array\n              that is too small to hold all of the values associated\n              with the requested kernel variable.\n\n-Detailed_Output\n\n   dim        is the number of values returned; this is always the\n              number of values associated with the requested kernel\n              variable unless an error has been signaled.\n\n   values     is the array of values associated with the requested\n              kernel variable.  If `values' is too small to hold all\n              of the values associated with the kernel variable, the\n              returned values of `dim' and `values' are undefined.\n\n");

/* void bodvrd_c ( ConstSpiceChar * body,ConstSpiceChar * item,SpiceInt maxn,
SpiceInt * dim ,SpiceDouble * values ); */
static PyObject * spice_bodvrd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt dim;
  SpiceDouble * values;
  /* variables for inputs */
  char * body;
  char * item;
  int maxn;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &body, &item, &maxn));

  values = PyMem_Malloc(sizeof(SpiceDouble) * maxn);
  bodvrd_c(body, item, maxn, &dim, values);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    PyMem_Free(values);
    return NULL;
  }

  int i = 0;
  PyObject *t = NULL;
  PyObject *returnVal = PyTuple_New(2);
  PyTuple_SET_ITEM(returnVal, 0, Py_BuildValue("i", dim));
  t = PyTuple_New(dim);
  for(i = 0; i < dim; ++ i) {
    PyTuple_SET_ITEM(t, i, Py_BuildValue("d", values[i]));
  }
  PyTuple_SET_ITEM(returnVal, 1, t);
  return returnVal;
}
PyDoc_STRVAR(bodvrd_doc, "-Abstract\n\n   Fetch from the kernel pool the double precision values\n   of an item associated with a body.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   bodynm     I   Body name.\n   item       I   Item for which values are desired. (\"RADII\",\n                  \"NUT_PREC_ANGLES\", etc. )\n   maxn       I   Maximum number of values that may be returned.\n   dim        O   Number of values returned.\n   values     O   Values.\n\n-Detailed_Input\n\n   bodynm     is the name of the body for which `item' is requested.\n              `bodynm' is case-insensitive, and leading and trailing\n              blanks in `bodynm' are not significant. Optionally, you\n              may supply the integer ID code for the object as an\n              integer string.  For example both \"MOON\" and \"301\" are\n              legitimate strings that indicate the moon is the body\n              of interest.\n\n   item       is the item to be returned. Together, the NAIF ID\n              code of the body and the item name combine to form a\n              kernel variable name, e.g.,\n\n                 \"BODY599_RADII\"\n                 \"BODY401_POLE_RA\"\n\n              The values associated with the kernel variable having\n              the name constructed as shown are sought.  Below\n              we'll take the shortcut of calling this kernel variable\n              the \"requested kernel variable.\"\n\n              Note that `item' *is* case-sensitive.  This attribute\n              is inherited from the case-sensitivity of kernel\n              variable names.\n\n   maxn       is the maximum number of values that may be returned.\n              The output array `values' must be declared with size at\n              least `maxn'.  It's an error to supply an output array\n              that is too small to hold all of the values associated\n              with the requested kernel variable.\n\n-Detailed_Output\n\n   dim        is the number of values returned; this is always the\n              number of values associated with the requested kernel\n              variable unless an error has been signaled.\n\n   values     is the array of values associated with the requested\n              kernel variable.  If `values' is too small to hold all\n              of the values associated with the kernel variable, the\n              returned values of `dim' and `values' are undefined.\n\n");

/* SpiceDouble brcktd_c ( SpiceDouble number,SpiceDouble end1,
SpiceDouble end2 ); */
static PyObject * spice_brcktd(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double number;
  double end1;
  double end2;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &number, &end1, &end2));
  result = brcktd_c(number, end1, end2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(brcktd_doc, "-Abstract\n\n   Bracket a number. That is, given a number and an acceptable\n   interval, make sure that the number is contained in the\n   interval. (If the number is already in the interval, leave it\n    alone. If not, set it to the nearest endpoint of the interval.)\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   number     I   Number to be bracketed.\n   end1       I   One of the bracketing endpoints for number.\n   end2       I   The other bracketing endpoint for number.\n\n   The function returns the bracketed number.\n\n-Detailed_Input\n\n   number      is the number to be bracketed. That is, the\n               value of number is constrained to lie in the\n               interval bounded by end1 and end2.\n\n   end1,\n   end2        are the lower and upper bounds for number. The\n               order is not important.\n\n-Detailed_Output\n\n   The function returnes the input number, if it was already in the\n   interval provided. Otherwise the returned value is the nearest\n   bound of the interval.\n\n");

/* SpiceInt brckti_c ( SpiceInt number,SpiceInt end1,SpiceInt end2 ); */
static PyObject * spice_brckti(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int number;
  int end1;
  int end2;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &number, &end1, &end2));
  result = brckti_c(number, end1, end2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(brckti_doc, "-Abstract\n\n   Bracket a number. That is, given a number and an acceptable\n   interval, make sure that the number is contained in the\n   interval. (If the number is already in the interval, leave it\n    alone. If not, set it to the nearest endpoint of the interval.)\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   number     I   Number to be bracketed.\n   end1       I   One of the bracketing endpoints for number.\n   end2       I   The other bracketing endpoint for number.\n\n   The function returns the bracketed number.\n\n-Detailed_Input\n\n   number      is the number to be bracketed. That is, the\n               value of number is constrained to lie in the\n               interval bounded by end1 and end2.\n\n   end1,\n   end2        are the lower and upper bounds for number. The\n               order is not important.\n\n-Detailed_Output\n\n   The function returnes the input number, if it was already in the\n   interval provided. Otherwise the returned value is the nearest\n   bound of the interval.\n\n");

/* SpiceInt bschoi_c ( SpiceInt value,SpiceInt ndim,ConstSpiceInt * array,
ConstSpiceInt * order ); */
static PyObject * spice_bschoi(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int value;
  int ndim;
  int * array;
  int * order;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiii", &value, &ndim, &array, &order));
  result = bschoi_c(value, ndim, array, order);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(bschoi_doc, "-Abstract\n\n   Do a binary search for a given value within an integer array,\n   accompanied by an order vector.  Return the index of the\n   matching array entry, or -1 if the key value is not found.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   value      I   Value to find in array.\n   ndim       I   Dimension of array.\n   array      I   Array to be searched.\n   order      I   Order vector.\n\n   The function returns the index of value in array, or -1 if the value\n   is not found.\n\n-Detailed_Input\n\n   value       is the value to be found in the input array.\n\n   ndim        is the number of elements in the input array.\n\n   array       is the array to be searched.\n\n   order       is an order vector which can be used to access the elements\n               of array in order.  The contents of order are a permutation\n               of the sequence of integers ranging from zero to ndim-1.\n\n-Detailed_Output\n\n   The function returns the index of the input value in the input array.\n   Indices range from zero to ndim-1.\n\n   If the input array does not contain the specified value, the function\n   returns -1.\n\n   If the input array contains more than one occurrence of the specified\n   value, the returned index may point to any of the occurrences.\n\n");

/* SpiceInt bsrchd_c ( SpiceDouble value,SpiceInt ndim,
ConstSpiceDouble * array ); */
static PyObject * spice_bsrchd(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double value;
  int ndim;
  double * array;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "did", &value, &ndim, &array));
  result = bsrchd_c(value, ndim, array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(bsrchd_doc, "-Abstract\n\n   Do a binary search for a key value within a double precision array,\n   assumed to be in increasing order. Return the index of the matching\n   array entry, or -1 if the key value is not found.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   value      I   Value to find in array.\n   ndim       I   Dimension of array.\n   array      I   Array to be searched.\n\n   The function returns the index of the input key value in the\n   input array, or -1 if the value is not found.\n\n-Detailed_Input\n\n   value       is the value to be found in the input array.\n\n   ndim        is the number of elements in the input array.\n\n   array       is the array to be searched. The elements in the\n               array are assumed to sorted in increasing order.\n\n-Detailed_Output\n\n   The function returns the index of the input value in the input array.\n   Indices range from zero to ndim-1.\n\n   If the input array does not contain the specified value, the function\n   returns -1.\n\n   If the input array contains more than one occurrence of the specified\n   value, the returned index may point to any of the occurrences.\n\n");

/* SpiceInt bsrchi_c ( SpiceInt value,SpiceInt ndim,ConstSpiceInt * array ); */
static PyObject * spice_bsrchi(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int value;
  int ndim;
  int * array;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &value, &ndim, &array));
  result = bsrchi_c(value, ndim, array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(bsrchi_doc, "-Abstract\n\n   Do a binary search for a key value within an integer array,\n   assumed to be in increasing order. Return the index of the\n   matching array entry, or -1 if the key value is not found.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   value      I   Value to find in array.\n   ndim       I   Dimension of array.\n   array      I   Array to be searched.\n\n   The function returns the index of the input key value in the\n   input array, or -1 if the value is not found.\n\n-Detailed_Input\n\n   value       is the value to be found in the input array.\n\n   ndim        is the number of elements in the input array.\n\n   array       is the array to be searched. The elements in the\n               array are assumed to sorted in increasing order.\n\n-Detailed_Output\n\n   The function returns the index of the input value in the input array.\n   Indices range from zero to ndim-1.\n\n   If the input array does not contain the specified value, the function\n   returns -1.\n\n   If the input array contains more than one occurrence of the specified\n   value, the returned index may point to any of the occurrences.\n\n");

/* SpiceDouble b1900_c ( void ); */
static PyObject * spice_b1900(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = b1900_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(b1900_doc, "-Abstract\n\n   Return the Julian Date corresponding to Besselian Date 1900.0.\n\n-Brief_I/O\n\n   The function returns the Julian Date corresponding to Besselian\n   date 1900.0.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns 2415020.31352, the Julian Date corresponding\n   to Besselian Date 1900.0 as reported by Lieske [1].\n\n");

/* SpiceDouble b1950_c ( void ); */
static PyObject * spice_b1950(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = b1950_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(b1950_doc, "-Abstract\n\n   Return the Julian Date corresponding to Besselian Date 1950.0.\n\n-Brief_I/O\n\n   The function returns the Julian Date corresponding to Besselian\n   date 1950.0.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns 2433282.42345905, the Julian Date corresponding\n   to Besselian Date 1950.0 as reported by Lieske [1].\n\n");

/* SpiceInt card_c ( SpiceCell * cell ); */
static PyObject * spice_card(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cell;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceInt result;

  result = card_c(&cell);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cell));
  return returnVal;
}
PyDoc_STRVAR(card_doc, "-Abstract\n\n   Return the cardinality (current number of elements) in a\n   cell of any data type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   cell       I   Input cell.\n\n   The function returns the cardinality of the input cell.\n\n-Detailed_Input\n\n   cell        is a cell of character, double precision, or\n               integer data type.\n\n-Detailed_Output\n\n   The function returns the cardinality of (current number of elements\n   in) the input cell.\n\n");

/* void cgv2el_c ( ConstSpiceDouble center[3],ConstSpiceDouble vec1 [3],
ConstSpiceDouble vec2 [3],SpiceEllipse * ellipse ); */
static PyObject * spice_cgv2el(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceEllipse ellipse;
  /* variables for inputs */
  double center[3];
  double vec1[3];
  double vec2[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)(ddd)", &center[0], &center[1], &center[2], &vec1[0], &vec1[1], &vec1[2], &vec2[0], &vec2[1], &vec2[2]));
  cgv2el_c(center, vec1, vec2, &ellipse);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_ellipse(&ellipse));
  return returnVal;
}
PyDoc_STRVAR(cgv2el_doc, "-Abstract\n\n   Form a CSPICE ellipse from a center vector and two generating\n   vectors.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   center,\n   vec1,\n   vec2       I   Center and two generating vectors for an ellipse.\n   ellipse    O   The CSPICE ellipse defined by the input vectors.\n\n-Detailed_Input\n\n   center,\n   vec1,\n   vec2           are a center and two generating vectors defining\n                  an ellipse in three-dimensional space.  The\n                  ellipse is the set of points\n\n                     center  +  cos(theta) vec1  +  sin(theta) vec2\n\n                  where theta ranges over the interval (-pi, pi].\n                  vec1 and vec2 need not be linearly independent.\n\n-Detailed_Output\n\n   ellipse        is the CSPICE ellipse defined by the input\n                  vectors.\n\n");

/* void chkin_c ( ConstSpiceChar * module ); */
static PyObject * spice_chkin(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * module;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &module));
  chkin_c(module);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(chkin_doc, "-Abstract\n\n   Inform the CSPICE error handling mechanism of entry into a\n   routine.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  ---------------------------------------------------\n   module     I   The name of the calling routine.\n\n-Detailed_Input\n\n   module         is the name of the routine calling chkin_c.  The\n                  named routine is supposed to be `checking in'\n                  when it calls chkin_c; that is, the call should be\n                  the first executable statement following the\n                  reference to the function return_c() (which should be\n                  the first executable statement).\n\n-Detailed_Output\n\n   None.\n\n");

/* void chkout_c ( ConstSpiceChar * module ); */
static PyObject * spice_chkout(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * module;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &module));
  chkout_c(module);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(chkout_doc, "-Abstract\n\n   Inform the CSPICE error handling mechanism of exit from a\n   routine.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   module     I   The name of the calling routine.\n\n-Detailed_Input\n\n   module         is the name of the routine calling chkout_c.  The\n                  named routine is supposed to be `checking out'\n                  when it calls chkout_c; that is, the call should be\n                  the last executable statement preceding any exit\n                  from the routine.\n\n-Detailed_Output\n\n   None.\n\n");

/* void cidfrm_c ( SpiceInt cent,SpiceInt lenout,SpiceInt * frcode,
SpiceChar * frname,SpiceBoolean * found ); */
static PyObject * spice_cidfrm(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt frcode;
  SpiceChar frname[STRING_LEN];
  SpiceBoolean found;
  /* variables for inputs */
  int cent;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &cent));
  cidfrm_c(cent, lenout, &frcode, frname, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "s");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, frcode, frname);
  return returnVal;
  }

}
PyDoc_STRVAR(cidfrm_doc, "-Abstract\n\n   Retrieve frame ID code and name to associate with a frame center.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   cent       I   An object to associate a frame with.\n   lenout     I   Available space in output string frname.\n   frcode     O   The ID code of the frame associated with cent.\n   frname     O   The name of the frame with ID frcode.\n   found      O   SPICETRUE if the requested information is available.\n\n-Detailed_Input\n\n   cent        is the ID code for object for which there is a\n               preferred reference frame.\n\n   lenout      is the available space in the output string frname,\n               including room for the terminating null character.\n\n-Detailed_Output\n\n   frcode      is the frame ID code to associate with the object\n               specified by cent.\n\n   frname      is the name of the frame that should be associated\n               with the object specified by cent.\n\n   found       is SPICETRUE if the appropriate frame ID code and frame\n               name can be determined.  Otherwise found is returned\n               with the value SPICEFALSE.\n\n");

/* void ckcls_c ( SpiceInt handle ); */
static PyObject * spice_ckcls(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  ckcls_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ckcls_doc, "-Abstract\n\n   Close an open CK file.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    handle     I   Handle of the CK file to be closed.\n\n-Detailed_Input\n\n   handle   The handle of the CK file that is to be closed.\n\n-Detailed_Output\n\n   None.\n\n");

/* void ckcov_c ( ConstSpiceChar * ck,SpiceInt idcode,SpiceBoolean needav,
ConstSpiceChar * level,SpiceDouble tol,ConstSpiceChar * timsys,
SpiceCell * cover ); */
static PyObject * spice_ckcov(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cover;
  /* variables for inputs */
  char * ck;
  int idcode;
  char needav;
  char * level;
  double tol;
  char * timsys;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "siOsds", &ck, &idcode, &needav, &level, &tol, &timsys));
  ckcov_c(ck, idcode, needav, level, tol, timsys, &cover);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cover));
  return returnVal;
}
PyDoc_STRVAR(ckcov_doc, "-Abstract\n\n   Find the coverage window for a specified object in a specified CK\n   file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   ck         I   Name of CK file.\n   idcode     I   ID code of object.\n   needav     I   Flag indicating whether angular velocity is needed.\n   level      I   Coverage level:  \"SEGMENT\" OR \"INTERVAL\".\n   tol        I   Tolerance in ticks.\n   timsys     I   Time system used to represent coverage.\n   cover     I/O  Window giving coverage for `idcode'.\n\n-Detailed_Input\n\n   ck             is the name of a C-kernel.\n\n   idcode         is the integer ID code of an object, normally a\n                  spacecraft structure or instrument, for which\n                  pointing data are expected to exist in the specified\n                  CK file.\n\n   needav         is a logical variable indicating whether only\n                  segments having angular velocity are to be considered\n                  when determining coverage.  When `needav' is\n                  SPICETRUE, segments without angular velocity don't\n                  contribute to the coverage window; when `needav' is\n                  SPICEFALSE, all segments for `idcode' may contribute\n                  to the coverage window.\n\n\n   level          is the level (granularity) at which the coverage\n                  is examined.  Allowed values and corresponding\n                  meanings are:\n\n                     \"SEGMENT\"    The output coverage window contains\n                                  intervals defined by the start and\n                                  stop times of segments for the object\n                                  designated by `idcode'.\n\n                     \"INTERVAL\"   The output coverage window contains\n                                  interpolation intervals of segments\n                                  for the object designated by\n                                  `idcode'.  For type 1 segments, which\n                                  don't have interpolation intervals,\n                                  each epoch associated with a pointing\n                                  instance is treated as a singleton\n                                  interval; these intervals are added\n                                  to the coverage window.\n\n                                  All interpolation intervals are\n                                  considered to lie within the segment\n                                  bounds for the purpose of this\n                                  summary:  if an interpolation\n                                  interval extends beyond the segment\n                                  coverage interval, only its\n                                  intersection with the segment\n                                  coverage interval is considered to\n                                  contribute to the total coverage.\n\n   tol            is a tolerance value expressed in ticks of the\n                  spacecraft clock associated with IDCODE.  Before each\n                  interval is inserted into the coverage window, the\n                  interval is intersected with the segment coverage\n                  interval, then if the intersection is non-empty, it\n                  is expanded by `tol': the left endpoint of the\n                  intersection interval is reduced by `tol' and the\n                  right endpoint is increased by `tol'. Adjusted\n                  interval endpoints, when expressed as encoded SCLK,\n                  never are less than zero ticks.  Any intervals that\n                  overlap as a result of the expansion are merged.\n\n                  The coverage window returned when tol > 0 indicates\n                  the coverage provided by the file to the CK readers\n                  ckgpav_c and ckgp_c when that value of `tol' is\n                  passed to them as an input.\n\n\n   timsys         is a string indicating the time system used in the\n                  output coverage window.  `timsys' may have the\n                  values:\n\n                      \"SCLK\"    Elements of `cover' are expressed in\n                                encoded SCLK (\"ticks\"), where the\n                                clock is associated with the object\n                                designated by `idcode'.\n\n                      \"TDB\"     Elements of `cover' are expressed as\n                                seconds past J2000 TDB.\n\n\n   cover          is an initialized CSPICE window data structure.\n                  `cover' optionally may contain coverage data on\n                  input; on output, the data already present in `cover'\n                  will be combined with coverage found for the object\n                  designated by `idcode' in the file `ck'.\n\n                  If `cover' contains no data on input, its size and\n                  cardinality still must be initialized.\n\n-Detailed_Output\n\n   cover          is a CSPICE window data structure which represents\n                  the merged coverage for `idcode'. When the coverage\n                  level is \"INTERVAL\", this is the set of time\n                  intervals for which data for `idcode' are present in\n                  the file `ck', merged with the set of time intervals\n                  present in `cover' on input.  The merged coverage is\n                  represented as the union of one or more disjoint time\n                  intervals.  The window `cover' contains the pairs of\n                  endpoints of these intervals.\n\n                  When the coverage level is \"SEGMENT\", `cover' is\n                  computed in a manner similar to that described above,\n                  but the coverage intervals used in the computation\n                  are those of segments rather than interpolation\n                  intervals within segments.\n\n                  When `tol' is > 0, the intervals comprising the\n                  coverage window for `idcode' are expanded by `tol'\n                  and any intervals overlapping as a result are merged.\n                  The resulting window is returned in `cover'. The\n                  expanded window in no case extends beyond the segment\n                  bounds in either direction by more than `tol'.\n\n                  The interval endpoints contained in `cover' are\n                  encoded spacecraft clock times if `timsys' is \"SCLK\";\n                  otherwise the times are converted from encoded\n                  spacecraft clock to seconds past J2000 TDB.\n\n                  See the Examples section below for a complete example\n                  program showing how to retrieve the endpoints from\n                  `cover'.\n\n");

/* void ckobj_c ( ConstSpiceChar * ck,SpiceCell * ids ); */
static PyObject * spice_ckobj(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell ids;
  /* variables for inputs */
  char * ck;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &ck));
  ckobj_c(ck, &ids);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&ids));
  return returnVal;
}
PyDoc_STRVAR(ckobj_doc, "-Abstract\n\n   Find the set of ID codes of all objects in a specified CK file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   ck         I   Name of CK file.\n   ids       I/O  Set of ID codes of objects in CK file.\n\n-Detailed_Input\n\n   ck             is the name of a C-kernel.\n\n   ids            is an initialized CSPICE set data structure.\n                  `ids' optionally may contain a set of ID codes on\n                  input; on output, the data already present in\n                  `ids' will be combined with ID code set found for the\n                  file `ck'.\n\n                  If `ids' contains no data on input, its size and\n                  cardinality still must be initialized.\n\n-Detailed_Output\n\n   ids            is a CSPICE set data structure which contains\n                  the union of its contents upon input with the set\n                  of ID codes of each object for which pointing data\n                  are present in the indicated CK file. The elements\n                  of CSPICE sets are unique; hence each ID code in\n                  `ids' appears only once, even if the CK file\n                  contains multiple segments for that ID code.\n\n                  See the Examples section below for a complete\n                  example program showing how to retrieve the ID\n                  codes from `ids'.\n\n");

/* void ckgp_c ( SpiceInt inst,SpiceDouble sclkdp,SpiceDouble tol,
ConstSpiceChar * ref,SpiceDouble cmat[3][3],SpiceDouble * clkout,
SpiceBoolean * found ); */
static PyObject * spice_ckgp(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble cmat[3][3];
  SpiceDouble clkout;
  SpiceBoolean found;
  /* variables for inputs */
  int inst;
  double sclkdp;
  double tol;
  char * ref;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idds", &inst, &sclkdp, &tol, &ref));
  ckgp_c(inst, sclkdp, tol, ref, cmat, &clkout, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");
  strcat(buildvalue_string, "d");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, cmat[0][0], cmat[0][1], cmat[0][2], cmat[1][0], cmat[1][1], cmat[1][2], cmat[2][0], cmat[2][1], cmat[2][2], clkout);
  return returnVal;
  }

}
PyDoc_STRVAR(ckgp_doc, "-Abstract\n\n   Get pointing (attitude) for a specified spacecraft clock time.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   inst       I   NAIF ID of instrument, spacecraft, or structure.\n   sclkdp     I   Encoded spacecraft clock time.\n   tol        I   Time tolerance.\n   ref        I   Reference frame.\n   cmat       O   C-matrix pointing data.\n   clkout     O   Output encoded spacecraft clock time.\n   found      O   True when requested pointing is available.\n\n-Detailed_Input\n\n   inst       is the NAIF integer ID for the instrument, spacecraft, or\n              other structure for which pointing is being requested.\n              For brevity we will refer to this object as the\n              \"instrument,\" and the frame fixed to this object as the\n              \"instrument frame\" or \"instrument-fixed\" frame.\n\n   sclkdp     is the encoded spacecraft clock time for which\n              pointing is being requested.\n\n              The CSPICE routines scencd_c and sce2c_c respectively\n              convert spacecraft clock strings and ephemeris time\n              to encoded spacecraft clock.  The inverse conversions\n              are performed by scdecd_c and sct2e_c.\n\n   tol        is a time tolerance in ticks, the units of encoded\n              spacecraft clock time.\n\n              The CSPICE routine sctiks_c converts a spacecraft clock\n              tolerance duration from its character string\n              representation to ticks.  scfmt_c performs the inverse\n              conversion.\n\n              The C-matrix returned by ckgp_c is the one whose time tag\n              is closest to `sclkdp' and within `tol' units of\n              `sclkdp'.  (More in Particulars, below.)\n\n              In general, because using a non-zero tolerance\n              affects selection of the segment from which the\n              data is obtained, users are strongly discouraged\n              from using a non-zero tolerance when reading CKs\n              with continuous data. Using a non-zero tolerance\n              should be reserved exclusively to reading CKs with\n              discrete data because in practice obtaining data\n              from such CKs using a zero tolerance is often not\n              possible due to time round off.\n\n   ref        is the desired reference frame for the returned pointing.\n              The returned C-matrix `cmat' gives the orientation of the\n              instrument designated by `inst' relative to the frame\n              designated by `ref'.  When a vector specified relative to\n              frame `ref' is left-multiplied by `cmat', the vector is\n              rotated to the frame associated with `inst'.  See the\n              discussion of `cmat' below for details.\n\n              Consult the SPICE document \"Frames\" for a discussion\n              of supported reference frames.\n\n-Detailed_Output\n\n   cmat       is a rotation matrix that transforms the components of a\n              vector expressed in the frame specified by `ref' to\n              components expressed in the frame tied to the instrument,\n              spacecraft, or other structure at time `clkout' (see\n              below).\n\n              Thus, if a vector v has components x,y,z in the `ref'\n              reference frame, then v has components x',y',z' in the\n              instrument fixed frame at time `clkout':\n\n                   [ x' ]     [          ] [ x ]\n                   | y' |  =  |   cmat   | | y |\n                   [ z' ]     [          ] [ z ]\n\n              If you know x', y', z', use the transpose of the\n              C-matrix to determine x, y, z as follows:\n\n                   [ x ]      [          ]T    [ x' ]\n                   | y |  =   |   cmat   |     | y' |\n                   [ z ]      [          ]     [ z' ]\n                           (Transpose of cmat)\n\n\n   clkout     is the encoded spacecraft clock time associated with\n              the returned C-matrix. This value may differ from the\n              requested time, but never by more than the input\n              tolerance `tol'.\n\n              The particulars section below describes the search\n              algorithm used by ckgp_c to satisfy a pointing request.\n              This algorithm determines the pointing instance\n              (and therefore the associated time value) that is\n              returned.\n\n   found      is SPICETRUE if a record was found to satisfy the\n              pointing request.  `found' will be SPICEFALSE otherwise.\n\n");

/* void ckgpav_c ( SpiceInt inst,SpiceDouble sclkdp,SpiceDouble tol,
ConstSpiceChar * ref,SpiceDouble cmat[3][3],SpiceDouble av[3],
SpiceDouble * clkout,SpiceBoolean * found ); */
static PyObject * spice_ckgpav(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble cmat[3][3];
  SpiceDouble av[3];
  SpiceDouble clkout;
  SpiceBoolean found;
  /* variables for inputs */
  int inst;
  double sclkdp;
  double tol;
  char * ref;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idds", &inst, &sclkdp, &tol, &ref));
  ckgpav_c(inst, sclkdp, tol, ref, cmat, av, &clkout, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, cmat[0][0], cmat[0][1], cmat[0][2], cmat[1][0], cmat[1][1], cmat[1][2], cmat[2][0], cmat[2][1], cmat[2][2], av[0], av[1], av[2], clkout);
  return returnVal;
  }

}
PyDoc_STRVAR(ckgpav_doc, "-Abstract\n\n   Get pointing (attitude) and angular velocity for a specified\n   spacecraft clock time.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   inst       I   NAIF ID of instrument, spacecraft, or structure.\n   sclkdp     I   Encoded spacecraft clock time.\n   tol        I   Time tolerance.\n   ref        I   Reference frame.\n   cmat       O   C-matrix pointing data.\n   av         O   Angular velocity vector.\n   clkout     O   Output encoded spacecraft clock time.\n   found      O   True when requested pointing is available.\n\n-Detailed_Input\n\n   inst       is the NAIF integer ID for the instrument, spacecraft, or\n              other structure for which pointing and angular velocity\n              are requested. For brevity we will refer to this object\n              as the \"instrument,\" and the frame fixed to this object\n              as the \"instrument frame\" or \"instrument-fixed\" frame.\n\n   sclkdp     is the encoded spacecraft clock time for which\n              pointing and angular velocity are requested.\n\n              The CSPICE routines scencd_c and sce2c_c respectively\n              convert spacecraft clock strings and ephemeris time\n              to encoded spacecraft clock.  The inverse conversions\n              are performed by scdecd_c and sct2e_c.\n\n   tol        is a time tolerance in ticks, the units of encoded\n              spacecraft clock time.\n\n              The CSPICE routine sctiks_c converts a spacecraft clock\n              tolerance duration from its character string\n              representation to ticks.  scfmt_c performs the inverse\n              conversion.\n\n              The C-matrix - angular velocity vector pair returned by\n              ckgpav_c is the one whose time tag is closest to `sclkdp'\n              and within `tol' units of `sclkdp'.  (More in\n              Particulars, below.)\n\n              In general, because using a non-zero tolerance\n              affects selection of the segment from which the\n              data is obtained, users are strongly discouraged\n              from using a non-zero tolerance when reading CKs\n              with continuous data. Using a non-zero tolerance\n              should be reserved exclusively to reading CKs with\n              discrete data because in practice obtaining data\n              from such CKs using a zero tolerance is often not\n              possible due to time round off.\n\n   ref        is the desired reference frame for the returned pointing\n              and angular velocity. The returned C-matrix `cmat' gives\n              the orientation of the instrument designated by `inst'\n              relative to the frame designated by `ref'.  When a vector\n              specified relative to frame `ref' is left-multiplied by\n              `cmat', the vector is rotated to the frame associated\n              with `inst'.  The returned angular velocity vector `av'\n              expresses the angular velocity of the instrument\n              designated by `inst' relative to the frame designated by\n              `ref'.  See the discussion of `cmat' and `av' below\n              for details.\n\n              Consult the SPICE document \"Frames\" for a discussion\n              of supported reference frames.\n\n-Detailed_Output\n\n   cmat       is a rotation matrix that transforms the components of a\n              vector expressed in the frame specified by `ref' to\n              components expressed in the frame tied to the instrument,\n              spacecraft, or other structure at time `clkout' (see\n              below).\n\n              Thus, if a vector v has components x,y,z in the `ref'\n              reference frame, then v has components x',y',z' in the\n              instrument fixed frame at time `clkout':\n\n                   [ x' ]     [          ] [ x ]\n                   | y' |  =  |   cmat   | | y |\n                   [ z' ]     [          ] [ z ]\n\n              If you know x', y', z', use the transpose of the\n              C-matrix to determine x, y, z as follows:\n\n                   [ x ]      [          ]T    [ x' ]\n                   | y |  =   |   cmat   |     | y' |\n                   [ z ]      [          ]     [ z' ]\n                           (Transpose of cmat)\n\n\n   av         is the angular velocity vector.  This is the axis about\n              which the reference frame tied to the instrument is\n              rotating in the right-handed sense at time `clkout'. The\n              magnitude of `av' is the magnitude of the instantaneous\n              velocity of the rotation, in radians per second.\n              The components of `av' are given relative to the\n              reference frame specified by the input argument `ref'.\n\n   clkout     is the encoded spacecraft clock time associated with\n              the returned C-matrix and the returned angular\n              velocity vector. This value may differ from the\n              requested time, but never by more than the input\n              tolerance `tol'.\n\n              The particulars section below describes the search\n              algorithm used by ckgpav_c to satisfy a pointing request.\n              This algorithm determines the pointing instance\n              (and therefore the associated time value) that is\n              returned.\n\n   found      is SPICETRUE if a record was found to satisfy the\n              pointing request.  `found' will be SPICEFALSE otherwise.\n\n");

/* void cklpf_c ( ConstSpiceChar * fname,SpiceInt * handle ); */
static PyObject * spice_cklpf(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &fname));
  cklpf_c(fname, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(cklpf_doc, "-Abstract\n\n   Load a CK pointing file for use by the CK readers.  Return that\n   file's handle, to be used by other CK routines to refer to the\n   file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   filename   I   Name of the CK file to be loaded.\n   handle     O   Loaded file's handle.\n\n-Detailed_Input\n\n   filename   is the name of a C-kernel file to be loaded.\n\n-Detailed_Output\n\n   handle     is an integer handle assigned to the file upon loading.\n              Almost every other CK routine will subsequently use\n              this number to refer to the file.\n\n");

/* void ckopn_c ( ConstSpiceChar * name,ConstSpiceChar * ifname,
SpiceInt ncomch,SpiceInt * handle ); */
static PyObject * spice_ckopn(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * name;
  char * ifname;
  int ncomch;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &name, &ifname, &ncomch));
  ckopn_c(name, ifname, ncomch, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(ckopn_doc, "-Abstract\n\n   Open a new CK file, returning the handle of the opened file.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   fname      I   The name of the CK file to be opened.\n   ifname     I   The internal filename for the CK.\n   ncomch     I   The number of characters to reserve for comments.\n   handle     O   The handle of the opened CK file.\n\n-Detailed_Input\n\n   fname    The name of the CK file to be opened.\n\n   ifname   The internal filename for the CK file that is being\n            created. The internal filename may be up to 60 characters\n            long. If you do not have any conventions for tagging your\n            files, an internal filename of \"CK_file\" is perfectly\n            acceptable. You may also leave it blank if you like.\n\n   ncomch   This is the space, measured in characters, to be\n            initially set aside for the comment area when a new CK\n            file is opened. The amount of space actually set aside\n            may be greater than the amount requested, due to the\n            manner in which comment records are allocated in an CK\n            file. However, the amount of space set aside for comments\n            will always be at least the amount that was requested.\n\n            The value of ncomch should be greater than or equal to\n            zero, i.e., 0 <= ncomch. A negative value, should one\n            occur, will be assumed to be zero.\n\n-Detailed_Output\n\n   handle   The handle of the opened CK file. If an error occurs the\n            value of this variable will not represent a valid handle.\n\n");

/* void ckupf_c ( SpiceInt handle ); */
static PyObject * spice_ckupf(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  ckupf_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ckupf_doc, "-Abstract\n\n   Unload a CK pointing file so that it will no longer be searched\n   by the readers.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of CK file to be unloaded\n\n-Detailed_Input\n\n   handle     Integer handle assigned to the file upon loading.\n\n-Detailed_Output\n\n   None.\n\n");

/* SpiceDouble clight_c ( void ); */
static PyObject * spice_clight(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = clight_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(clight_doc, "-Abstract\n\n   Return the speed of light in a vacuum (IAU official\n   value, in km/sec).\n\n-Brief_I/O\n\n   The function returns the speed of light in vacuo (km/sec).\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the IAU official value for the speed of light\n   in vacuo: 299792.458 km/sec.\n\n");

/* void clpool_c ( void ); */
static PyObject * spice_clpool(PyObject *self, PyObject *args)
{

  char failed = 0;

  clpool_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(clpool_doc, "-Abstract\n\n   Remove all variables from the kernel pool.\n\n-Brief_I/O\n\n   None.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   None.\n\n");

/* void cmprss_c ( SpiceChar delim,SpiceInt n,ConstSpiceChar * input,
SpiceInt lenout,SpiceChar * output ); */
static PyObject * spice_cmprss(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar output[STRING_LEN];
  /* variables for inputs */
  char delim;
  int n;
  char * input;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sis", &delim, &n, &input));
  cmprss_c(delim, n, input, lenout, output);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, output);
  return returnVal;
}
PyDoc_STRVAR(cmprss_doc, "-Abstract\n\n    Compress a character string by removing occurrences of\n    more than N consecutive occurrences of a specified\n    character.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    delim      I   Delimiter to be compressed.\n    n          I   Maximum consecutive occurrences of delim.\n    input      I   Input string.\n    lenout     I   Available space in output string.\n    output     O   Compressed string.\n\n-Detailed_Input\n\n    delim       is the delimiter to be compressed out of the string.\n                This may be any ASCII character.\n\n    n           is the maximum number of consecutive occurrences\n                of delim that will be allowed to remain in the\n                output string.\n\n    input       is the input string.\n\n    lenout      is the available space in the output string, counting\n                the terminating null.  lenout is typically the\n                declared length of the output string.\n\n-Detailed_Output\n\n    output      is the output string. This is the input string with all\n                occurrences of more than N consecutive delimiters\n                removed.  A null terminator will follow the last\n                character of the string resulting from the compression.\n\n                If output is not large enough to hold the compressed\n                string, it is truncated on the right.  The output string\n                will always be null-terminated.\n\n                output may overwrite input.\n\n");

/* void cnmfrm_c ( ConstSpiceChar * cname,SpiceInt lenout,SpiceInt * frcode,
SpiceChar * frname,SpiceBoolean * found ); */
static PyObject * spice_cnmfrm(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt frcode;
  SpiceChar frname[STRING_LEN];
  SpiceBoolean found;
  /* variables for inputs */
  char * cname;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &cname));
  cnmfrm_c(cname, lenout, &frcode, frname, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "s");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, frcode, frname);
  return returnVal;
  }

}
PyDoc_STRVAR(cnmfrm_doc, "-Abstract\n\n   Retrieve frame ID code and name to associate with an object.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   cname      I   Name of the object to find a frame for.\n   lenout     I   Maximum length available for frame name.\n   frcode     O   The ID code of the frame associated with cname.\n   frname     O   The name of the frame with ID frcode.\n   found      O   SPICETRUE if the requested information is available.\n\n-Detailed_Input\n\n   cname          is the name for object for which there is a\n                  preferred reference frame.\n\n   lenout         is the amount of space available, counting the\n                  space required for the terminating null character,\n                  in the output string frname.  Normally lenout is\n                  the declared length of frname.\n\n-Detailed_Output\n\n   frcode         is the frame id-code to associate with a the object\n                  specified by cname.\n\n   frname         is the name of the frame that should be associated\n                  with the object specified by cname.\n\n   found          is SPICETRUE if the appropriate frame id-code and\n                  frame name can be determined.  Otherwise found is\n                  returned with the value SPICEFALSE.\n\n");

/* void conics_c ( ConstSpiceDouble elts[8],SpiceDouble et,
SpiceDouble state[6] ); */
static PyObject * spice_conics(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble state[6];
  /* variables for inputs */
  double elts[8];
  double et;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddddd)d", &elts[0], &elts[1], &elts[2], &elts[3], &elts[4], &elts[5], &elts[6], &elts[7], &et));
  conics_c(elts, et, state);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, state[0], state[1], state[2], state[3], state[4], state[5]);
  return returnVal;
}
PyDoc_STRVAR(conics_doc, "-Abstract\n\n   Determine the state (position, velocity) of an orbiting body\n   from a set of elliptic, hyperbolic, or parabolic orbital\n   elements.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   elts       I   Conic elements.\n   et         I   Input time.\n   state      O   State of orbiting body at et.\n\n-Detailed_Input\n\n   elts       are conic osculating elements describing the orbit of a\n              body around a primary. The elements are, in order:\n\n                 RP      Perifocal distance.\n                 ECC     Eccentricity.\n                 INC     Inclination.\n                 LNODE   Longitude of the ascending node.\n                 ARGP    Argument of periapse.\n                 M0      Mean anomaly at epoch.\n                 T0      Epoch.\n                 MU      Gravitational parameter.\n\n              Units are km, rad, rad/sec, km**3/sec**2.\n\n              The epoch T0 is given in ephemeris seconds past J2000.\n              T0 is the instant at which the state of the body is\n              specified by the elements.\n\n              The same elements are used to describe all three types\n              (elliptic, hyperbolic, and parabolic) of conic orbit.\n\n   et         is the time at which the state of the orbiting body\n              is to be determined, in ephemeris seconds J2000.\n\n-Detailed_Output\n\n   state      is the state (position and velocity) of the body at\n              time `et'. Components are x, y, z, dx/dt, dy/dt, dz/dt.\n\n");

/* void convrt_c ( SpiceDouble x,ConstSpiceChar * in,ConstSpiceChar * out,
SpiceDouble * y ); */
static PyObject * spice_convrt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble y;
  /* variables for inputs */
  double x;
  char * in;
  char * out;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dss", &x, &in, &out));
  convrt_c(x, in, out, &y);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, y);
  return returnVal;
}
PyDoc_STRVAR(convrt_doc, "-Abstract\n\n    Take a measurement X, the units associated with\n    X, and units to which X should be converted; return Y ---\n    the value of the measurement in the output units.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  -------------------------------------------------\n   x          I   Number representing a measurement in some units.\n   in         I   The units in which x is measured.\n   out        I   Desired units for the measurement.\n   y          O   The measurment in the desired units.\n\n-Detailed_Input\n\n   x          is a number representing a measurement in the units\n              specified by in.\n\n   in         represents the units associated with a measurement x.\n              Acceptable units are:\n\n              Angles:                 \"RADIANS\"\n                                      \"DEGREES\"\n                                      \"ARCMINUTES\"\n                                      \"ARCSECONDS\"\n                                      \"HOURANGLE\"\n                                      \"MINUTEANGLE\"\n                                      \"SECONDANGLE\"\n\n              Metric Distances:       \"METERS\"\n                                      \"KM\"\n                                      \"CM\"\n                                      \"MM\"\n\n              English Distances:      \"FEET\"\n                                      \"INCHES\"\n                                      \"YARDS\"\n                                      \"STATUTE_MILES\"\n                                      \"NAUTICAL_MILES\"\n\n              Astrometric Distances:  \"AU\"\n                                      \"PARSECS\"\n                                      \"LIGHTSECS\"\n                                      \"LIGHTYEARS\" julian lightyears\n\n              Time:                   \"SECONDS\"\n                                      \"MINUTES\"\n                                      \"HOURS\"\n                                      \"DAYS\"\n                                      \"JULIAN_YEARS\"\n                                      \"TROPICAL_YEARS\"\n                                      \"YEARS\" (same as julian years)\n\n\n              The case of the string in is not significant.\n\n\n   out        represents the units desired for the measurement x.\n              See the description of in.\n\n              The case of the string out is not significant.\n\n\n-Detailed_Output\n\n   y          is the input measurement converted to the desired units.\n\n\n");

/* void copy_c ( SpiceCell * a,SpiceCell * b ); */
static PyObject * spice_copy(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  SpiceCell b;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  copy_c(&a, &b);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a), get_py_cell(&b));
  return returnVal;
}
PyDoc_STRVAR(copy_doc, "-Abstract\n\n   Copy the contents of a SpiceCell of any data type to another\n   cell of the same type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   cell       I   Cell to be copied.\n   copy       O   New cell.\n\n-Detailed_Input\n\n   cell        is a cell of character, double precision, or\n               integer data type.\n\n\n-Detailed_Output\n\n   copy        is a cell which contains the same elements as the\n               input cell, in the same order.\n\n");

/* SpiceInt cpos_c ( ConstSpiceChar * str,ConstSpiceChar * chars,
SpiceInt start ); */
static PyObject * spice_cpos(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * str;
  char * chars;
  int start;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &str, &chars, &start));
  result = cpos_c(str, chars, start);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(cpos_doc, "-Abstract\n\n   Find the first occurrence in a string of a character belonging\n   to a collection of characters, starting at a specified location,\n   searching forward.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   str        I   Any character string.\n   chars      I   A collection of characters.\n   start      I   Position to begin looking for one of chars.\n\n   The function returns the index of the first character of str\n   at or following index start that is in the collection chars.\n\n-Detailed_Input\n\n   str        is any character string.\n\n   chars      is a character string containing a collection\n              of characters.  Spaces in chars are significant,\n              including trailing blanks.  The order in which\n              characters are listed is not significant.\n\n   start      is the position in str to begin looking for one of\n              the characters in chars.  start may range from 0\n              to n-1, where n is the number of characters in str.\n\n-Detailed_Output\n\n   The function returns the index of the first character of str (at or\n   following index start) that is one of the characters in the string\n   chars.  The returned value normally ranges from 0 to n-1, where n is\n   the number of characters in str. If none of the characters is found,\n   the function returns -1.\n\n");

/* SpiceInt cposr_c ( ConstSpiceChar * str,ConstSpiceChar * chars,
SpiceInt start ); */
static PyObject * spice_cposr(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * str;
  char * chars;
  int start;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &str, &chars, &start));
  result = cposr_c(str, chars, start);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(cposr_doc, "-Abstract\n\n   Find the first occurrence in a string of a character belonging\n   to a collection of characters, starting at a specified location,\n   searching in reverse.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   str        I   Any character string.\n   chars      I   A collection of characters.\n   start      I   Position to begin looking for one of chars.\n\n   The function returns the index of the last character of str\n   at or before index start that is in the collection chars.\n\n-Detailed_Input\n\n   str        is any character string.\n\n   chars      is a character string containing a collection\n              of characters.  Spaces in chars are significant,\n              including trailing blanks.  The order in which\n              characters are listed is not significant.\n\n   start      is the position in str to begin looking for one of\n              the characters in chars.  start may range from 0\n              to n-1, where n is the number of characters in str.\n\n-Detailed_Output\n\n   The function returns the index of the last character of str (at or\n   before index start) that is one of the characters in the string\n   chars.  The returned value normally ranges from 0 to n-1, where n is\n   the number of characters in str. If none of the characters is found,\n   the function returns -1.\n\n");

/* void cvpool_c ( ConstSpiceChar * agent,SpiceBoolean * update ); */
static PyObject * spice_cvpool(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceBoolean update;
  /* variables for inputs */
  char * agent;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &agent));
  cvpool_c(agent, &update);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_boolean(&update));
  return returnVal;
}
PyDoc_STRVAR(cvpool_doc, "-Abstract\n\n   Determine whether or not any of the variables that are to be watched\n   and have a specified agent on their distribution list have been\n   updated.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   agent      I   Name of the agent to check for notices.\n   update     O   SPICETRUE if variables for agent have been updated.\n\n-Detailed_Input\n\n   agent     is the name of a function or significant portion of code\n             that needs to access variables in the kernel pool.\n             Generally this agent will buffer these variables\n             internally and fetch them from the kernel pool only when\n             they are updated.\n\n-Detailed_Output\n\n   update    is a logical flag that will be set to SPICETRUE if the\n             variables in the kernel pool that are required by agent\n             have been updated since the last call to cvpool_c.\n\n");

/* void cyllat_c ( SpiceDouble r,SpiceDouble lonc,SpiceDouble z,
SpiceDouble * radius,SpiceDouble * lon,SpiceDouble * lat ); */
static PyObject * spice_cyllat(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble radius;
  SpiceDouble lon;
  SpiceDouble lat;
  /* variables for inputs */
  double r;
  double lonc;
  double z;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &r, &lonc, &z));
  cyllat_c(r, lonc, z, &radius, &lon, &lat);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, radius, lon, lat);
  return returnVal;
}
PyDoc_STRVAR(cyllat_doc, "-Abstract\n\n   Convert from cylindrical to latitudinal coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   r          I   Distance of point from z axis.\n   lonc       I   Cylindrical angle of point from XZ plane(radians).\n   z          I   Height of point above XY plane.\n   radius     O   Distance of point from origin.\n   lon        O   Longitude of point (radians).\n   lat        O   Latitude of point (radians).\n\n-Detailed_Input\n\n   r          Distance of the input point from z axis.\n\n   lonc       Cylindrical angle of the point from XZ plane(radians).\n\n   z          Height of the point above XY plane.\n\n-Detailed_Output\n\n   radius     Distance of the input point from origin.\n\n   lon        Longitude (i.e. angle from the XZ plane) of the input\n              point.\n\n   lat        Latitude (i.e. angle above the XY plane) of the input\n              point (radians).\n\n");

/* void cylrec_c ( SpiceDouble r,SpiceDouble lon,SpiceDouble z,
SpiceDouble rectan[3] ); */
static PyObject * spice_cylrec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rectan[3];
  /* variables for inputs */
  double r;
  double lon;
  double z;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &r, &lon, &z));
  cylrec_c(r, lon, z, rectan);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rectan[0], rectan[1], rectan[2]);
  return returnVal;
}
PyDoc_STRVAR(cylrec_doc, "-Abstract\n\n   Convert from cylindrical to rectangular coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  -------------------------------------------------\n   r          I   Distance of a point from z axis.\n   lon        I   Angle (radians) of a point from xZ plane\n   z          I   Height of a point above xY plane.\n   rectan     O   Rectangular coordinates of the point.\n\n-Detailed_Input\n\n   r          Distance of the point of interest from z axis.\n\n   lon        Cylindrical angle (in radians) of the point of\n              interest from XZ plane.\n\n   z          Height of the point above XY plane.\n\n-Detailed_Output\n\n   rectan     Rectangular coordinates of the point of interest.\n\n");

/* void cylsph_c ( SpiceDouble r,SpiceDouble lonc,SpiceDouble z,
SpiceDouble * radius,SpiceDouble * colat,SpiceDouble * lon ); */
static PyObject * spice_cylsph(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble radius;
  SpiceDouble colat;
  SpiceDouble lon;
  /* variables for inputs */
  double r;
  double lonc;
  double z;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &r, &lonc, &z));
  cylsph_c(r, lonc, z, &radius, &colat, &lon);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, radius, colat, lon);
  return returnVal;
}
PyDoc_STRVAR(cylsph_doc, "-Abstract\n\n   Convert from cylindrical to spherical coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  -------------------------------------------------\n   r          I   Distance of point from z axis.\n   lonc       I   Angle (radians) of point from XZ plane.\n   z          I   Height of point above XY plane.\n   radius     O   Distance of point from origin.\n   colat      O   Polar angle (co-latitude in radians) of point.\n   lon        O   Azimuthal angle (longitude) of point (radians).\n\n-Detailed_Input\n\n   r          Distance of the point of interest from z axis.\n\n   lonc       Cylindrical angle (radians) of the point from the\n              XZ plane.\n\n   z          Height of the point above XY plane.\n\n-Detailed_Output\n\n   radius     Distance of the point from origin.\n\n   colat      Polar angle (co-latitude in radians) of the point.\n\n   lon        Azimuthal angle (longitude) of the point (radians).\n\n");

/* void dafbbs_c ( SpiceInt handle ); */
static PyObject * spice_dafbbs(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  dafbbs_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(dafbbs_doc, "-Abstract\n\n   Begin a backward search for arrays in a DAF.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of DAF to be searched.\n\n-Detailed_Input\n\n   handle      is the handle of a DAF on which a backward\n               search is to be conducted.\n\n-Detailed_Output\n\n   None.\n\n");

/* void dafbfs_c ( SpiceInt handle ); */
static PyObject * spice_dafbfs(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  dafbfs_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(dafbfs_doc, "-Abstract\n\n   Begin a forward search for arrays in a DAF.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of file to be searched.\n\n-Detailed_Input\n\n   handle      is the handle of a DAF on which a forward\n               search is to be conducted.\n\n-Detailed_Output\n\n   None.\n\n");

/* void dafcls_c ( SpiceInt handle ); */
static PyObject * spice_dafcls(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  dafcls_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(dafcls_doc, "-Abstract\n\n   Close the DAF associated with a given handle.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of DAF to be closed.\n\n-Detailed_Input\n\n   handle      is the file handle of a previously opened DAF file.\n\n-Detailed_Output\n\n   None.\n\n");

/* void dafcs_c ( SpiceInt handle ); */
static PyObject * spice_dafcs(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  dafcs_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(dafcs_doc, "-Abstract\n\n   Select a DAF that already has a search in progress as the\n   one to continue searching.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of DAF to continue searching.\n\n-Detailed_Input\n\n   handle         is the handle of a DAF in which either a forward\n                  or backward search has already been started by\n                  dafbfs_c or dafbbs_c.  The DAF may be open for read\n                  or write access.\n\n-Detailed_Output\n\n   None.\n\n");

/* void dafdc_c ( SpiceInt handle ); */
static PyObject * spice_dafdc(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  dafdc_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(dafdc_doc, "-Abstract\n\n   Delete the entire comment area of a specified DAF file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   The handle of a binary DAF opened for writing.\n\n-Detailed_Input\n\n   handle    is the handle of a binary DAF that is to have its entire\n             comment area deleted. The DAF must have been opened\n             with write access.\n\n-Detailed_Output\n\n   None.\n\n");

/* void daffna_c ( SpiceBoolean * found ); */
static PyObject * spice_daffna(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceBoolean found;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  daffna_c(&found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */

  if(found) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(daffna_doc, "-Abstract\n\n   Find the next (forward) array in the current DAF.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   found      O   SPICETRUE if an array was found.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   found       is SPICETRUE if an array was found, and is SPICEFALSE\n               if, when this routine is called, the current array is\n               the tail of the array list.  (Recall that the arrays in\n               a DAF may be viewed as a doubly linked list, with the\n               tail being the last array in the file.)\n\n");

/* void daffpa_c ( SpiceBoolean * found ); */
static PyObject * spice_daffpa(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceBoolean found;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  daffpa_c(&found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */

  if(found) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(daffpa_doc, "-Abstract\n\n   Find the previous (backward) array in the current DAF.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   found      O   SPICETRUE if an array was found.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   found       is SPICETRUE if an array was found, and is SPICEFALSE\n               if, when this routine is called, the current array is\n               the head of the array list.  (Recall that the arrays in\n               a DAF may be viewed as a doubly linked list, with the\n               head being the first array in the file.)\n\n");

/* void dafgda_c ( SpiceInt handle,SpiceInt begin,SpiceInt end,
SpiceDouble * data ); */
static PyObject * spice_dafgda(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble data;
  /* variables for inputs */
  int handle;
  int begin;
  int end;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &handle, &begin, &end));
  dafgda_c(handle, begin, end, &data);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, data);
  return returnVal;
}
PyDoc_STRVAR(dafgda_doc, "-Abstract\n\n   Read the double precision data bounded by two addresses within\n   a DAF.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of a DAF.\n   begin,\n   end        I   Initial, final address within file.\n   data       O   Data contained between `begin' and `end'.\n\n-Detailed_Input\n\n   handle      is the handle of a DAF.\n\n   begin,\n   end         are the initial and final addresses of a contiguous\n               set of double precision numbers within a DAF.\n               Presumably, these make up all or part of a particular\n               array.\n\n               Note that CSPICE DAF addresses begin at 1 as in the\n               FORTRAN version of the SPICE Toolkit.\n\n-Detailed_Output\n\n   data        are the double precision data contained between\n               the specified addresses within the specified file.\n\n");

/* void dafgn_c ( SpiceInt lenout,SpiceChar * name ); */
static PyObject * spice_dafgn(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar name[STRING_LEN];
  /* variables for inputs */
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  dafgn_c(lenout, name);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, name);
  return returnVal;
}
PyDoc_STRVAR(dafgn_doc, "-Abstract\n\n   Return (get) the name for the current array in the current DAF.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   lenout     I   Length of array name string.\n   name       O   Name of current array.\n\n-Detailed_Input\n\n   lenout         is the length of the name string, including room for\n                  the null terminator. For a DAF with summary\n                  parameters ND and NI, the maximum length of an array\n                  name is\n\n                                        (NI + 1)\n                     NC  =   8 * ( ND + -------- ) (Note that this is\n                                            2       integer division.)\n\n                  Given NC, lenout should be set equal to NC+1.\n\n-Detailed_Output\n\n   name        is the name for the current array (the array found by\n               the latest call to daffna_c or daffpa_c).\n\n");

/* void dafgsr_c ( SpiceInt handle,SpiceInt recno,SpiceInt begin,SpiceInt end,
SpiceDouble * data,SpiceBoolean * found ); */
static PyObject * spice_dafgsr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble data;
  SpiceBoolean found;
  /* variables for inputs */
  int handle;
  int recno;
  int begin;
  int end;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiii", &handle, &recno, &begin, &end));
  dafgsr_c(handle, recno, begin, end, &data, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, data);
  return returnVal;
  }

}
PyDoc_STRVAR(dafgsr_doc, "-Abstract\n\n   Read a portion of the contents of a summary record in a DAF file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of DAF.\n   recno      I   Record number.\n   begin      I   First word to read from record.\n   end        I   Last word to read from record.\n   data       O   Contents of record.\n   found      O   True if record is found.\n\n-Detailed_Input\n\n   handle      is the handle associated with a DAF.\n\n   recno       is the record number of a particular double precision\n               record within the DAF, whose contents are to be read.\n               DAF record numbers start at 1.\n\n   begin       is the first word in the specified record to be\n               returned.  For compatibility with SPICELIB, word\n               numbers range from 1 to 128.\n\n   end         is the final word in the specified record to be\n               returned.  For compatibility with SPICELIB, word\n               numbers range from 1 to 128.\n\n-Detailed_Output\n\n   data        contains the specified portion (from `begin' to `end',\n               inclusive) of the specified record.\n\n   found       is SPICETRUE when the specified record is found, and is\n               SPICEFALSE otherwise.\n\n");

/* void dafopr_c ( ConstSpiceChar * fname,SpiceInt * handle ); */
static PyObject * spice_dafopr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &fname));
  dafopr_c(fname, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(dafopr_doc, "-Abstract\n\n   Open a DAF for subsequent read requests.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   fname      I   Name of DAF to be opened.\n   handle     O   Handle assigned to DAF.\n\n-Detailed_Input\n\n   fname       is the file name of a DAF to be opened for read\n               access.\n\n-Detailed_Output\n\n   handle      is the file handle associated with the file. This\n               handle is used to identify the file in subsequent\n               calls to other DAF routines.\n\n");

/* void dafopw_c ( ConstSpiceChar * fname,SpiceInt * handle ); */
static PyObject * spice_dafopw(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &fname));
  dafopw_c(fname, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(dafopw_doc, "-Abstract\n\n   Open a DAF for subsequent write requests.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   fname      I   Name of DAF to be opened.\n   handle     O   Handle assigned to DAF.\n\n-Detailed_Input\n\n   fname       is the name of a DAF to be opened with write\n               access.\n\n-Detailed_Output\n\n   handle      is the file handle associated with the file. This\n               handle is used to identify the file in subsequent\n               calls to other DAF routines.\n\n");

/* void dafrda_c ( SpiceInt handle,SpiceInt begin,SpiceInt end,
SpiceDouble * data ); */
static PyObject * spice_dafrda(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble data;
  /* variables for inputs */
  int handle;
  int begin;
  int end;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &handle, &begin, &end));
  dafrda_c(handle, begin, end, &data);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, data);
  return returnVal;
}
PyDoc_STRVAR(dafrda_doc, "-Abstract\n\n   Read the double precision data bounded by two addresses within\n   a DAF.\n\n   Deprecated:  This routine has been superseded by dafgda_c and\n   dafgsr_c.  This routine is supported for purposes of backward\n   compatibility only.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of a DAF.\n   begin,\n   end        I   Initial, final address within file.\n   data       O   Data contained between begin and end.\n\n-Detailed_Input\n\n   handle      is the handle of a DAF.\n\n   begin,\n   end         are the initial and final addresses of a contiguous\n               set of double precision numbers within a DAF.\n               Presumably, these make up all or part of a particular\n               array.\n\n               Note that CSPICE DAF addresses begin at 1 as in the\n               FORTRAN version of the SPICE Toolkit.\n\n-Detailed_Output\n\n   data        are the double precision data contained between\n               the specified addresses within the specified file.\n\n");

/* void dafrfr_c ( SpiceInt handle,SpiceInt lenout,SpiceInt * nd,SpiceInt * ni,
SpiceChar * ifname,SpiceInt * fward,SpiceInt * bward,SpiceInt * free ); */
static PyObject * spice_dafrfr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt nd;
  SpiceInt ni;
  SpiceChar ifname[STRING_LEN];
  SpiceInt fward;
  SpiceInt bward;
  SpiceInt free_;
  /* variables for inputs */
  int handle;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  dafrfr_c(handle, lenout, &nd, &ni, ifname, &fward, &bward, &free_);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, nd, ni, ifname, fward, bward, free_);
  return returnVal;
}
PyDoc_STRVAR(dafrfr_doc, "-Abstract\n\n   Read the contents of the file record of a DAF.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of an open DAF file.\n   lenout     I   Available room in the output string `ifname'.\n   nd         O   Number of double precision components in summaries.\n   ni         O   Number of integer components in summaries.\n   ifname     O   Internal file name.\n   fward      O   Forward list pointer.\n   bward      O   Backward list pointer.\n   free       O   Free address pointer.\n\n-Detailed_Input\n\n   handle         is the handle assigned to a DAF file opened for\n                  reading.\n\n   lenout         is the maximum number of characters that can be\n                  accommodated in the output string `ifname'. This count\n                  includes room for the terminating null character.\n                  DAF internal file names may contain up to 60\n                  characters, so lenout normally should be set to 61.\n\n-Detailed_Output\n\n   nd,\n   ni          are the numbers of double precision and integer\n               components, respectively, in each array summary in\n               the specified file.\n\n   ifname      is the internal file name stored in the first\n               (or file) record of the specified file. `ifname'\n               should be declared with the length specified by\n               `lenout'.\n\n   fward       is the forward list pointer. This points to the\n               first summary record in the file. (Records between\n               the first record and the first summary record are\n               reserved when the file is created, and are invisible\n               to DAF routines.)\n\n               DAF list pointers are actually Fortran record numbers,\n               and as such, start at one.\n\n   bward       is the backward list pointer. This points\n               to the final summary record in the file.\n\n\n   free        is the free address pointer. This contains the\n               first free address in the file. (That is, the\n               initial address of the next array to be added\n               to the file.)\n\n               `free' is a DAF address; for compatiblity with\n               SPICELIB, the range of DAF addresses starts at 1.\n\n");

/* void dafrs_c ( ConstSpiceDouble * sum ); */
static PyObject * spice_dafrs(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double * sum;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &sum));
  dafrs_c(sum);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(dafrs_doc, "-Abstract\n\n   Change the summary for the current array in the current DAF.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sum        I   New summary for current array.\n\n-Detailed_Input\n\n   sum         is the new summary for the current array. This\n               replaces the existing summary. However, the addresses\n               (the final two integer components) of the original\n               summary are not changed.\n\n-Detailed_Output\n\n   None.\n\n");

/* void dascls_c ( SpiceInt handle ); */
static PyObject * spice_dascls(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  dascls_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(dascls_doc, "-Abstract\n\n   Close a DAS file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of an open DAS file.\n   FTSIZE     P   Maximum number of simultaneously open DAS files.\n\n-Detailed_Input\n\n   handle         is the file handle of an open DAS file.\n\n-Detailed_Output\n\n   None.  See $Particulars for a description of the effect of this\n   routine.\n\n");

/* void dasopr_c ( ConstSpiceChar * fname,SpiceInt * handle ); */
static PyObject * spice_dasopr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &fname));
  dasopr_c(fname, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(dasopr_doc, "-Abstract\n\n   Open a DAS file for reading.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   fname      I   Name of a DAS file to be opened.\n   handle     O   Handle assigned to the opened DAS file.\n\n-Detailed_Input\n\n   fname       is the name of a DAS file to be opened with read\n               access.\n\n-Detailed_Output\n\n   handle      is the handle that is  associated with the file. This\n               handle is used to identify the file in subsequent\n               calls to other DAS routines.\n\n");

/* void dcyldr_c ( SpiceDouble x,SpiceDouble y,SpiceDouble z,
SpiceDouble jacobi[3][3] ); */
static PyObject * spice_dcyldr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  double x;
  double y;
  double z;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &x, &y, &z));
  dcyldr_c(x, y, z, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(dcyldr_doc, "-Abstract\n\n   This routine computes the Jacobian of the transformation from\n   rectangular to cylindrical coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   x          I   X-coordinate of point.\n   y          I   Y-coordinate of point.\n   z          I   Z-coordinate of point.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   x,\n   y,\n   z          are the rectangular coordinates of the point at\n              which the Jacobian of the map from rectangular\n              to cylindrical coordinates is desired.\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              between rectangular and cylindrical coordinates.  It\n              has the form\n\n                 .-                            -.\n                 |  dr  /dx   dr  /dy  dr  /dz  |\n                 |  dlon/dx   dlon/dy  dlon/dz  |\n                 |  dz  /dx   dz  /dy  dz  /dz  |\n                 `-                            -'\n\n              evaluated at the input values of x, y, and z.\n\n");

/* void deltet_c ( SpiceDouble epoch,ConstSpiceChar * eptype,
SpiceDouble * delta ); */
static PyObject * spice_deltet(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble delta;
  /* variables for inputs */
  double epoch;
  char * eptype;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ds", &epoch, &eptype));
  deltet_c(epoch, eptype, &delta);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, delta);
  return returnVal;
}
PyDoc_STRVAR(deltet_doc, "-Abstract\n\n   Return the value of Delta ET (ET-UTC) for an input epoch.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   epoch      I   Input epoch (seconds past J2000).\n   eptype     I   Type of input epoch (\"UTC\" or \"ET\").\n   delta      O   Delta ET (ET-UTC) at input epoch.\n\n-Detailed_Input\n\n   epoch       is the epoch at which \"delta ET\" is to be computed.\n               `epoch' may be either UTC or ephemeris seconds past\n               J2000, as specified by EPTYPE.\n\n   eptype      indicates the type of input epoch. It may be either\n               of the following:\n\n                  \"UTC\"    UTC seconds past J2000 UTC.\n\n                  \"ET\"     Ephemeris seconds past J2000 TDB,\n                           also known as barycentric dynamical\n                           time (TDB).\n\n-Detailed_Output\n\n   delta       is the value of\n\n                  \"delta ET\" = ET - UTC\n\n               at the input epoch. This is added to UTC to give\n               ET, or subtracted from ET to give UTC. The routine\n               is reversible: that is, given the following calls,\n\n                  deltet_c ( utc,      \"UTC\", &del1 );\n                  deltet_c ( utc+del1, \"ET\",  &del2 );\n\n               the expression\n\n                  ( del1 == del2 )\n\n               is true.\n\n");

/* SpiceDouble det_c ( ConstSpiceDouble m1[3][3] ); */
static PyObject * spice_det(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double m1[3][3];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2]));
  result = det_c(m1);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(det_doc, "-Abstract\n\n    Compute the determinant of a double precision 3x3 matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   m1         I     Matrix whose determinant is to be found.\n\n-Detailed_Input\n\n   m1      This variable may be any double precision, 3x3 matrix.\n\n-Detailed_Output\n\n   det_c   This is the value of the determinant found by direct\n           application of the definition of the determinant.\n\n");

/* void diags2_c ( ConstSpiceDouble symmat [2][2],SpiceDouble diag [2][2],
SpiceDouble rotate [2][2] ); */
static PyObject * spice_diags2(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble diag[2][2];
  SpiceDouble rotate[2][2];
  /* variables for inputs */
  double symmat[2][2];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((dd)(dd))", &symmat[0][0], &symmat[0][1], &symmat[1][0], &symmat[1][1]));
  diags2_c(symmat, diag, rotate);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((dd)(dd))");
  strcat(buildvalue_string, "((dd)(dd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, diag[0][0], diag[0][1], diag[1][0], diag[1][1], rotate[0][0], rotate[0][1], rotate[1][0], rotate[1][1]);
  return returnVal;
}
PyDoc_STRVAR(diags2_doc, "-Abstract\n\n   Diagonalize a symmetric 2x2 matrix.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n\n   symmat     I   A symmetric 2x2 matrix.\n   diag       O   A diagonal matrix similar to symmat.\n   rotate     O   A rotation used as the similarity transformation.\n\n-Detailed_Input\n\n   symmat         A symmetric 2x2 matrix.  That is, symmat has the\n                  form\n\n                     +-        -+\n                     |  A    B  |\n                     |          |.\n                     |  B    C  |\n                     +-        -+\n\n                  This routine uses only the upper-triangular\n                  elements of symmat, that is, the elements\n\n                     symmat[0][0]\n                     symmat[0][1]\n                     symmat[1][1]\n\n                  to determine the outputs diag and rotate.\n\n-Detailed_Output\n\n   diag,\n   rotate         are, respectively, a diagonal matrix and a 2x2\n                  rotation matrix that satisfy the equation\n\n                                      T\n                     diag   =   rotate    *  symmat  *  rotate.\n\n                  In other words, diag is similar to symmat, and\n                  rotate is a change-of-basis matrix that\n                  diagonalizes symmat.  diags2_c chooses rotate so\n                  that its angle of rotation has the smallest\n                  possible magnitude.  If there are two rotations\n                  that meet these criteria (they will be inverses of\n                  one another), either rotation may be chosen.\n\n");

/* void diff_c ( SpiceCell * a,SpiceCell * b,SpiceCell * c ); */
static PyObject * spice_diff(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  SpiceCell b;
  SpiceCell c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  diff_c(&a, &b, &c);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a), get_py_cell(&b), get_py_cell(&c));
  return returnVal;
}
PyDoc_STRVAR(diff_doc, "-Abstract\n\n   Take the difference of two sets of any data type to form a third\n   set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   First input set.\n   b          I   Second input set.\n   c          O   Difference of a and b.\n\n-Detailed_Input\n\n   a           is a CSPICE set.  a must be declared as a SpiceCell\n               of data type character, double precision, or integer.\n\n   b           is a CSPICE set, distinct from a.  b must have the\n               same data type as a.\n\n-Detailed_Output\n\n   c           is a CSPICE set, distinct from sets a and b, which\n               contains the difference of a and b (that is, all of\n               the elements which are in a but NOT in b).  c must\n               have the same data type as a and b.\n\n               When comparing elements of character sets, this routine\n               ignores trailing blanks.  Trailing blanks will be\n               trimmed from the members of the output set c.\n\n");

/* void dgeodr_c ( SpiceDouble x,SpiceDouble y,SpiceDouble z,SpiceDouble re,
SpiceDouble f,SpiceDouble jacobi[3][3] ); */
static PyObject * spice_dgeodr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  double x;
  double y;
  double z;
  double re;
  double f;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddddd", &x, &y, &z, &re, &f));
  dgeodr_c(x, y, z, re, f, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(dgeodr_doc, "-Abstract\n\n   This routine computes the Jacobian of the transformation from\n   rectangular to geodetic coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   X          I   X-coordinate of point.\n   Y          I   Y-coordinate of point.\n   Z          I   Z-coordinate of point.\n   RE         I   Equatorial radius of the reference spheroid.\n   F          I   Flattening coefficient.\n   JACOBI     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   x,\n   y,\n   z          are the rectangular coordinates of the point at\n              which the Jacobian of the map from rectangular\n              to geodetic coordinates is desired.\n\n   re         Equatorial radius of the reference spheroid.\n\n   f          Flattening coefficient = (re-rp) / re,  where rp is\n              the polar radius of the spheroid.  (More importantly\n              rp = re*(1-f).)\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              between rectangular and geodetic coordinates.  It\n              has the form\n\n                  .-                            -.\n                  |  dlon/dx   dlon/dy  dlon/dz  |\n                  |  dlat/dx   dlat/dy  dlat/dz  |\n                  |  dalt/dx   dalt/dy  dalt/dz  |\n                  `-                            -'\n\n             evaluated at the input values of x, y, and z.\n\n");

/* void dlatdr_c ( SpiceDouble x,SpiceDouble y,SpiceDouble z,
SpiceDouble jacobi[3][3] ); */
static PyObject * spice_dlatdr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  double x;
  double y;
  double z;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &x, &y, &z));
  dlatdr_c(x, y, z, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(dlatdr_doc, "-Abstract\n\n   This routine computes the Jacobian of the transformation from\n   rectangular to latitudinal coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   x          I   X-coordinate of point.\n   y          I   Y-coordinate of point.\n   z          I   Z-coordinate of point.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   x,\n   y,\n   z          are the rectangular coordinates of the point at\n              which the Jacobian of the map from rectangular\n              to latitudinal coordinates is desired.\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              between rectangular and latitudinal coordinates.  It\n              has the form\n\n                 .-                             -.\n                 |  dr/dx     dr/dy     dr/dz    |\n                 |  dlon/dx   dlon/dy   dlon/dz  |\n                 |  dlat/dx   dlat/dy   dlat/dz  |\n                 `-                             -'\n\n              evaluated at the input values of x, y, and z.\n\n");

/* void dp2hx_c ( SpiceDouble number,SpiceInt lenout,SpiceChar * string,
SpiceInt * length); */
static PyObject * spice_dp2hx(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar string[STRING_LEN];
  SpiceInt length;
  /* variables for inputs */
  double number;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &number));
  dp2hx_c(number, lenout, string, &length);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, string, length);
  return returnVal;
}
PyDoc_STRVAR(dp2hx_doc, "-Abstract\n\n   Convert a double precision number to an equivalent character\n   string using base 16 ``scientific notation.''\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   number     I   D.p. number to be converted.\n   lenout     I   Available space for output string 'string'.\n   string     O   Equivalent character string, left justified.\n   length     O   Length of the character string produced.\n\n-Detailed_Input\n\n   number   The double precision number to be converted to a\n            character string representation.\n\n   lenout   is the maximum length of the output 'string'. The value\n            defined by lenout should be one plus the value large\n            enough to hold any possible output.\n\n-Detailed_Output\n\n   string   The character string produced by this routine that\n            represents 'number' in base 16 ``scientific notation,''\n            e.g.:\n\n               672.0 = '2A^3' = ( 2/16 + 10/( 16**2 ) ) * 16**3\n\n            and\n\n               -11.0 = '-B^1' = - ( 11/16 ) * 16**1.\n\n            The following table describes the character set used to\n            represent the hexadecimal digits and their corresponding\n            values.\n\n                 Character    Value         Character    Value\n                 ---------    ------        ---------    ------\n                   '0'         0.0D0          '8'         8.0D0\n                   '1'         1.0D0          '9'         9.0D0\n                   '2'         2.0D0          'A'        10.0D0\n                   '3'         3.0D0          'B'        11.0D0\n                   '4'         4.0D0          'C'        12.0D0\n                   '5'         5.0D0          'D'        13.0D0\n                   '6'         6.0D0          'E'        14.0D0\n                   '7'         7.0D0          'F'        15.0D0\n\n            The caret, or hat, character, '^', is used to distinguish\n            the exponent.\n\n            The plus sign, '+', and the minus sign, '-' have the expected\n            meanings.\n\n            In order to obtain the entire character string produced\n            by this routine, the output character string should be\n            at least N characters long, where\n\n\n                      # of bits per double precision mantissa + 3\n            N = 3 + ----------------------------------------------\n                                          4\n\n                      # of bits per double precision exponent + 3\n                  + ---------------------------------------------- .\n                                          4\n\n            There should be one character position for the sign of\n            the mantissa, one for the sign of the exponent, one for\n            the exponentiation character, and one for each\n            hexadecimal digit that could be produced from a mantissa\n            and an exponent.\n\n            The following table contains minimum output string\n            lengths necessary to obtain the complete character\n            string produced by this routine for some typical\n            implementations of double precision numbers.\n\n            Double precision number\n            Size Mantissa Exponent    Minimum output string length\n            bits   bits     bits\n            ---- -------- --------    ----------------------------\n            64   48       15          3 + 12 + 4 = 19\n            64   55+1     8           3 + 14 + 2 = 19 (VAX)\n            64   52       11          3 + 13 + 3 = 19 (IEEE)\n\n            The base 16 ``scientific notation'' character string\n            produced by this routine will be left justified and\n            consist of a contiguous sequence of characters with one\n            of the following formats:\n\n                (1)   h h h h  ... h ^H H  ... H\n                       1 2 3 4      n  1 2      m\n\n                (2)   -h h h h  ... h ^H H  ... H\n                        1 2 3 4      n  1 2      m\n\n                (3)   h h h h  ... h ^-H H  ... H\n                       1 2 3 4      n   1 2      m\n\n                (4)   -h h h h  ... h ^-H H  ... H\n                        1 2 3 4      n   1 2      m\n\n            where\n\n               h   and  H   denote hexadecimal digits\n                i        j\n\n               '^'          denotes exponentiation ( base 16 )\n\n            and\n\n               '+' and '-'  have their usual interpretations.\n\n   length   the length of the base 16 ``scientific notation'' character\n            'string' returned by this routine.\n\n");

/* void dpgrdr_c ( ConstSpiceChar * body,SpiceDouble x,SpiceDouble y,
SpiceDouble z,SpiceDouble re,SpiceDouble f,SpiceDouble jacobi[3][3] ); */
static PyObject * spice_dpgrdr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  char * body;
  double x;
  double y;
  double z;
  double re;
  double f;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sddddd", &body, &x, &y, &z, &re, &f));
  dpgrdr_c(body, x, y, z, re, f, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(dpgrdr_doc, "-Abstract\n\n   This routine computes the Jacobian matrix of the transformation\n   from rectangular to planetographic coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   body       I   Body with which coordinate system is associated.\n   x          I   X-coordinate of point.\n   y          I   Y-coordinate of point.\n   z          I   Z-coordinate of point.\n   re         I   Equatorial radius of the reference spheroid.\n   f          I   Flattening coefficient.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   body       Name of the body with which the planetographic\n              coordinate system is associated.\n\n              `body' is used by this routine to look up from the\n              kernel pool the prime meridian rate coefficient giving\n              the body's spin sense.  See the Files and Particulars\n              header sections below for details.\n\n   x,\n   y,\n   z          are the rectangular coordinates of the point at\n              which the Jacobian of the map from rectangular\n              to planetographic coordinates is desired.\n\n   re         Equatorial radius of the reference spheroid.\n\n   f          Flattening coefficient = (re-rp) / re,  where rp is\n              the polar radius of the spheroid.  (More importantly\n              rp = re*(1-f).)\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              from rectangular to planetographic coordinates.  It\n              has the form\n\n                  .-                               -.\n                  |  DLON/DX    DLON/DY   DLON/DZ   |\n                  |  DLAT/DX    DLAT/DY   DLAT/DZ   |\n                  |  DALT/DX    DALT/DY   DALT/DZ   |\n                  `-                               -'\n\n             evaluated at the input values of `x', `y', and `z'.\n\n");

/* SpiceDouble dpmax_c ( void ); */
static PyObject * spice_dpmax(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = dpmax_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(dpmax_doc, "-Abstract\n\n   Return the value of the largest (positive) number representable\n   in a double precision variable.\n\n-Brief_I/O\n\n   The function returns the value of the largest (positive) number\n   that can be represented in a double precision variable.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the value of the largest (positive) number\n   that can be represented in a double precision variable.\n\n   This value varies from machine to machine.  The value is defined by\n   the macro DBL_MAX from the ANSI standard header file float.h.\n   According to the ANSI standard, DBL_MAX must be at least\n\n      1.E+37\n\n\n");

/* SpiceDouble dpmax_ ( void ); */
static PyObject * spice_dpmax_(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = dpmax_();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(dpmax__doc, "");

/* SpiceDouble dpmin_c ( void ); */
static PyObject * spice_dpmin(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = dpmin_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(dpmin_doc, "-Abstract\n\n   Return the value of the smallest (negative) number representable\n   in a double precision variable.\n\n-Brief_I/O\n\n   The function returns the value of the smallest (negative) number\n   that can be represented in a double precision variable.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the value of the smallest (negative) number\n   that can be represented in a double precision variable.\n\n   This value varies from machine to machine.  Usually, the value is\n   defined as the negative of the macro DBL_MAX from the ANSI standard\n   header file float.h.  According to the ANSI standard, DBL_MAX must be\n   at least\n\n      1.E+37\n\n   Therefore dpmin_c usually returns a value less than or equal to\n\n     -1.E+37\n\n   Exceptional systems would be those where DBL_MAX cannot be negated.\n   Currently no such systems are supported.\n\n");

/* SpiceDouble dpmin_ ( void ); */
static PyObject * spice_dpmin_(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = dpmin_();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(dpmin__doc, "");

/* SpiceDouble dpr_c ( void ); */
static PyObject * spice_dpr(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = dpr_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(dpr_doc, "-Abstract\n\n   Return the number of degrees per radian.\n\n-Brief_I/O\n\n   The function returns the number of degrees per radian.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the number of degrees per radian: 180/pi.\n   The value of pi is determined by the ACOS function. That is,\n\n         dpr_c = 180. / acos ( -1. );\n\n");

/* void drdcyl_c ( SpiceDouble r,SpiceDouble lon,SpiceDouble z,
SpiceDouble jacobi[3][3] ); */
static PyObject * spice_drdcyl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  double r;
  double lon;
  double z;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &r, &lon, &z));
  drdcyl_c(r, lon, z, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(drdcyl_doc, "-Abstract\n\n   This routine computes the Jacobian of the transformation from\n   cylindrical to rectangular coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   r          I   Distance of a point from the origin.\n   lon        I   Angle of the point from the xz plane in radians.\n   z          I   Height of the point above the xy plane.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   r          Distance of the point of interest from z axis.\n\n   lon        Cylindrical angle (in radians) of the point of\n              interest from xz plane.  The angle increases in the\n              counterclockwise sense about the +z axis.\n\n   z          Height of the point above xy plane.\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              between cylindrical and rectangular coordinates.  It\n              has the form\n\n                 .-                               -.\n                 |  dx/dr     dx/dlon     dx/dz    |\n                 |                                 |\n                 |  dy/dr     dy/dlon     dy/dz    |\n                 |                                 |\n                 |  dz/dr     dz/dlon     dz/dz    |\n                 `-                               -'\n\n              evaluated at the input values of r, lon and z.\n              Here x,y, and z are given by the familiar formulae\n\n                 x = r*cos(lon)\n                 y = r*sin(lon)\n                 z = z\n\n");

/* void drdgeo_c ( SpiceDouble lon,SpiceDouble lat,SpiceDouble alt,
SpiceDouble re,SpiceDouble f,SpiceDouble jacobi[3][3] ); */
static PyObject * spice_drdgeo(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  double lon;
  double lat;
  double alt;
  double re;
  double f;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddddd", &lon, &lat, &alt, &re, &f));
  drdgeo_c(lon, lat, alt, re, f, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(drdgeo_doc, "-Abstract\n\n   This routine computes the Jacobian of the transformation from\n   geodetic to rectangular coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   lon        I   Geodetic longitude of point (radians).\n   lat        I   Geodetic latitude of point (radians).\n   alt        I   Altitude of point above the reference spheroid.\n   re         I   Equatorial radius of the reference spheroid.\n   f          I   Flattening coefficient.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   lon        Geodetic longitude of point (radians).\n\n   lat        Geodetic latitude  of point (radians).\n\n   alt        Altitude of point above the reference spheroid.\n\n   re         Equatorial radius of the reference spheroid.\n\n   f          Flattening coefficient = (re-rp) / re,  where rp is\n              the polar radius of the spheroid.  (More importantly\n              rp = re*(1-f).)\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              between geodetic and rectangular coordinates.  It\n              has the form\n\n                 .-                             -.\n                 |  dx/dlon   dx/dlat  dx/dalt   |\n                 |  dy/dlon   dy/dlat  dy/dalt   |\n                 |  dz/dlon   dz/dlat  dz/dalt   |\n                 `-                             -'\n\n              evaluated at the input values of lon, lat and alt.\n\n              The formulae for computing x, y, and z from\n              geodetic coordinates are given below.\n\n                 x = [alt +        re/g(lat,f)]*cos(lon)*cos(lat)\n\n\n                 y = [alt +        re/g(lat,f)]*sin(lon)*cos(lat)\n\n                                    2\n                 z = [alt + re*(1-f) /g(lat,f)]*         sin(lat)\n\n              where\n\n                 re is the polar radius of the reference spheroid.\n\n                 f  is the flattening factor (the polar radius is\n                 obtained by multiplying the equatorial radius by 1-f).\n\n                 g( lat, f ) is given by\n\n                        2             2     2\n                    sqrt ( cos (lat) + (1-f) * sin (lat) )\n\n");

/* void drdlat_c ( SpiceDouble r,SpiceDouble lon,SpiceDouble lat,
SpiceDouble jacobi[3][3] ); */
static PyObject * spice_drdlat(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  double r;
  double lon;
  double lat;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &r, &lon, &lat));
  drdlat_c(r, lon, lat, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(drdlat_doc, "-Abstract\n\n   Compute the Jacobian of the transformation from latitudinal to\n   rectangular coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   radius     I   Distance of a point from the origin.\n   lon        I   Angle of the point from the XZ plane in radians.\n   lat        I   Angle of the point from the XY plane in radians.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n    radius     Distance of a point from the origin.\n\n    lon        Angle of the point from the XZ plane in radians.\n               The angle increases in the counterclockwise sense\n               about the +Z axis.\n\n    lat        Angle of the point from the XY plane in radians.\n               The angle increases in the direction of the +Z axis.\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              between latitudinal and rectangular coordinates. It has\n              the form\n\n                  .-                                -.\n                  |  dx/dr     dx/dlon     dx/dlat   |\n                  |                                  |\n                  |  dy/dr     dy/dlon     dy/dlat   |\n                  |                                  |\n                  |  dz/dr     dz/dlon     dz/dlat   |\n                  `-                                -'\n\n             evaluated at the input values of r, lon and lat.\n             Here x, y, and z are given by the familiar formulae\n\n                 x = r * cos(lon) * cos(lat)\n                 y = r * sin(lon) * cos(lat)\n                 z = r *            sin(lat).\n\n");

/* void drdpgr_c ( ConstSpiceChar * body,SpiceDouble lon,SpiceDouble lat,
SpiceDouble alt,SpiceDouble re,SpiceDouble f,SpiceDouble jacobi[3][3] ); */
static PyObject * spice_drdpgr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  char * body;
  double lon;
  double lat;
  double alt;
  double re;
  double f;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sddddd", &body, &lon, &lat, &alt, &re, &f));
  drdpgr_c(body, lon, lat, alt, re, f, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(drdpgr_doc, "-Abstract\n\n   This routine computes the Jacobian matrix of the transformation\n   from planetographic to rectangular coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   body       I   Name of body with which coordinates are associated.\n   lon        I   Planetographic longitude of a point (radians).\n   lat        I   Planetographic latitude of a point (radians).\n   alt        I   Altitude of a point above reference spheroid.\n   re         I   Equatorial radius of the reference spheroid.\n   f          I   Flattening coefficient.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   body       Name of the body with which the planetographic\n              coordinate system is associated.\n\n              `body' is used by this routine to look up from the\n              kernel pool the prime meridian rate coefficient giving\n              the body's spin sense.  See the Files and Particulars\n              header sections below for details.\n\n   lon        Planetographic longitude of the input point.  This is\n              the angle between the prime meridian and the meridian\n              containing the input point.  For bodies having\n              prograde (aka direct) rotation, the direction of\n              increasing longitude is positive west:  from the +X\n              axis of the rectangular coordinate system toward the\n              -Y axis.  For bodies having retrograde rotation, the\n              direction of increasing longitude is positive east:\n              from the +X axis toward the +Y axis.\n\n              The earth, moon, and sun are exceptions:\n              planetographic longitude is measured positive east for\n              these bodies.\n\n              The default interpretation of longitude by this\n              and the other planetographic coordinate conversion\n              routines can be overridden; see the discussion in\n              Particulars below for details.\n\n              Longitude is measured in radians. On input, the range\n              of longitude is unrestricted.\n\n   lat        Planetographic latitude of the input point.  For a\n              point P on the reference spheroid, this is the angle\n              between the XY plane and the outward normal vector at\n              P. For a point P not on the reference spheroid, the\n              planetographic latitude is that of the closest point\n              to P on the spheroid.\n\n              Latitude is measured in radians.  On input, the\n              range of latitude is unrestricted.\n\n   alt        Altitude of point above the reference spheroid.\n              Units of `alt' must match those of `re'.\n\n   re         Equatorial radius of a reference spheroid.  This\n              spheroid is a volume of revolution:  its horizontal\n              cross sections are circular.  The shape of the\n              spheroid is defined by an equatorial radius `re' and\n              a polar radius `rp'.  Units of `re' must match those of\n              `alt'.\n\n   f          Flattening coefficient =\n\n                 (re-rp) / re\n\n              where `rp' is the polar radius of the spheroid, and the\n              units of `rp' match those of `re'.\n\n-Detailed_Output\n\n   JACOBI     is the matrix of partial derivatives of the conversion\n              from planetographic to rectangular coordinates.  It\n              has the form\n\n                 .-                              -.\n                 |  DX/DLON   DX/DLAT   DX/DALT   |\n                 |  DY/DLON   DY/DLAT   DY/DALT   |\n                 |  DZ/DLON   DZ/DLAT   DZ/DALT   |\n                 `-                              -'\n\n              evaluated at the input values of `lon', `lat' and `alt'.\n\n");

/* void drdsph_c ( SpiceDouble r,SpiceDouble colat,SpiceDouble lon,
SpiceDouble jacobi[3][3] ); */
static PyObject * spice_drdsph(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  double r;
  double colat;
  double lon;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &r, &colat, &lon));
  drdsph_c(r, colat, lon, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(drdsph_doc, "-Abstract\n\n   This routine computes the Jacobian of the transformation from\n   spherical to rectangular coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   r          I   Distance of a point from the origin.\n   colat      I   Angle of the point from the positive z-axis.\n   lon        I   Angle of the point from the xy plane.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   r          Distance of a point from the origin.\n\n   colat      Angle between the point and the positive z-axis, in\n              radians.\n\n   lon        Angle of the point from the xz plane in radians.\n              The angle increases in the counterclockwise sense\n              about the +z axis.\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              between spherical and rectangular coordinates,\n              evaluated at the input coordinates.  This matrix has\n              the form\n\n                  .-                                 -.\n                  |  dx/dr     dx/dcolat     dx/dlon  |\n                  |                                   |\n                  |  dy/dr     dy/dcolat     dy/dlon  |\n                  |                                   |\n                  |  dz/dr     dz/dcolat     dz/dlon  |\n                  `-                                 -'\n\n             evaluated at the input values of r, lon and lat.\n             Here x, y, and z are given by the familiar formulae\n\n                 x = r*cos(lon)*sin(colat)\n                 y = r*sin(lon)*sin(colat)\n                 z = r*cos(colat)\n\n");

/* void dsphdr_c ( SpiceDouble x,SpiceDouble y,SpiceDouble z,
SpiceDouble jacobi[3][3] ); */
static PyObject * spice_dsphdr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble jacobi[3][3];
  /* variables for inputs */
  double x;
  double y;
  double z;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &x, &y, &z));
  dsphdr_c(x, y, z, jacobi);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, jacobi[0][0], jacobi[0][1], jacobi[0][2], jacobi[1][0], jacobi[1][1], jacobi[1][2], jacobi[2][0], jacobi[2][1], jacobi[2][2]);
  return returnVal;
}
PyDoc_STRVAR(dsphdr_doc, "-Abstract\n\n   This routine computes the Jacobian of the transformation from\n   rectangular to spherical coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   x          I   x-coordinate of point.\n   y          I   y-coordinate of point.\n   z          I   z-coordinate of point.\n   jacobi     O   Matrix of partial derivatives.\n\n-Detailed_Input\n\n   x,\n   y,\n   z          are the rectangular coordinates of the point at\n              which the Jacobian of the map from rectangular\n              to spherical coordinates is desired.\n\n-Detailed_Output\n\n   jacobi     is the matrix of partial derivatives of the conversion\n              between rectangular and spherical coordinates.  It\n              has the form\n\n                 .-                                  -.\n                 |  dr/dx       dr/dy      dr/dz      |\n                 |  dcolat/dx   dcolat/dy  dcolat/dz  |\n                 |  dlon/dx     dlon/dy    dlon/dz    |\n                 `-                                  -'\n\n             evaluated at the input values of x, y, and z.\n\n");

/* void dtpool_c ( ConstSpiceChar * name,SpiceBoolean * found,SpiceInt * n,
SpiceChar type [1] ); */
static PyObject * spice_dtpool(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceBoolean found;
  SpiceInt n;
  SpiceChar type[1];
  /* variables for inputs */
  char * name;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &name));
  dtpool_c(name, &found, &n, type);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "(s)");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, n, type[0]);
  return returnVal;
  }

}
PyDoc_STRVAR(dtpool_doc, "-Abstract\n\n   Return the data about a kernel pool variable.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   Name of the variable whose value is to be returned.\n   found      O   True if variable is in pool.\n   n          O   Number of values returned for name.\n   type       O   Type of the variable:  'C', 'N', or 'X'\n\n-Detailed_Input\n\n   name       is the name of the variable whose values are to be\n              returned.\n\n-Detailed_Output\n\n\n   found      is SPICETRUE if the variable is in the pool;\n              SPICEFALSE if it is not.\n\n   n          is the number of values associated with name.\n              If name is not present in the pool n will be returned\n              with the value 0.\n\n   type       is a single character indicating the type of the variable\n              associated with name.\n\n                  'C' if the data is character data\n                  'N' if the data is numeric.\n                  'X' if there is no variable name in the pool.\n\n");

/* void ducrss_c ( ConstSpiceDouble s1 [6],ConstSpiceDouble s2 [6],
SpiceDouble sout[6] ); */
static PyObject * spice_ducrss(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sout[6];
  /* variables for inputs */
  double s1[6];
  double s2[6];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddd)(dddddd)", &s1[0], &s1[1], &s1[2], &s1[3], &s1[4], &s1[5], &s2[0], &s2[1], &s2[2], &s2[3], &s2[4], &s2[5]));
  ducrss_c(s1, s2, sout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sout[0], sout[1], sout[2], sout[3], sout[4], sout[5]);
  return returnVal;
}
PyDoc_STRVAR(ducrss_doc, "-Abstract\n\n   Compute the unit vector parallel to the cross product of\n   two 3-dimensional vectors and the derivative of this unit vector.\n\n-Brief_I/O\n\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   s1        I   Left hand state for cross product and derivative.\n   s2        I   Right hand state for cross product and derivative.\n   sout      O   Unit vector and derivative of the cross product.\n\n-Detailed_Input\n\n   s1       This may be any state vector.  Typically, this\n            might represent the apparent state of a planet or the\n            Sun, which defines the orientation of axes of\n            some coordinate system.\n\n   s2       Any state vector.\n\n-Detailed_Output\n\n   sout     This variable represents the unit vector parallel to the\n            cross product of the position components of 's1' and 's2'\n            and the derivative of the unit vector.\n\n            If the cross product of the position components is\n            the zero vector, then the position component of the\n            output will be the zero vector.  The velocity component\n            of the output will simply be the derivative of the\n            cross product of the position components of 's1' and 's2'.\n\n            'sout' may overwrite 's1' or 's2'.\n\n");

/* void dvcrss_c ( ConstSpiceDouble s1 [6],ConstSpiceDouble s2 [6],
SpiceDouble sout[6] ); */
static PyObject * spice_dvcrss(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sout[6];
  /* variables for inputs */
  double s1[6];
  double s2[6];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddd)(dddddd)", &s1[0], &s1[1], &s1[2], &s1[3], &s1[4], &s1[5], &s2[0], &s2[1], &s2[2], &s2[3], &s2[4], &s2[5]));
  dvcrss_c(s1, s2, sout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sout[0], sout[1], sout[2], sout[3], sout[4], sout[5]);
  return returnVal;
}
PyDoc_STRVAR(dvcrss_doc, "-Abstract\n\n   Compute the cross product of two 3-dimensional vectors\n   and the derivative of this cross product.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   s1        I   Left hand state for cross product and derivative.\n   s2        I   Right hand state for cross product and derivative.\n   sout      O   State associated with cross product of positions.\n\n-Detailed_Input\n\n   s1       This may be any state vector.  Typically, this\n            might represent the apparent state of a planet or the\n            Sun, which defines the orientation of axes of\n            some coordinate system.\n\n   s2       A state vector.\n\n-Detailed_Output\n\n   sout     This variable represents the state associated with the\n            cross product of the position components of 's1' and 's2.'\n            In otherwords if s1 = (P1,V1) and s2 = (P2,V2) then\n            'sout' is ( P1xP2, d/dt{ P1xP2 } )\n\n            'sout' may overwrite 's1' or 's2'.\n\n");

/* SpiceDouble dvdot_c ( ConstSpiceDouble s1 [6],ConstSpiceDouble s2 [6] ); */
static PyObject * spice_dvdot(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double s1[6];
  double s2[6];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddd)(dddddd)", &s1[0], &s1[1], &s1[2], &s1[3], &s1[4], &s1[5], &s2[0], &s2[1], &s2[2], &s2[3], &s2[4], &s2[5]));
  result = dvdot_c(s1, s2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(dvdot_doc, "-Abstract\n\n   Compute the derivative of the dot product of two double\n   precision position vectors.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   s1         I   First state vector in the dot product.\n   s2         I   Second state vector in the dot product.\n\n   The function returns the derivative of the dot product <s1,s2>\n\n-Detailed_Input\n\n   s1      Any state vector.  The components are in order\n           (x, y, z, dx/dt, dy/dt, dz/dt )\n\n   s2      Any state vector.\n\n-Detailed_Output\n\n   The function returns the derivative of the dot product of the\n   position portions of the two state vectors s1 and s2.\n\n");

/* void dvhat_c ( ConstSpiceDouble s1 [6],SpiceDouble sout[6] ); */
static PyObject * spice_dvhat(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sout[6];
  /* variables for inputs */
  double s1[6];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddd)", &s1[0], &s1[1], &s1[2], &s1[3], &s1[4], &s1[5]));
  dvhat_c(s1, sout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sout[0], sout[1], sout[2], sout[3], sout[4], sout[5]);
  return returnVal;
}
PyDoc_STRVAR(dvhat_doc, "-Abstract\n\n   Find the unit vector corresponding to a state vector and the\n   derivative of the unit vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   s1        I     State to be normalized.\n   sout      O     Unit vector s1 / |s1|, and its time derivative.\n\n-Detailed_Input\n\n   s1       This is any double precision state. If the position\n            component of the state is the zero vector, this routine\n            will detect it and will not attempt to divide by zero.\n\n-Detailed_Output\n\n   sout     sout is a state containing the unit vector pointing in\n            the direction of position component of s1 and the\n            derivative of the unit vector with respect to time.\n\n            sout may overwrite s1.\n\n");

/* SpiceDouble dvnorm_c ( ConstSpiceDouble state[6] ); */
static PyObject * spice_dvnorm(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double state[6];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddd)", &state[0], &state[1], &state[2], &state[3], &state[4], &state[5]));
  result = dvnorm_c(state);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(dvnorm_doc, "-Abstract\n\n   Function to calculate the derivative of the norm of a 3-vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   state      I   A 6-vector composed of three coordinates and their\n                  derivatives.\n\n-Detailed_Input\n\n   state   A double precision 6-vector, the second three\n           components being the derivatives of the first three\n           with respect to some scalar.\n\n              state =  ( x, dx )\n                            --\n                            ds\n\n           A common form for 'state' would contain position and\n           velocity.\n\n-Detailed_Output\n\n   dvnorm_c   The value of d||x|| corresponding to 'state'.\n                           ------\n                             ds\n\n                                 1/2         2    2    2  1/2\n            where ||x|| = < x, x >    =  ( x1 + x2 + x3 )\n\n\n                      v = ( dx1, dx2, dx3 )\n                            ---  ---  ---\n                            ds   ds   ds\n\n                 d||x||   < x, v >\n                 ------ =  ------     =  < xhat, v >\n                   ds            1/2\n                          < x, x >\n\n");

/* void dvpool_c ( ConstSpiceChar * name ); */
static PyObject * spice_dvpool(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * name;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &name));
  dvpool_c(name);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(dvpool_doc, "-Abstract\n\n   Delete a variable from the kernel pool.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   Name of the kernel variable to be deleted.\n\n-Detailed_Input\n\n   name       is the name of the kernel pool variable to delete.\n              The name and associated values are removed from the\n              kernel pool, freeing the occupied space.\n\n              If watches are set on the variable designated by\n              name, the corresponding agents are placed on the list\n              of agents to be notified of a kernel variable update.\n\n-Detailed_Output\n\n   None.\n\n");

/* SpiceDouble dvsep_c ( ConstSpiceDouble * s1,ConstSpiceDouble * s2 ); */
static PyObject * spice_dvsep(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double * s1;
  double * s2;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dd", &s1, &s2));
  result = dvsep_c(s1, s2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(dvsep_doc, "-Abstract\n\n   Calculate the time derivative of the separation angle between\n   two input states, S1 and S2.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   s1         I   State vector of the first body\n   s2         I   State vector of the second  body\n\n-Detailed_Input\n\n   s1         the state vector of the first target body as seen from\n              the observer\n\n   s2         the state vector of the second target body as seen from\n              the observer\n\n   An implicit assumption exists that both states lie in the same\n   refrence frame with the same observer for the same epoch. If this\n   is not the case, the numerical result has no meaning.\n\n-Detailed_Output\n\n   The function returns the double precision value of the time derivative\n   of the angular separation between S1 and S2.\n\n");

/* void edlimb_c ( SpiceDouble a,SpiceDouble b,SpiceDouble c,
ConstSpiceDouble viewpt[3],SpiceEllipse * limb ); */
static PyObject * spice_edlimb(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceEllipse limb;
  /* variables for inputs */
  double a;
  double b;
  double c;
  double viewpt[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd(ddd)", &a, &b, &c, &viewpt[0], &viewpt[1], &viewpt[2]));
  edlimb_c(a, b, c, viewpt, &limb);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_ellipse(&limb));
  return returnVal;
}
PyDoc_STRVAR(edlimb_doc, "-Abstract\n\n   Find the limb of a triaxial ellipsoid, viewed from a specified\n   point.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   a          I   Length of ellipsoid semi-axis lying on the x-axis.\n   b          I   Length of ellipsoid semi-axis lying on the y-axis.\n   c          I   Length of ellipsoid semi-axis lying on the z-axis.\n   viewpt     I   Location of viewing point.\n   limb       O   Limb of ellipsoid as seen from viewing point.\n\n-Detailed_Input\n\n   a,\n   b,\n   c              are the lengths of the semi-axes of a triaxial\n                  ellipsoid.  The ellipsoid is centered at the\n                  origin and oriented so that its axes lie on the\n                  x, y and z axes.  a, b, and c are the lengths of\n                  the semi-axes that point in the x, y, and z\n                  directions respectively.\n\n   viewpt         is a point from which the ellipsoid is viewed.\n                  viewpt must be outside of the ellipsoid.\n\n-Detailed_Output\n\n   limb           is a CSPICE ellipse that represents the limb of\n                  the ellipsoid.\n\n");

/* void ekaced_c ( SpiceInt handle,SpiceInt segno,SpiceInt recno,
ConstSpiceChar * column,SpiceInt nvals,ConstSpiceDouble * dvals,
SpiceBoolean isnull ); */
static PyObject * spice_ekaced(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  int segno;
  int recno;
  char * column;
  int nvals;
  double * dvals;
  char isnull;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiisidO", &handle, &segno, &recno, &column, &nvals, &dvals, &isnull));
  ekaced_c(handle, segno, recno, column, nvals, dvals, isnull);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ekaced_doc, "-Abstract\n\n   Add data to an double precision column in a specified EK record.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   EK file handle.\n   segno      I   Index of segment containing record.\n   recno      I   Record to which data is to be added.\n   column     I   Column name.\n   nvals      I   Number of values to add to column.\n   dvals      I   Double precision values to add to column.\n   isnull     I   Flag indicating whether column entry is null.\n\n-Detailed_Input\n\n   handle         is the handle of an EK file open for write access.\n\n   segno          is the number of the segment to which the record\n                  is to be added.  EK segment numbers range from\n                  zero to N-1, where N is the number of segments\n                  in the kernel.\n\n   recno          is the index of the record to which data is to be\n                  added.  This record number is relative to the start\n                  of the segment indicated by segno; the first\n                  record in the segment has index 0.\n\n   column         is the name of the column to which data is to be\n                  added.\n   nvals,\n   dvals          are, respectively, the number of values to add to\n                  the specified column and the set of values\n                  themselves.  The data values are written into the\n                  specified column and record.\n\n                  If the  column has fixed-size entries, then nvals\n                  must equal the entry size for the specified column.\n\n\n   isnull         is a logical flag indicating whether the entry is\n                  null.  If isnull is SPICEFALSE, the column entry\n                  defined by nvals and dvals is added to the\n                  specified kernel file.\n\n                  If isnull is SPICETRUE, nvals and cvals are ignored:\n                  no data are written into the specified column entry.\n                  The column entry is marked as a null value.\n\n                  If the column has fixed-length, variable-size\n                  entries, the number of entries is considered to\n                  be 1.\n\n-Detailed_Output\n\n   None.  See $Particulars for a description of the effect of this\n   routine.\n\n");

/* void ekacei_c ( SpiceInt handle,SpiceInt segno,SpiceInt recno,
ConstSpiceChar * column,SpiceInt nvals,ConstSpiceInt * ivals,
SpiceBoolean isnull ); */
static PyObject * spice_ekacei(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  int segno;
  int recno;
  char * column;
  int nvals;
  int * ivals;
  char isnull;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiisiiO", &handle, &segno, &recno, &column, &nvals, &ivals, &isnull));
  ekacei_c(handle, segno, recno, column, nvals, ivals, isnull);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ekacei_doc, "-Abstract\n\n   Add data to an integer column in a specified EK record.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   EK file handle.\n   segno      I   Index of segment containing record.\n   recno      I   Record to which data is to be added.\n   column     I   Column name.\n   nvals      I   Number of values to add to column.\n   ivals      I   Integer values to add to column.\n   isnull     I   Flag indicating whether column entry is null.\n\n-Detailed_Input\n\n   handle         is the handle of an EK file open for write access.\n\n   segno          is the number of the segment to which the record\n                  is to be added.  EK segment numbers range from\n                  0 to N-1, where N is the number of segments\n                  in the kernel.\n\n   recno          is the index of the record to which data is to be\n                  added.  This record number is relative to the start\n                  of the segment indicated by segno; the first\n                  record in the segment has index 0.\n\n   column         is the name of the column to which data is to be\n                  added.\n\n   nvals,\n   ivals          are, respectively, the number of values to add to\n                  the specified column and the set of values\n                  themselves.  The data values are written into the\n                  specified column and record.\n\n                  If the column has fixed-size entries, then NVALS\n                  must equal the entry size for the specified column.\n\n\n   isnull         is a logical flag indicating whether the entry is\n                  null.  If isnull is SPICEFALSE, the column entry\n                  defined by nvals and ivals is added to the\n                  specified kernel file.\n\n                  If isnull is SPICETRUE, nvals and cvals are ignored:\n                  no data are written into the specified column entry.\n                  The column entry is marked as a null value.\n\n                  If the column has fixed-length, variable-size\n                  entries, the number of entries is considered to\n                  be 1.\n\n-Detailed_Output\n\n   None.  See $Particulars for a description of the effect of this\n   routine.\n\n");

/* void ekacld_c ( SpiceInt handle,SpiceInt segno,ConstSpiceChar * column,
ConstSpiceDouble * dvals,ConstSpiceInt * entszs,ConstSpiceBoolean * nlflgs,
ConstSpiceInt * rcptrs,SpiceInt * wkindx ); */
static PyObject * spice_ekacld(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt wkindx;
  /* variables for inputs */
  int handle;
  int segno;
  char * column;
  double * dvals;
  int * entszs;
  char * nlflgs;
  int * rcptrs;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iisdiOi", &handle, &segno, &column, &dvals, &entszs, &nlflgs, &rcptrs));
  ekacld_c(handle, segno, column, dvals, entszs, nlflgs, rcptrs, &wkindx);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, wkindx);
  return returnVal;
}
PyDoc_STRVAR(ekacld_doc, "-Abstract\n\n   Add an entire double precision column to an EK segment.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   EK file handle.\n   segno      I   Number of segment to add column to.\n   column     I   Column name.\n   dvals      I   Double precision values to add to column.\n   entszs     I   Array of sizes of column entries.\n   nlflgs     I   Array of null flags for column entries.\n   rcptrs     I   Record pointers for segment.\n   wkindx    I-O  Work space for column index.\n\n-Detailed_Input\n\n   handle         the handle of an EK file that is open for writing.\n                  A \"begin segment for fast write\" operation must\n                  have already been performed for the designated\n                  segment.\n\n   segno          is the number of the segment to which data is to be\n                  added. Segments are numbered from 0 to nseg-1, where\n                  nseg is the count of segments in the file.\n\n   column         is the name of the column to be added.  All of\n                  the data for the named column will be added in\n                  one shot.\n\n   dvals          is an array containing the entire set of column\n                  entries for the specified column.  The entries\n                  are listed in row-order:  the column entry for the\n                  first row of the segment is first, followed by the\n                  column entry for the second row, and so on.  The\n                  number of column entries must match the declared\n                  number of rows in the segment.  For columns having\n                  fixed-size entries, a null entry must be allocated\n                  the same amount of space occupied by a non-null\n                  entry in the array dvals.  For columns having\n                  variable-size entries, null entries do not require\n                  any space in the dvals* array, but in any case must\n                  have their allocated space described correctly by\n                  the corresponding element of the entszs array\n                  (described below).\n\n   entszs         is an array containing sizes of column entries.\n                  The Ith element of entszs gives the size of the\n                  Ith column entry.  entszs is used only for columns\n                  having variable-size entries.  For such columns,\n                  the dimension of entszs must be at least nrows.\n                  The size of null entries should be set to zero.\n\n                  For columns having fixed-size entries, the\n                  dimension of this array may be any positive value.\n\n   nlflgs         is an array of logical flags indicating whether\n                  the corresponding entries are null.  If the Ith\n                  element of nlflgs is SPICEFALSE, the Ith column entry\n                  defined by dvals and entszs is added to the\n                  current segment in the specified kernel file.\n\n                  If the Ith element of nlfgls is SPICETRUE, the\n                  contents of the Ith column entry are undefined.\n\n                  nlflgs is used only for columns that allow null\n                  values; it's ignored for other columns.\n\n   rcptrs         is an array of record pointers for the input\n                  segment.  This array is obtained as an output\n                  from ekifld_c, the routine called to initiate a\n                  fast write.\n\n   wkindx         is a work space array used for building a column\n                  index.  If the column is indexed, the dimension of\n                  wkindx_c must be at nrows, where nrows is the number\n                  of rows in the column.  If the column is not\n                  indexed, this work space is not used, so the\n                  dimension may be any positive value.\n\n-Detailed_Output\n\n   None.  See $Particulars for a description of the effect of this\n   routine.\n\n");

/* void ekacli_c ( SpiceInt handle,SpiceInt segno,ConstSpiceChar * column,
ConstSpiceInt * ivals,ConstSpiceInt * entszs,ConstSpiceBoolean * nlflgs,
ConstSpiceInt * rcptrs,SpiceInt * wkindx ); */
static PyObject * spice_ekacli(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt wkindx;
  /* variables for inputs */
  int handle;
  int segno;
  char * column;
  int * ivals;
  int * entszs;
  char * nlflgs;
  int * rcptrs;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iisiiOi", &handle, &segno, &column, &ivals, &entszs, &nlflgs, &rcptrs));
  ekacli_c(handle, segno, column, ivals, entszs, nlflgs, rcptrs, &wkindx);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, wkindx);
  return returnVal;
}
PyDoc_STRVAR(ekacli_doc, "-Abstract\n\n   Add an entire integer column to an EK segment.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   EK file handle.\n   segno      I   Number of segment to add column to.\n   column     I   Column name.\n   ivals      I   Integer values to add to column.\n   entszs     I   Array of sizes of column entries.\n   nlflgs     I   Array of null flags for column entries.\n   rcptrs     I   Record pointers for segment.\n   wkindx    I-O  Work space for column index.\n\n-Detailed_Input\n\n   handle         the handle of an EK file that is open for writing.\n                  A \"begin segment for fast write\" operation must\n                  have already been performed for the designated\n                  segment.\n\n   segno          is the number of the segment to which data is to be\n                  added. Segments are numbered from 0 to nseg-1, where\n                  nseg is the count of segments in the file.\n\n   column         is the name of the column to be added.  All of\n                  the data for the named column will be added in\n                  one shot.\n\n   ivals          is an array containing the entire set of column\n                  entries for the specified column.  The entries\n                  are listed in row-order:  the column entry for the\n                  first row of the segment is first, followed by the\n                  column entry for the second row, and so on.  The\n                  number of column entries must match the declared\n                  number of rows in the segment.  For columns having\n                  fixed-size entries, a null entry must be allocated\n                  the same amount of space occupied by a non-null\n                  entry in the array ivals.  For columns having\n                  variable-size entries, null entries do not require\n                  any space in the ivals* array, but in any case must\n                  have their allocated space described correctly by\n                  the corresponding element of the entszs array\n                  (described below).\n\n   entszs         is an array containing sizes of column entries.\n                  The Ith element of entszs gives the size of the\n                  Ith column entry.  entszs is used only for columns\n                  having variable-size entries.  For such columns,\n                  the dimension of entszs must be at least nrows.\n                  The size of null entries should be set to zero.\n\n                  For columns having fixed-size entries, the\n                  dimension of this array may be any positive value.\n\n   nlflgs         is an array of logical flags indicating whether\n                  the corresponding entries are null.  If the Ith\n                  element of nlflgs is SPICEFALSE, the Ith column entry\n                  defined by ivals and entszs is added to the\n                  current segment in the specified kernel file.\n\n                  If the Ith element of nlfgls is SPICETRUE, the\n                  contents of the Ith column entry are undefined.\n\n                  nlflgs is used only for columns that allow null\n                  values; it's ignored for other columns.\n\n   rcptrs         is an array of record pointers for the input\n                  segment.  This array is obtained as an output\n                  from ekifld_c, the routine called to initiate a\n                  fast write.\n\n   wkindx         is a work space array used for building a column\n                  index.  If the column is indexed, the dimension of\n                  wkindx_c must be at nrows, where nrows is the number\n                  of rows in the column.  If the column is not\n                  indexed, this work space is not used, so the\n                  dimension may be any positive value.\n\n-Detailed_Output\n\n   None.  See $Particulars for a description of the effect of this\n   routine.\n\n");

/* void ekappr_c ( SpiceInt handle,SpiceInt segno,SpiceInt * recno ); */
static PyObject * spice_ekappr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt recno;
  /* variables for inputs */
  int handle;
  int segno;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &handle, &segno));
  ekappr_c(handle, segno, &recno);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, recno);
  return returnVal;
}
PyDoc_STRVAR(ekappr_doc, "-Abstract\n\n   Append a new, empty record at the end of a specified E-kernel\n   segment.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   File handle.\n   segno      I   Segment number.\n   recno      O   Number of appended record.\n\n-Detailed_Input\n\n   handle         is a file handle of an EK open for write access.\n\n   segno          is the number of the segment to which the record\n                  is to be added.  EK segment numbers range from\n                  zero to N-1, where N is the number of segments\n                  in the kernel.\n\n-Detailed_Output\n\n   recno          is the number of the record appended by this\n                  routine.  recno is used to identify the record\n                  when writing column entries to it.  EK record\n                  numbers range from 0 to N-1, where N is the\n                  number of records in the segment containing\n                  the record.\n\n");

/* void ekccnt_c ( ConstSpiceChar * table,SpiceInt * ccount ); */
static PyObject * spice_ekccnt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt ccount;
  /* variables for inputs */
  char * table;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &table));
  ekccnt_c(table, &ccount);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, ccount);
  return returnVal;
}
PyDoc_STRVAR(ekccnt_doc, "-Abstract\n\n   Return the number of distinct columns in a specified, currently\n   loaded table\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   table      I   Name of table.\n   ccount     O   Count of distinct, currently loaded columns.\n\n-Detailed_Input\n\n   table          is the name of a currently loaded table.  Case\n                  is not significant in the table name.\n\n-Detailed_Output\n\n   ccount         is the number of distinct columns in table.\n                  Columns that have the same name but belong to\n                  different segments that are considered to be\n                  portions of the same column, if the segments\n                  containing those columns belong to table.\n\n");

/* void ekcii_c ( ConstSpiceChar * table,SpiceInt cindex,SpiceInt lenout,
SpiceChar * column,SpiceEKAttDsc * attdsc ); */
static PyObject * spice_ekcii(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar column[STRING_LEN];
  SpiceEKAttDsc attdsc;
  /* variables for inputs */
  char * table;
  int cindex;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &table, &cindex));
  ekcii_c(table, cindex, lenout, column, &attdsc);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, column, get_py_ekattdsc(&attdsc));
  return returnVal;
}
PyDoc_STRVAR(ekcii_doc, "-Abstract\n\n   Return attribute information about a column belonging to a loaded\n   EK table, specifying the column by table and index.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   table      I   Name of table containing column.\n   cindex     I   Index of column whose attributes are to be found.\n   lenout     I   Maximum allowed length of column name.\n   column     O   Name of column.\n   attdsc     O   Column attribute descriptor.\n\n-Detailed_Input\n\n   table          is the name of a loaded EK table.  Case is not\n                  significant.\n\n   cindex         is the index, within TABLE's column attribute\n                  table, of the column whose attributes are to be\n                  found.  The indices of the column table entries\n                  range from 0 to ccount-1, where ccount is the value\n                  returned by the entry point ekccnt_c.\n\n   lenout         is the maximum allowed length of the output column\n                  name, including the terminating null.  Column names\n                  can be accommodated by a character array of length\n                  SPICE_EK_CSTRLN.  This constant is declared in the\n                  header file SpiceEK.h.\n\n-Detailed_Output\n\n   column         is the name of the specified column.\n\n   attdsc         is an EK column attribute descriptor.  See the header\n                  file SpiceEK.h for details.\n\n");

/* void ekcls_c ( SpiceInt handle ); */
static PyObject * spice_ekcls(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  ekcls_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ekcls_doc, "-Abstract\n\n   Close an E-kernel.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   EK file handle.\n\n-Detailed_Input\n\n   handle         is the file handle of an EK to be closed.  Note\n                  that EKs open for writing must be closed by this\n                  routine in order by be valid.\n\n-Detailed_Output\n\n   None.\n\n");

/* void ekdelr_c ( SpiceInt handle,SpiceInt segno,SpiceInt recno ); */
static PyObject * spice_ekdelr(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  int segno;
  int recno;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &handle, &segno, &recno));
  ekdelr_c(handle, segno, recno);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ekdelr_doc, "-Abstract\n\n   Delete a specified record from a specified E-kernel segment.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   File handle.\n   segno      I   Segment number.\n   recno      I   Record number.\n\n-Detailed_Input\n\n   handle         is a file handle of an EK open for write access.\n\n   segno          is the number of the segment to which the record\n                  is to be added.  EK segment numbers range from\n                  zero to N-1, where N is the number of segments\n                  in the kernel.\n\n   recno          is the index of the record to delete.  recno must\n                  be in the range 0 : N, where N is the\n                  number of records in the segment prior to the\n                  insertion.\n\n-Detailed_Output\n\n   None.  See the $Particulars section for a description of the\n   effect of this routine.\n\n");

/* void ekffld_c ( SpiceInt handle,SpiceInt segno,SpiceInt * rcptrs ); */
static PyObject * spice_ekffld(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt rcptrs;
  /* variables for inputs */
  int handle;
  int segno;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &handle, &segno));
  ekffld_c(handle, segno, &rcptrs);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rcptrs);
  return returnVal;
}
PyDoc_STRVAR(ekffld_doc, "-Abstract\n\n   Complete a fast write operation on a new E-kernel segment.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   File handle.\n   segno      I   Segment number.\n   rcptrs     I   Record pointers.\n\n-Detailed_Input\n\n   handle         the handle of an EK file that is open for writing.\n                  A \"begin segment for fast write\" operation must\n                  have already been performed for the designated\n                  segment.\n\n   segno          is the number of the segment to which data is to be\n                  added. Segments are numbered from 0 to nseg-1, where\n                  nseg is the count of segments in the file.\n\n   rcptrs         is an array of record pointers for the input\n                  segment.  This array is obtained as an output\n                  from ekifld_c, the routine called to initiate a\n                  fast write.\n\n-Detailed_Output\n\n   None.\n\n   See the Particulars section for a description of the\n   effects of this routine.\n\n");

/* void ekfind_c ( ConstSpiceChar * query,SpiceInt lenout,SpiceInt * nmrows,
SpiceBoolean * error,SpiceChar * errmsg ); */
static PyObject * spice_ekfind(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt nmrows;
  SpiceBoolean error;
  SpiceChar errmsg[STRING_LEN];
  /* variables for inputs */
  char * query;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &query));
  ekfind_c(query, lenout, &nmrows, &error, errmsg);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, nmrows, get_py_boolean(&error), errmsg);
  return returnVal;
}
PyDoc_STRVAR(ekfind_doc, "-Abstract\n\n   Find E-kernel data that satisfy a set of constraints.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   query      I   Query specifying data to be found.\n   lenout     I   Declared length of output error message string.\n   nmrows     O   Number of matching rows.\n   error      O   Flag indicating whether query parsed correctly.\n   errmsg     O   Parse error description.\n\n-Detailed_Input\n\n   query          is a character string that specifies a set of EK\n                  data to select from those present in currently\n                  loaded EK files.  The selected data will be\n                  retrievable via the EK fetch routines ekgc_c, ekgd_c,\n                  and ekgi_c.\n\n                  The query consists of four clauses, the third and\n                  fourth of which are optional.  The general form\n                  of a query is\n\n                     SELECT <column list>\n                     FROM <table list>\n                     [WHERE <constraint list>]\n                     [ORDER BY <ORDER BY column list>]\n\n                  where brackets indicate optional items.  The\n                  elements of the query shown above are called,\n                  respectively, the `SELECT clause', the\n                  `FROM clause', the `WHERE clause', and the\n                  `ORDER BY clause'.  The result of a query may be\n                  thought of as a new table, whose columns are those\n                  specified in the SELECT clause, whose rows are\n                  those satisfying the constraints of the WHERE\n                  clause, and whose rows are ordered according to\n                  the ORDER BY clause.\n\n                  The SELECT clause specifies a list of columns\n                  from which data are to be selected.  In a simple\n                  (non-join) query, these columns must belong to\n                  the single table specified in the FROM clause.\n\n                  The form of a SELECT clause is\n\n                     SELECT <column name> [ ,<column name>...]\n\n                  In queries having multiple tables in the FROM\n                  clause, column names are ambiguous if they occur\n                  in more than one table in the FROM clause.  Such\n                  column names must be qualified with table\n                  identifiers.  These identifiers may be the names of\n                  the tables to which the columns belong, or table\n                  `aliases', names (usually short ones) associated\n                  with tables in the FROM clause.  Table aliases have\n                  duration limited to the execution of the query to\n                  which they belong.\n\n                  The form of a qualified column name is\n\n                     <table name>.<column name>\n\n                  or\n\n                     <table alias>.<column name>\n\n\n                  The FROM clause specifies the tables from which\n                  data are to be selected.  In simple queries, only\n                  one table is listed.  In this case the form of\n                  the FROM clause is\n\n                     FROM <table name>\n\n                  In queries involving multiple tables, the form of\n                  the FROM clause becomes\n\n                     FROM <table name> [<table alias>]\n                          [ , <table name> [<table alias>] ... ]\n\n                  The aliases associated with the table names must\n                  be distinct and must not be the actual names of\n                  loaded EK tables.\n\n                  Queries involving multiple tables are called\n                  `joins'.\n\n                  The meaning of a FROM clause containing multiple\n                  tables is that the output is to be a subset of\n                  the rows of the Cartesian product of the listed\n                  tables.  Normally, WHERE clause constraints are\n                  supplied to reduce the selected rows to a set of\n                  interest.\n\n                  The most common example of a join is a query with\n                  two tables listed in the FROM clause, and a WHERE\n                  clause constraint enforcing equality of members\n                  of a column in the first table with members of\n                  column in the second table.  Such a query is\n                  called an `equi-join'.  A join in which columns\n                  of different tables are related by an inequality\n                  is called a `non-equi-join'.  Any type of join\n                  other than an equi-join may be very slow to\n                  evaluate, due to the large number of elements that\n                  may be contained in the Cartesian\n                  product of the listed tables.\n\n                  The WHERE clause lists constraints that must\n                  be met by each row satisfying the query.  The\n                  constraints are specified as a logical combination\n                  of relational expressions.  The form of the\n                  constraint list is\n\n                     WHERE <constraint expression>\n\n                  where each <constraint expression> consists of one\n                  or more simple relational expressions of the form\n\n                     <column name> <operator> <RHS symbol>\n\n                  where\n\n                     <RHS symbol>\n\n                  is a column name, a literal value, or the special\n                  symbol\n\n                     NULL\n\n                  and\n\n                     <operator>\n\n                  is any of\n\n                     EQ, GE, GT, LE, LIKE, LT, NE, NOT LIKE, <, <=,\n                     =, >, >=, !=, <>\n\n                  For comparison with null values, the special\n                  syntaxes\n\n                     <column name> IS NULL\n                     <column name> IS NOT NULL\n\n                  are allowed, in addition to the standard\n                  comparison syntaxes using the equality or\n                  inequality operators.\n\n                  The LIKE operator allows comparison of a string\n                  value against a template.  The template syntax\n                  is that allowed by the CSPICE routine MATCHI.\n                  Templates may include literal characters, the\n                  wild string marker '*', and the wild character\n                  marker '%'.  Case is significant in templates.\n\n                  Templates are bracketed by quote characters, just\n                  as are literal strings.\n\n                  The query language also supports the BETWEEN and\n                  NOT BETWEEN constructs\n\n                     <column> BETWEEN <symbol 1> AND <symbol 2>\n\n                     <column> NOT BETWEEN <symbol 1> AND <symbol 2>\n\n                  The tokens\n\n                     <symbol 1>\n                     <symbol 2>\n\n                  may be literal values or column names.\n\n                  The BETWEEN operator considers values that match\n                  the bounds to satisfy the condition:  the BETWEEN\n                  operator tests for inclusion in the closed interval\n                  defined by the bounds.\n\n                  In the WHERE clause, simple relational expressions\n                  may be combined using the logical operators AND,\n                  OR, and NOT, as in the Fortran programming\n                  language.  Parentheses may be used to enforce a\n                  desired order of evaluation of logical expressions.\n\n                  The expression syntax is NOT symmetric:  literal\n                  values must not appear on the left hand side of the\n                  operators that apply to them.\n\n                  The columns named in a constraint clause must\n                  belong to the tables listed in the FROM clause.\n                  If the query is a join, qualifying table names or\n                  aliases are required wherever their omission would\n                  result in ambiguity.\n\n                  Data types of the columns or constants used on the\n                  right-hand-sides of operators must match the data\n                  types of the corresponding columns on the\n                  left-hand-sides, except that comparison of integer\n                  and double precision quantities is permitted.\n\n                  Literal strings used in constraints are always\n                  bracketed by quotes.  Either single  quotes (')\n                  or double quotes (\") may be used, but the same\n                  quote character must be used to start and end any\n                  literal string. Within character string values,\n                  quote characters must be doubled in order to be\n                  recognized.  Case is significant in character\n                  except in comparisions using the LIKE and NOT LIKE\n                  operators, which ignore case:  the expression\n\n                     ANIMAL LIKE \"*A*\"\n\n                  would be considered true when ANIMAL takes the\n                  value\n\n                     \"cat\"\n\n                  Time values are considered to be strings and\n                  require bracketing quotes.  Currently, the\n                  only time values allowed are UTC times in ISO\n                  format, UTC times represented in forms accepted by\n                  the CSPICE routine TPARSE, and SCLK strings in\n                  NAIF format.\n\n                  The ORDER BY clause indicates which columns to\n                  use to order the output generated by the query.\n                  The columns in the ORDER BY clause define a\n                  dictionary ordering, with the first listed column\n                  acting as a primary key, the second column acting\n                  as a secondary key, and so on.\n\n                  For each ORDER BY column, the keywords ASC or DESC\n                  may be supplied to indicate whether the items in\n                  that column are to be listed in ascending or\n                  descending order.  Ascending order is the default.\n                  The direction in which data items increase is\n                  referred to as the `order sense'.\n\n                  The ORDER BY clause, if present, must appear\n                  last in the query.\n\n                  The form of the ORDER BY clause is\n\n                     ORDER BY <column name> [<order sense>]\n                              [ ,<column name> [<order sense>]...]\n\n                  Rows satisfying the query constraints will be\n                  returned so that the entries of the first column\n                  specified in the ORDER BY clause will be appear in\n                  the order specified by the order sense keyword,\n                  which is assumed to be ASC if absent.  When entries\n                  in the first through Nth ORDER BY column are equal,\n                  the entries in the (N+1)st ORDER BY column\n                  determine the order of the rows, and so on.\n\n                  As in the WHERE clause, column names must be\n                  qualified by table names or table aliases where\n                  they would otherwise be ambiguous.\n\n                  The query language is word-oriented, and some\n                  indicate whether the words are reserved.  Reserved\n                  words must be separated from other words by white\n                  space.  It is not necessary to use white space\n                  to separate words and punctuation characters.\n                  The list of reserved words is\n\n                     AND\n                     BETWEEN\n                     BY\n                     COLUMN\n                     EQ\n                     FROM\n                     GE\n                     GT\n                     IS\n                     LE\n                     LT\n                     LIKE\n                     NE\n                     NOT\n                     NULL\n                     OR\n                     ORDER\n                     SELECT\n                     WHERE\n\n                  The left and right parenthesis characters are also\n                  reserved; they may not be used in queries outside\n                  of quoted strings.\n\n                  Case is not significant in queries, except within\n                  literal strings.\n\n\n   lenout     is the maximum number of characters that can be\n              accommodated in the output string.  This count\n              includes room for the terminating null character.\n              For example, if the maximum allowed length of the\n              output string, including the terminating null, is 25\n              characters, then lenout should be set to 25.\n\n\n-Detailed_Output\n\n   nmrows         is the number of rows that match the query\n                  criteria.  nmrows is defined if and only if\n                  error is returned as SPICEFALSE.\n\n   error          is a logical flag indicating whether the query\n                  failed to parse correctly.\n\n   errmsg         is a character string that describes ekfind_c's\n                  diagnosis of a parse error, should one occur.\n                  Otherwise, errmsg will be returned blank.\n\n");

/* void ekgc_c ( SpiceInt selidx,SpiceInt row,SpiceInt elment,SpiceInt lenout,
SpiceChar * cdata,SpiceBoolean * null,SpiceBoolean * found ); */
static PyObject * spice_ekgc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar cdata[STRING_LEN];
  SpiceBoolean null;
  SpiceBoolean found;
  /* variables for inputs */
  int selidx;
  int row;
  int elment;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &selidx, &row, &elment));
  ekgc_c(selidx, row, elment, lenout, cdata, &null, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "O");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, cdata, get_py_boolean(&null));
  return returnVal;
  }

}
PyDoc_STRVAR(ekgc_doc, "-Abstract\n\n   Return an element of an entry in a column of character\n   type in a specified row.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   selidx     I   Index of parent column in SELECT clause.\n   row        I   Row to fetch from.\n   elment     I   Index of element, within column entry, to fetch.\n   lenout     I   Maximum length of column element.\n   cdata      O   Character string element of column entry.\n   null       O   Flag indicating whether column entry was null.\n   found      O   Flag indicating whether column was present in row.\n\n-Detailed_Input\n\n   selidx         is the SELECT clause index of the column to fetch\n                  from.  The range of selidx is from 0 to one less than\n                  the number of columns in the SELECT clause.\n\n   row            is the output row containing the entry to fetch\n                  from.  The range of row is from 0 to one less than\n                  the number of rows satisfying the previous query.\n\n   elment         is the index of the element of the column entry\n                  to fetch.  The normal range of elment is from 0 to\n                  one less than the size of the column's entry, but\n                  elment is allowed to exceed the number of elements in\n                  the column entry; if it does, found is returned\n                  as SPICEFALSE.  This allows the caller to read data\n                  from the column entry in a loop without checking the\n                  number of available elements first.\n\n                  Null values in variable-sized columns are\n                  considered to have size 1.\n\n   lenout         is the maximum allowed length of a string that\n                  can be fetched into the string cdata.  This length\n                  must large enough to hold the specified element of the\n                  column entry, plus a null terminator.  If the column\n                  element is expected to have x characters, lenout needs\n                  to be x + 1.\n\n\n-Detailed_Output\n\n   cdata          is the requested element of the specified column\n                  entry.  If the entry is null, cdata is undefined.\n\n                  If cdata is too short to accommodate the requested\n                  column entry element, the element is truncated on\n                  the right to fit cdata.\n\n   null           is a logical flag indicating whether the entry\n                  belonging to the specified column in the specified\n                  row is null.\n\n   found          is a logical flag indicating whether the specified\n                  element was found.  If the element does not exist,\n                  found is returned as SPICEFALSE.\n\n");

/* void ekgd_c ( SpiceInt selidx,SpiceInt row,SpiceInt elment,
SpiceDouble * ddata,SpiceBoolean * null,SpiceBoolean * found ); */
static PyObject * spice_ekgd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble ddata;
  SpiceBoolean null;
  SpiceBoolean found;
  /* variables for inputs */
  int selidx;
  int row;
  int elment;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &selidx, &row, &elment));
  ekgd_c(selidx, row, elment, &ddata, &null, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "O");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, ddata, get_py_boolean(&null));
  return returnVal;
  }

}
PyDoc_STRVAR(ekgd_doc, "-Abstract\n\n   Return an element of an entry in a column of double precision\n   type in a specified row.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   selidx     I   Index of parent column in SELECT clause.\n   row        I   Row to fetch from.\n   elment     I   Index of element, within column entry, to fetch.\n   ddata      O   Double precision element of column entry.\n   null       O   Flag indicating whether column entry was null.\n   found      O   Flag indicating whether column was present in row.\n\n-Detailed_Input\n\n   selidx         is the SELECT clause index of the column to fetch\n                  from.  The range of selidx is from 0 to one less than\n                  the number of columns in the SELECT clause.\n\n   row            is the output row containing the entry to fetch\n                  from.  The range of row is from 0 to one less than\n                  the number of rows satisfying the previous query.\n\n   elment         is the index of the element of the column entry\n                  to fetch.  The normal range of elment is from 0 to\n                  one less than the size of the column's entry, but\n                  elment is allowed to exceed the number of elements in\n                  the column entry; if it does, found is returned\n                  as SPICEFALSE.  This allows the caller to read data\n                  from the column entry in a loop without checking the\n                  number of available elements first.\n\n                  Null values in variable-sized columns are\n                  considered to have size 1.\n\n-Detailed_Output\n\n   ddata          is the requested element of the specified column\n                  entry.  If the entry is null, ddata is undefined.\n\n   null           is a logical flag indicating whether the entry\n                  belonging to the specified column in the specified\n                  row is null.\n\n   found          is a logical flag indicating whether the specified\n                  element was found.  If the element does not exist,\n                  found is returned as SPICEFALSE.\n\n");

/* void ekgi_c ( SpiceInt selidx,SpiceInt row,SpiceInt elment,SpiceInt * idata,
SpiceBoolean * null,SpiceBoolean * found ); */
static PyObject * spice_ekgi(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt idata;
  SpiceBoolean null;
  SpiceBoolean found;
  /* variables for inputs */
  int selidx;
  int row;
  int elment;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &selidx, &row, &elment));
  ekgi_c(selidx, row, elment, &idata, &null, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "O");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, idata, get_py_boolean(&null));
  return returnVal;
  }

}
PyDoc_STRVAR(ekgi_doc, "-Abstract\n\n   Return an element of an entry in a column of integer\n   type in a specified row.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   selidx     I   Index of parent column in SELECT clause.\n   row        I   Row to fetch from.\n   elment     I   Index of element, within column entry, to fetch.\n   idata      O   Integer element of column entry.\n   null       O   Flag indicating whether column entry was null.\n   found      O   Flag indicating whether column was present in row.\n\n-Detailed_Input\n\n   selidx         is the SELECT clause index of the column to fetch\n                  from.  The range of selidx is from 0 to one less than\n                  the number of columns in the SELECT clause.\n\n   row            is the output row containing the entry to fetch\n                  from.  The range of row is from 0 to one less than\n                  the number of rows satisfying the previous query.\n\n   elment         is the index of the element of the column entry\n                  to fetch.  The normal range of elment is from 0 to\n                  one less than the size of the column's entry, but\n                  elment is allowed to exceed the number of elements in\n                  the column entry; if it does, found is returned\n                  as SPICEFALSE.  This allows the caller to read data\n                  from the column entry in a loop without checking the\n                  number of available elements first.\n\n                  Null values in variable-sized columns are\n                  considered to have size 1.\n\n-Detailed_Output\n\n   idata          is the requested element of the specified column\n                  entry.  If the entry is null, idata is undefined.\n\n                  If idata is too short to accommodate the requested\n                  column entry element, the element is truncated on\n                  the right to fit idata.\n\n   null           is a logical flag indicating whether the entry\n                  belonging to the specified column in the specified\n                  row is null.\n\n   found          is a logical flag indicating whether the specified\n                  element was found.  If the element does not exist,\n                  found is returned as SPICEFALSE.\n\n");

/* void ekinsr_c ( SpiceInt handle,SpiceInt segno,SpiceInt recno ); */
static PyObject * spice_ekinsr(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  int segno;
  int recno;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &handle, &segno, &recno));
  ekinsr_c(handle, segno, recno);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ekinsr_doc, "-Abstract\n\n   Add a new, empty record to a specified E-kernel segment at\n   a specified index.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   File handle.\n   segno      I   Segment number.\n   recno      I   Record number.\n\n-Detailed_Input\n\n   handle         is a file handle of an EK open for write access.\n\n   segno          is the number of the segment to which the record\n                  is to be added.\n\n   recno          is the index of the new record.  recno must be\n                  in the range 0 : NREC, where NREC is the\n                  number of records in the segment prior to the\n                  insertion.  If recno is equal to NREC, the\n                  new record is appended.  Otherwise, the new\n                  record has the ordinal position specified by\n                  recno, and the records previously occupying\n                  positions recno : NREC-1 have their indices\n                  incremented by 1.\n\n-Detailed_Output\n\n   None.  See the $Particulars section for a description of the\n   effect of this routine.\n\n");

/* void eklef_c ( ConstSpiceChar * fname,SpiceInt * handle ); */
static PyObject * spice_eklef(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &fname));
  eklef_c(fname, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(eklef_doc, "-Abstract\n\n   Load an EK file, making it accessible to the EK readers.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   fname      I   Name of EK file to load.\n   handle     O   File handle of loaded EK file.\n\n-Detailed_Input\n\n   fname          is the name of a binary EK file to be loaded.\n\n-Detailed_Output\n\n   handle         is the handle of the EK file.  The file is\n                  accessible by the EK reader routines once it\n                  has been loaded.\n\n");

/* SpiceInt eknelt_c ( SpiceInt selidx,SpiceInt row ); */
static PyObject * spice_eknelt(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int selidx;
  int row;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &selidx, &row));
  result = eknelt_c(selidx, row);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(eknelt_doc, "-Abstract\n\n   Return the number of elements in a specified column entry in\n   the current row.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   selidx     I   Index of parent column in SELECT clause.\n   row        I   Row containing element.\n\n   The function returns the number of elements in entry in current row.\n\n-Detailed_Input\n\n   selidx         is the SELECT clause index of the column to\n                  fetch from.  The range of selidx is 0 : (nsel-1)\n                  inclusive, where nsel is the number of items in\n                  the SELECT clause of the current query.\n\n   row            is the index of the row containing the element.\n                  This number refers to a member of the set of rows\n                  matching a query.  row must be in the range\n\n                    0 : nmrows-1\n\n                  where nmrows is the matching row count returned\n                  by ekfind_c.\n\n-Detailed_Output\n\n   The function returns the number of elements in the column entry\n   belonging to the specified column in the current row.\n\n   Null entries in variable-size columns are considered to have size 1.\n\n");

/* SpiceInt eknseg_c ( SpiceInt handle ); */
static PyObject * spice_eknseg(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  result = eknseg_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(eknseg_doc, "-Abstract\n\n   Return the number of segments in a specified EK.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   EK file handle.\n\n   The function returns the number of segments in the specified\n   E-kernel.\n\n-Detailed_Input\n\n   handle         is the handle of an EK file opened for read access.\n\n-Detailed_Output\n\n   The function returns the number of segments in the specified\n   E-kernel.\n\n");

/* void ekntab_c ( SpiceInt * n ); */
static PyObject * spice_ekntab(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt n;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  ekntab_c(&n);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, n);
  return returnVal;
}
PyDoc_STRVAR(ekntab_doc, "-Abstract\n\n   Return the number of loaded EK tables.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   n          O   Number of loaded tables.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   n              is the number of loaded tables.  The count refers\n                  to the number of logical tables; if multiple\n                  segments contain data for the same table, these\n                  segments collectively contribute only one table\n                  to the count.\n\n");

/* void ekopn_c ( ConstSpiceChar * fname,ConstSpiceChar * ifname,
SpiceInt ncomch,SpiceInt * handle ); */
static PyObject * spice_ekopn(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;
  char * ifname;
  int ncomch;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &fname, &ifname, &ncomch));
  ekopn_c(fname, ifname, ncomch, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(ekopn_doc, "-Abstract\n\n   Open a new E-kernel file and prepare the file for writing.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   fname      I   Name of EK file.\n   ifname     I   Internal file name.\n   ncomch     I   The number of characters to reserve for comments.\n   handle     O   Handle attached to new EK file.\n\n-Detailed_Input\n\n   fname          is the name of a new E-kernel file to be created.\n\n   ifname         is the internal file name of a new E-kernel.  The\n                  internal file name may be up to 60 characters in\n                  length, not including the null terminator.\n\n   ncomch         is the amount of space, measured in characters, to\n                  be allocated in the comment area when the new EK\n                  file is created.  It is not necessary to allocate\n                  space in advance in order to add comments, but\n                  doing so may greatly increase the efficiency with\n                  which comments may be added.  Making room for\n                  comments after data has already been added to the\n                  file involves moving the data, and thus is slower.\n\n                  ncomch must be greater than or equal to zero.\n\n-Detailed_Output\n\n   handle         is the EK handle of the file designated by fname.\n                  This handle is used to identify the file to other\n                  EK routines.\n\n");

/* void ekopr_c ( ConstSpiceChar * fname,SpiceInt * handle ); */
static PyObject * spice_ekopr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &fname));
  ekopr_c(fname, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(ekopr_doc, "-Abstract\n\n   Open an existing E-kernel file for reading.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   fname      I   Name of EK file.\n   handle     O   Handle attached to EK file.\n\n-Detailed_Input\n\n   fname          is the name of an existing E-kernel file to be\n                  opened for read access.\n\n-Detailed_Output\n\n   handle         is the EK file handle of the file designated by\n                  fname.  This handle is used to identify the file\n                  to other EK routines.\n\n");

/* void ekops_c ( SpiceInt * handle ); */
static PyObject * spice_ekops(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  ekops_c(&handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(ekops_doc, "-Abstract\n\n   Open a scratch (temporary) E-kernel file and prepare the file\n   for writing.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     O   File handle attached to new EK file.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   handle         is the EK file handle of the file opened by this\n                  routine.  This handle is used to identify the file\n                  to other EK routines.\n\n");

/* void ekopw_c ( ConstSpiceChar * fname,SpiceInt * handle ); */
static PyObject * spice_ekopw(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &fname));
  ekopw_c(fname, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(ekopw_doc, "-Abstract\n\n   Open an existing E-kernel file for writing.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   fname      I   Name of EK file.\n   handle     O   Handle attached to EK file.\n\n-Detailed_Input\n\n   fname          is the name of an existing E-kernel file to be\n                  opened for write access.\n\n-Detailed_Output\n\n   handle         is the DAS file handle of the EK designate by\n                  fname.  This handle is used to identify the file\n                  to other EK routines.\n\n");

/* void ekrced_c ( SpiceInt handle,SpiceInt segno,SpiceInt recno,
ConstSpiceChar * column,SpiceInt * nvals,SpiceDouble * dvals,
SpiceBoolean * isnull ); */
static PyObject * spice_ekrced(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt nvals;
  SpiceDouble dvals;
  SpiceBoolean isnull;
  /* variables for inputs */
  int handle;
  int segno;
  int recno;
  char * column;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiis", &handle, &segno, &recno, &column));
  ekrced_c(handle, segno, recno, column, &nvals, &dvals, &isnull);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, nvals, dvals, get_py_boolean(&isnull));
  return returnVal;
}
PyDoc_STRVAR(ekrced_doc, "-Abstract\n\n   Read data from a double precision column in a specified EK\n   record.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle attached to EK file.\n   segno      I   Index of segment containing record.\n   recno      I   Record from which data is to be read.\n   column     I   Column name.\n   nvals      O   Number of values in column entry.\n   dvals      O   D.p. values in column entry.\n   isnull     O   Flag indicating whether column entry is null.\n\n-Detailed_Input\n\n   handle         is an EK file handle.  The file may be open for\n                  read or write access.\n\n   segno          is the index of the segment from which data is to\n                  be read.  The first segment in the file has index 0.\n\n   recno          is the index of the record from which data is to be\n                  read.  This record number is relative to the start\n                  of the segment indicated by segno; the first\n                  record in the segment has index 0.\n\n   column         is the name of the column from which data is to be\n                  read.\n\n-Detailed_Output\n\n   nvals,\n   ivals          are, respectively, the number of values found in\n                  the specified column entry and the set of values\n                  themselves.\n\n                  For columns having fixed-size entries, when a\n                  a column entry is null, nvals is still set to the\n                  column entry size.  For columns having variable-\n                  size entries, nvals is set to 1 for null entries.\n\n   isnull         is a logical flag indicating whether the returned\n                  column entry is null.\n\n");

/* void ekrcei_c ( SpiceInt handle,SpiceInt segno,SpiceInt recno,
ConstSpiceChar * column,SpiceInt * nvals,SpiceInt * ivals,
SpiceBoolean * isnull ); */
static PyObject * spice_ekrcei(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt nvals;
  SpiceInt ivals;
  SpiceBoolean isnull;
  /* variables for inputs */
  int handle;
  int segno;
  int recno;
  char * column;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiis", &handle, &segno, &recno, &column));
  ekrcei_c(handle, segno, recno, column, &nvals, &ivals, &isnull);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, nvals, ivals, get_py_boolean(&isnull));
  return returnVal;
}
PyDoc_STRVAR(ekrcei_doc, "-Abstract\n\n   Read data from an integer column in a specified EK record.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle attached to EK file.\n   segno      I   Index of segment containing record.\n   recno      I   Record from which data is to be read.\n   column     I   Column name.\n   nvals      O   Number of values in column entry.\n   ivals      O   Integer values in column entry.\n   isnull     O   Flag indicating whether column entry is null.\n\n-Detailed_Input\n\n   handle         is an EK file handle.  The file may be open for\n                  read or write access.\n\n   segno          is the index of the segment from which data is to\n                  be read.  The first segment in the file has index 0.\n\n   recno          is the index of the record from which data is to be\n                  read.  This record number is relative to the start\n                  of the segment indicated by segno; the first\n                  record in the segment has index 0.\n\n   column         is the name of the column from which data is to be\n                  read.\n\n\n-Detailed_Output\n\n   nvals,\n   ivals          are, respectively, the number of values found in\n                  the specified column entry and the set of values\n                  themselves.\n\n                  For columns having fixed-size entries, when a\n                  a column entry is null, nvals is still set to the\n                  column entry size.  For columns having variable-\n                  size entries, nvals is set to 1 for null entries.\n\n   isnull         is a logical flag indicating whether the returned\n                  column entry is null.\n\n");

/* void ekssum_c ( SpiceInt handle,SpiceInt segno,SpiceEKSegSum * segsum ); */
static PyObject * spice_ekssum(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceEKSegSum segsum;
  /* variables for inputs */
  int handle;
  int segno;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &handle, &segno));
  ekssum_c(handle, segno, &segsum);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_eksegsum(&segsum));
  return returnVal;
}
PyDoc_STRVAR(ekssum_doc, "-Abstract\n\n   Return summary information for a specified segment in a\n   specified EK.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of EK.\n   segno      I   Number of segment to be summarized.\n   segsum     O   EK segment summary.\n\n-Detailed_Input\n\n   handle         is an EK file handle specifying the EK containing\n                  the segment to be summarized.\n\n   segno          is the number of the segment whose summary is\n                  desired.  Segments are numbered from 0 to nseg-1,\n                  where nseg is the count of segments in the file.\n\n-Detailed_Output\n\n\n   segsum         is a pointer to an EK segment summary.  The summary is\n                  of type EKSegSum.  The structure contains the\n                  following members:\n\n                     tabnam      The name of the table to which the\n                                 segment belongs.\n\n                     nrows       The number of rows in the segment.\n\n                     ncols       The number of columns in the segment.\n\n                     cnames      An array of names of columns in the\n                                 segment. Column names may contain\n                                 as many as SPICE_EK_CNAMSZ characters.\n                                 The array contains room for\n                                 SPICE_EK_MXCLSG column names.\n\n                     cdescrs     An array of column attribute\n                                 descriptors of type SpiceEKAttDsc.\n                                 The array contains room for\n                                 SPICE_EK_MXCLSG descriptors.  The Ith\n                                 descriptor corresponds to the column\n                                 whose name is the Ith element of the\n                                 array cnames.\n\n\n                  The column attribute descriptors have the following\n                  members:\n\n                     cclass:     Column class code.\n\n                     dtype:      Data type code:  has type\n                                 SpiceEKDataType.\n\n                     strlen:     String length.  Applies to SPICE_CHR\n                                 type.  Value is SPICE_EK_VARSIZ for\n                                 variable-length strings.\n\n                     size:       Column entry size; this is the number\n                                 of array elements in a column entry.\n                                 The value is SPICE_EK_VARSIZ for\n                                 variable-size columns.\n\n                     indexd:     Index flag; value is SPICETRUE if the\n                                 column is indexed, SPICEFALSE\n                                 otherwise.\n\n                     nullok:     Null flag; value is SPICETRUE if the\n                                 column may contain null values,\n                                 SPICEFALSE otherwise.\n\n");

/* void ektnam_c ( SpiceInt n,SpiceInt lenout,SpiceChar * table ); */
static PyObject * spice_ektnam(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar table[STRING_LEN];
  /* variables for inputs */
  int n;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &n));
  ektnam_c(n, lenout, table);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, table);
  return returnVal;
}
PyDoc_STRVAR(ektnam_doc, "-Abstract\n\n   Return the name of a specified, loaded table.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   n          I   Index of table.\n   lenout     I   Maximum table name length.\n   table      O   Name of table.\n\n-Detailed_Input\n\n   n              is the index of the table whose name is desired.\n                  The value of n ranges from 0 to one less than the\n                  number of loaded tables.\n\n   lenout         is the maximum allowed table name length, including\n                  space for the terminating null character.  Normally\n                  the caller should allow enough room for\n                  SPICE_EK_TSTRLN characters; this parameter is\n                  declared in the header SpiceEK.h.\n\n-Detailed_Output\n\n   table          is the name of the nth loaded table.  If table\n                  is too small to accommodate the name, the name will\n                  be truncated on the right.\n\n");

/* void ekuced_c ( SpiceInt handle,SpiceInt segno,SpiceInt recno,
ConstSpiceChar * column,SpiceInt nvals,ConstSpiceDouble * dvals,
SpiceBoolean isnull ); */
static PyObject * spice_ekuced(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  int segno;
  int recno;
  char * column;
  int nvals;
  double * dvals;
  char isnull;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiisidO", &handle, &segno, &recno, &column, &nvals, &dvals, &isnull));
  ekuced_c(handle, segno, recno, column, nvals, dvals, isnull);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ekuced_doc, "-Abstract\n\n   Update a double precision column entry in a specified EK record.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle attached to EK file.\n   segno      I   Index of segment containing record.\n   recno      I   Record in which entry is to be updated.\n   column     I   Column name.\n   nvals      I   Number of values in new column entry.\n   dvals      I   Double precision values comprising new column entry.\n   isnull     I   Flag indicating whether column entry is null.\n\n-Detailed_Input\n\n   handle         is a file handle attached to an EK open for\n                  write access.\n\n   segno          is the index of the segment containing the column\n                  entry to be updated.  EK segment numbers range from\n                  0 to N-1, where N is the number of segments\n                  in the kernel.\n\n   recno          is the index of the record containing the column\n                  entry to be updated.  This record number is\n                  relative to the start of the segment indicated by\n                  segno; the first record in the segment has index 0.\n\n   column         is the name of the column containing the entry to\n                  be updated.\n\n   nvals,\n   dvals          are, respectively, the number of values to insert into\n                  the specified column and the set of values\n                  themselves.  The data values are written in to the\n                  specifed column and record.\n\n                  If the  column has fixed-size entries, then nvals\n                  must equal the entry size for the specified column.\n\n                  For columns with variable-sized entries, the size\n                  of the new entry need not match the size of the\n                  entry it replaces.  In particular, the new entry\n                  may be larger.\n\n   isnull         is a logical flag indicating whether the entry is\n                  null.  If isnull is SPICEFALSE, the column entry\n                  defined by nvals and dvals is added to the\n                  specified kernel file.\n\n                  If isnull is SPICETRUE, nvals and ivals are ignored.\n                  The column entry is marked as a null value.\n                  The contents of the column entry are undefined.\n                  If the column has fixed-length, variable-size\n                  entries, the number of entries is considered to\n                  be 1.\n\n                  The new entry may be null even though it replaces\n                  a non-null value, and vice versa.\n\n-Detailed_Output\n\n   None.  See $Particulars for a description of the effect of this\n   routine.\n\n");

/* void ekucei_c ( SpiceInt handle,SpiceInt segno,SpiceInt recno,
ConstSpiceChar * column,SpiceInt nvals,ConstSpiceInt * ivals,
SpiceBoolean isnull ); */
static PyObject * spice_ekucei(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  int segno;
  int recno;
  char * column;
  int nvals;
  int * ivals;
  char isnull;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiisiiO", &handle, &segno, &recno, &column, &nvals, &ivals, &isnull));
  ekucei_c(handle, segno, recno, column, nvals, ivals, isnull);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ekucei_doc, "-Abstract\n\n   Update an integer column entry in a specified EK record.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle attached to EK file.\n   segno      I   Index of segment containing record.\n   recno      I   Record in which entry is to be updated.\n   column     I   Column name.\n   nvals      I   Number of values in new column entry.\n   ivals      I   Integer values comprising new column entry.\n   isnull     I   Flag indicating whether column entry is null.\n\n-Detailed_Input\n\n   handle         is a file handle attached to an EK open for\n                  write access.\n\n   segno          is the index of the segment containing the column\n                  entry to be updated.  EK segment numbers range from\n                  0 to N-1, where N is the number of segments\n                  in the kernel.\n\n   recno          is the index of the record containing the column\n                  entry to be updated.  This record number is\n                  relative to the start of the segment indicated by\n                  segno; the first record in the segment has index 0.\n\n   column         is the name of the column containing the entry to\n                  be updated.\n\n   nvals,\n   ivals          are, respectively, the number of values to insert into\n                  the specified column and the set of values\n                  themselves.  The data values are written in to the\n                  specifed column and record.\n\n                  If the  column has fixed-size entries, then nvals\n                  must equal the entry size for the specified column.\n\n                  For columns with variable-sized entries, the size\n                  of the new entry need not match the size of the\n                  entry it replaces.  In particular, the new entry\n                  may be larger.\n\n   isnull         is a logical flag indicating whether the entry is\n                  null.  If isnull is SPICEFALSE, the column entry\n                  defined by nvals and ivals is added to the\n                  specified kernel file.\n\n                  If ISNULL is SPICETRUE, nvals and ivals are ignored.\n                  The column entry is marked as a null value.\n                  The contents of the column entry are undefined.\n                  If the column has fixed-length, variable-size\n                  entries, the number of entries is considered to\n                  be 1.\n\n                  The new entry may be null even though it replaces\n                  a non-null value, and vice versa.\n\n-Detailed_Output\n\n   None.  See $Particulars for a description of the effect of this\n   routine.\n\n");

/* void ekuef_c ( SpiceInt handle ); */
static PyObject * spice_ekuef(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  ekuef_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ekuef_doc, "-Abstract\n\n   Unload an EK file, making its contents inaccessible to the\n   EK reader routines, and clearing space in order to allow other\n   EK files to be loaded.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of EK file.\n\n-Detailed_Input\n\n   handle         is a file handle returned by eklef_c.\n\n-Detailed_Output\n\n   None.  See $Particulars for a description of the effect of this\n   routine.\n\n");

/* SpiceBoolean elemc_c ( ConstSpiceChar * item,SpiceCell * set ); */
static PyObject * spice_elemc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  char * item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &item));
  result = elemc_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(elemc_doc, "-Abstract\n\n   Determine whether an item is an element of a character set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be tested.\n   set        I   Set to be tested.\n\n   The function returns SPICETRUE if item is an element of set.\n\n-Detailed_Input\n\n   item        is an item which may or may not be an element of\n               the input set. Trailing blanks in item are not\n               significant.\n\n   set         is a CSPICE set.  set must be declared as a character\n               SpiceCell.  Trailing blanks in the members of set are\n               not significant.\n\n-Detailed_Output\n\n   The function returns SPICETRUE if item is a member of the specified\n   set, and returns SPICEFALSE otherwise.\n\n   The comparison between item and members of set is case-sensitive.\n   Trailing blanks are ignored.\n\n");

/* SpiceBoolean elemd_c ( SpiceDouble item,SpiceCell * set ); */
static PyObject * spice_elemd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  double item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &item));
  result = elemd_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(elemd_doc, "-Abstract\n\n   Determine whether an item is an element of a double precision set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be tested.\n   set        I   Set to be tested.\n\n   The function returns SPICETRUE if item is an element of set.\n\n-Detailed_Input\n\n   item        is an item which may or may not be an element of\n               the input set.\n\n\n   set         is a CSPICE set.  set must be declared as a double\n               precision SpiceCell.\n\n-Detailed_Output\n\n   The function returns SPICETRUE if item is a member of the set,\n   and returns SPICEFALSE otherwise.\n\n");

/* SpiceBoolean elemi_c ( SpiceInt item,SpiceCell * set ); */
static PyObject * spice_elemi(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  int item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &item));
  result = elemi_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(elemi_doc, "-Abstract\n\n   Determine whether an item is an element of an integer set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be tested.\n   set        I   Set to be tested.\n\n   The function returns SPICETRUE if item is an element of set.\n\n-Detailed_Input\n\n   item        is an item which may or may not be an element of\n               the input set.\n\n\n   set         is a CSPICE set.  set must be declared as an integer\n               SpiceCell.\n\n-Detailed_Output\n\n   The function returns SPICETRUE if item is a member of the set,\n   and returns SPICEFALSE otherwise.\n\n");

/* SpiceBoolean eqstr_c ( ConstSpiceChar * a,ConstSpiceChar * b ); */
static PyObject * spice_eqstr(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * a;
  char * b;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ss", &a, &b));
  result = eqstr_c(a, b);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(eqstr_doc, "-Abstract\n\n   Determine whether two strings are equivalent.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a,\n   b          I   Arbitrary character strings.\n\n   The function returns SPICETRUE if A and B are equivalent.\n\n-Detailed_Input\n\n   a,\n   b           are arbitrary character strings.\n\n-Detailed_Output\n\n   The function returns TRUE if A and B are equivalent: that is,\n   if A and B contain  the same characters in the same order,\n   when white space characters are ignored and uppercase and lowercase\n   characters are considered equal.\n\n   White space characters are those in the set\n\n      { ' ', '\\f', '\\n', '\\r', '\\t', '\\v' }\n\n   Note that this specification differs from that of the Fortran version\n   of this routine, which considers the blank ( ' ' ) to be the only\n   white space character.\n\n");

/* void el2cgv_c ( ConstSpiceEllipse * ellipse,SpiceDouble center[3],
SpiceDouble smajor[3],SpiceDouble sminor[3] ); */
static PyObject * spice_el2cgv(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble center[3];
  SpiceDouble smajor[3];
  SpiceDouble sminor[3];
  /* variables for inputs */
  ConstSpiceEllipse * ellipse;
  PyObject * py_ellipse = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "O", &py_ellipse));
  ellipse = get_spice_ellipse(py_ellipse);

  el2cgv_c(ellipse, center, smajor, sminor);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, center[0], center[1], center[2], smajor[0], smajor[1], smajor[2], sminor[0], sminor[1], sminor[2]);
  return returnVal;
}
PyDoc_STRVAR(el2cgv_doc, "-Abstract\n\n   Convert a CSPICE ellipse to a center vector and two generating\n   vectors.  The selected generating vectors are semi-axes of the\n   ellipse.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   ellipse    I   A CSPICE ellipse.\n   center,\n   smajor,\n   sminor     O   Center and semi-axes of ellipse.\n\n-Detailed_Input\n\n   ellipse        is a CSPICE ellipse.\n\n-Detailed_Output\n\n   center,\n   smajor,\n   sminor         are, respectively, a center vector, a semi-major\n                  axis vector, and a semi-minor axis vector that\n                  generate the input ellipse.  This ellipse is the\n                  set of points\n\n                     center + cos(theta) smajor + sin(theta) sminor\n\n                  where theta ranges over the interval (-pi, pi].\n\n");

/* void erract_c ( ConstSpiceChar * operation,SpiceInt lenout,
SpiceChar * action ); */
static PyObject * spice_erract(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar action[STRING_LEN];
  /* variables for inputs */
  char * operation;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &operation));
  erract_c(operation, lenout, action);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, action);
  return returnVal;
}
PyDoc_STRVAR(erract_doc, "-Abstract\n\n   Retrieve or set the default error action.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   op         I   Operation -- \"GET\" or \"SET\"\n   lenout     I   Length of list for output.\n   action    I/O  Error response action\n\n-Detailed_Input\n\n   op       indicates the operation -- \"GET\" or \"SET\".  \"GET\" means,\n            \"Set action to the current value of the error response\n            action.\"  \"SET\" means, \"update the error response action to\n            the value indicated by action.\"\n\n            op may be in mixed case; for example,\n\n               erract_c ( \"gEt\", lenout, action );\n\n            will work.\n\n   lenout   is the string size of output 'action' when op equals \"GET.\"\n            The size described by lenout should be large enough to\n            hold all characters of any possible output string\n            plus 1 (to accommodate the C null terminator).\n\n   action   is an input argument when op is \"SET.\"  It takes the\n            values,  \"ABORT\",  \"IGNORE\", \"REPORT\", \"RETURN\", and\n            \"DEFAULT\".\n\n            Briefly, the meanings of the error response\n            choices are as follows:\n\n            1.  \"ABORT\"  --  When an error is detected by a\n                             CSPICE routine, or when\n                             ANY routine signals detection\n                of an error via a call to sigerr_c, the\n                toolkit will output any error messages that\n                it has been enabled to output (see errprt_c\n                and errdev_c also ), and then execute an\n                exit statement.\n\n            2.  \"REPORT\" --  In this mode, the toolkit does\n                             NOT abort when errors are detected.\n                             When sigerr_c is called to report\n                an error, all error messages that the toolkit\n                is enabled to output will be sent to the\n                designated error output device.  Similarly,\n                a call to setmsg_c will result in the long\n                error message being output, if the toolkit\n                is enabled to output it.\n\n\n            3.  \"RETURN\" --  In this mode, the toolkit also\n                             does NOT abort when errors are\n                             detected.  Instead, error messages\n                are output if the toolkit is enabled to do\n                so, and subsequently, ALL TOOLKIT ROUTINES\n                RETURN IMMEDIATELY UPON ENTRY until the\n                error status is reset via a call to RESET.\n                (No, RESET itself doesn't return on entry).\n                Resetting the error status will cause the\n                toolkit routines to resume their normal\n                execution threads.\n\n\n\n            4.  \"IGNORE\" --  The toolkit will not take any\n                             action in response to errors;\n                             calls to sigerr_c will have no\n                             effect.\n\n\n            5.  \"DEFAULT\" -- This mode is the same as \"ABORT\",\n                             except that an additional error\n                             message is output.  The additional\n                             message informs the user that the\n                             error response action can be\n                             modified, and refers to documentation\n                             of the error handling feature.\n\n\n            action may be in mixed case; for example,\n\n                erract_c ( \"SET\", lenout,\"igNORe\" );\n\n            will work.\n\n-Detailed_Output\n\n   action   is an output argument returning the current error\n            response action when 'op' equals \"GET.\"  Possible values\n            are:  \"ABORT\", \"REPORT\", \"RETURN\", and \"IGNORE\".\n            See \"Detailed Input\" for descriptions of these values.\n\n");

/* void errch_c ( ConstSpiceChar * marker,ConstSpiceChar * string ); */
static PyObject * spice_errch(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * marker;
  char * string;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ss", &marker, &string));
  errch_c(marker, string);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(errch_doc, "-Abstract\n\n   Substitute a character string for the first occurrence of\n   a marker in the current long error message.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  ---------------------------------------------------\n   marker     I   A substring of the error message to be replaced.\n   string     I   The character string to substitute for marker.\n\n-Detailed_Input\n\n\n   marker     is a character string that marks a position in\n              the long error message where a character string\n              is to be substituted.  Leading and trailing blanks\n              in marker are not significant.\n\n              Case IS significant:  \"XX\" is considered to be\n              a different marker from \"xx\".\n\n   string     is a character string that will be substituted for\n              the first occurrence of marker in the long error\n              message.  This occurrence of the substring indicated\n              by marker will be removed and replaced by string.\n              Leading and trailing blanks in string are not\n              significant.  However, if string is completely blank,\n              a single blank character will be substituted for\n              the marker.\n\n-Detailed_Output\n\n   None.\n\n");

/* void errdev_c ( ConstSpiceChar * operation,SpiceInt lenout,
SpiceChar * device ); */
static PyObject * spice_errdev(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar device[STRING_LEN];
  /* variables for inputs */
  char * operation;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &operation));
  errdev_c(operation, lenout, device);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, device);
  return returnVal;
}
PyDoc_STRVAR(errdev_doc, "-Abstract\n\n   Retrieve or set the name of the current output\n   device for error messages.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   op         I   The operation:  \"GET\" or \"SET\".\n   lenout     I   Length of device for output.\n   device    I/O  The device name.\n\n-Detailed_Input\n\n   op      indicates the operation to be performed.  Possible\n           values are \"GET\" and \"SET\".  \"GET\" means, \"set\n           device equal to the name of the current error\n           output device\"  \"SET\" means, \"set the name of the\n           current error output device equal to the value of\n           device.\"\n\n   lenout  the string size of output 'device' when op equals \"GET.\"\n           The size described by lenout should be large enough to\n           hold all characters of any possible output string\n           plus 1 (to accommodate the C null terminator).\n\n   device  is an input when op has the value, \"SET\".  It\n           indicates an output device to which error messages\n           are to be sent.  Possible values for device are:\n\n            1.    A file name.  Note that the name must not\n                  use one of the reserved strings below.\n\n            2.    \"SCREEN\"    The output will go to the\n                   screen.  This is the default device.\n\n            3.    \"NULL\"      The data will not be output.\n\n            \"SCREEN\" and \"NULL\" can be written in mixed\n            case.  For example, the following call will work:\n\n            errdev_c ( \"SET\", lenout, \"screEn\" );\n\n-Detailed_Output\n\n   device  is an output returning the current error output device\n           when 'op' equals \"GET.\"  See \"Detailed Input\"\n           descriptions of these values.\n\n");

/* void errdp_c ( ConstSpiceChar * marker,SpiceDouble number ); */
static PyObject * spice_errdp(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * marker;
  double number;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sd", &marker, &number));
  errdp_c(marker, number);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(errdp_doc, "-Abstract\n\n   Substitute a double precision number for the first occurrence of\n   a marker found in the current long error message.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   marker     I   A substring of the error message to be replaced.\n   number     I   The d.p. number to substitute for marker.\n\n-Detailed_Input\n\n\n   marker     is a character string which marks a position in\n              the long error message where a character string\n              representing an double precision number is to be\n              substituted.  Leading and trailing blanks in marker\n              are not significant.\n\n              Case IS significant;  \"XX\" is considered to be\n              a different marker from \"xx\".\n\n   number     is an double precision number whose character\n              representation will be substituted for the first\n              occurrence of marker in the long error message.\n              This occurrence of the substring indicated by marker\n              will be removed, and replaced by a character string,\n              with no leading or trailing blanks, representing\n              number.\n\n-Detailed_Output\n\n   None.\n\n");

/* void errint_c ( ConstSpiceChar * marker,SpiceInt number ); */
static PyObject * spice_errint(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * marker;
  int number;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &marker, &number));
  errint_c(marker, number);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(errint_doc, "-Abstract\n\n   Substitute an integer for the first occurrence of a marker found\n   in the current long error message.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   marker     I   A substring of the error message to be replaced.\n   number     I   The integer to substitute for marker.\n\n-Detailed_Input\n\n   marker     is a character string which marks a position in\n              the long error message where a character string\n              representing an integer is to be substituted.\n              Leading and trailing blanks in marker are not\n              significant.\n\n              Case IS significant;  \"XX\" is considered to be\n              a different marker from \"xx\".\n\n   number     is an integer whose character representation will\n              be substituted for the first occurrence of marker\n              in the long error message.  This occurrence of the\n              substring indicated by marker will be removed, and\n              replaced by a character string, with no leading or\n              trailing blanks, representing number.\n\n-Detailed_Output\n\n   None.\n\n");

/* void errprt_c ( ConstSpiceChar * operation,SpiceInt lenout,
SpiceChar * list ); */
static PyObject * spice_errprt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar list[STRING_LEN];
  /* variables for inputs */
  char * operation;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &operation));
  errprt_c(operation, lenout, list);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, list);
  return returnVal;
}
PyDoc_STRVAR(errprt_doc, "-Abstract\n\n   Retrieve or set the list of error message items\n   to be output when an error is detected.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   op         I   The operation:  \"GET\" or \"SET\".\n   lenout     I   Length of list for output.\n   list      I/O  Specification of error messages to be output.\n\n-Detailed_Input\n\n   op      indicates the operation to be performed.  Possible\n           values are \"GET\" and \"SET\".\n\n           \"SET\" means, \"the following list specifies the default\n           selection of error messages to be output.\"  These are\n           the messages that will be output to the default error\n           output device (selected by errdev_c) when an error is\n           detected.\n\n           \"GET\" means, \"return the current list of error output\n           items.\"  This is the exact list that was set by the\n           last call to this routine with the \"SET\" option.\n\n           The option can be specified in mixed case.  For example,\n           the following call will work:\n\n           errprt_c ( \"SeT\", lenout, \"ALL\" )\n\n\n   lenout  is the allowed length of list when list is returning a\n           the error message list.  The size described by lenout\n           should be large enough to hold any possible output plus 1.\n\n\n   list    is a list of error message items.  The items\n           are delimited by commas.  The items that can be\n           in the list are the words:\n\n           1.  SHORT        ...indicates the short error message\n           2.  EXPLAIN      ...the explanation of the short message\n           3.  LONG         ...the long error message\n           4.  TRACEBACK    ...the traceback\n           5.  ALL          ...indicates \"output all messages\"\n           6.  NONE         ...indicates \"don't output any messages\"\n           7.  DEFAULT      ...same as ALL, but includes default\n                                message\n\n           A \"list\" is a character string containing some or\n           all of the above words, delimited by commas.  Examples\n           are:\n\n           1.  \"SHORT, EXPLAIN\"\n           2.  \"SHORT, LONG\"\n           3.  \"ALL\"\n           4.  \"NONE\"\n           5.  \"ALL, NONE, ALL, SHORT, NONE\"\n\n           Each word in the list can be thought of as\n           \"flipping a switch\" to enable or disable the output\n           of the message(s) indicated by the word.  The\n           words are acted on in the order they occur in the\n           list, starting with the leftmost word.  As examples,\n           consider the sample lists above.\n\n           The effect of the first list above, \"SHORT, EXPLAIN\",\n           is to enable the output of the short error message\n           and the explanatory text corresponding to it.\n\n           The effect of the second list is to enable the output\n           of the short and long messages.\n\n           The effect of the third list is to enable the output of\n           all of the error messages (short, long, explanation\n           of the short message, and traceback).\n\n           The effect of the fourth list is to disable output of\n           all of the messages.\n\n           The effect of the fifth list is to disable output of\n           all of the messages.  The reason for this is that\n           the words in the list are responded to in order,\n           from left to right, and \"NONE\" is the last word.\n\n           If any words other than SHORT, LONG, EXPLAIN, ALL,\n           DEFAULT, TRACEBACK or NONE appear in list, those words\n           that are recognized are responded to.  The words\n           that are not recognized are diagnosed as\n           erroneous, and error messages are generated\n           for each such unrecognized word.\n\n           The length of list is caller-defined, but only\n           the first 100 characters of list will be saved\n           for later retrieval.\n\n           Only the first 10 items in the list are used;\n           the rest are ignored.\n\n-Detailed_Output\n\n   list    is a list of error message items.  The value of\n           list is that set by the last call to this routine\n           using the \"SET\" option.  See \"Detailed Input\"\n           for a description of the possible values and\n           meanings of list.\n\n           The initial value returned is \"DEFAULT\".\n\n           Only the first 100 characters of list are saved\n           when the list is set; any additional characters\n           are truncated.  Therefore, the first 100\n           characters, at most, of the saved value of list\n           will be returned.\n\n");

/* void etcal_c ( SpiceDouble et,SpiceInt lenout,SpiceChar * string ); */
static PyObject * spice_etcal(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar string[STRING_LEN];
  /* variables for inputs */
  double et;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &et));
  etcal_c(et, lenout, string);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, string);
  return returnVal;
}
PyDoc_STRVAR(etcal_doc, "-Abstract\n\n   Convert from an ephemeris epoch measured in seconds past\n   the epoch of J2000 to a calendar string format using a\n   formal calendar free of leapseconds.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   et         I   Ephemeris time measured in seconds past J2000.\n   lenout     I   Length of output string.\n   string     O   A standard calendar representation of et.\n\n-Detailed_Input\n\n   et       is an epoch measured in ephemeris seconds\n            past the epoch of J2000.\n\n   lenout   is the user defined length of the output string.\n            The value should be at least 48 characters.\n\n-Detailed_Output\n\n   string   is a calendar string representing the input ephemeris\n            epoch.  This string is based upon extending the\n            Gregorian Calendar backward and forward indefinitely\n            keeping the same rules for determining leap years.\n            Moreover, there is no accounting for leapseconds.\n\n            To be sure that all of the date can be stored in\n            string, it should be declared to have length at\n            least 48 characters.\n\n            The string will have the following format\n\n               year (era) mon day, hr:mn:sc.sss\n\n            Where:\n\n               year --- is the year\n               era  --- is the chronological era associated with\n                        the date.  For years after 999 A.D.\n                        the era is omitted.  For years\n                        between 1 A.D. and 999 A.D. (inclusive)\n                        era is the string 'A.D.' For epochs\n                        before 1 A.D. Jan 1 00:00:00, era is\n                        given as 'B.C.' and the year is converted\n                        to years before the \"Christian Era\".\n                        The last B.C. epoch is\n\n                          1 B.C. DEC 31, 23:59:59.999\n\n                        The first A.D. epoch (which occurs .001\n                        seconds after the last B.C. epoch) is:\n\n                           1 A.D. JAN 1, 00:00:00.000\n\n                        Note: there is no year 0 A.D. or 0 B.C.\n               mon  --- is a 3-letter abbreviation for the month\n                        in all capital letters.\n               day  --- is the day of the month\n               hr   --- is the hour of the day (between 0 and 23)\n                        leading zeros are added to hr if the\n                        numeric value is less than 10.\n               mn   --- is the minute of the hour (0 to 59)\n                        leading zeros are added to mn if the\n                        numeric value is less than 10.\n               sc.sss   is the second of the minute to 3 decimal\n                        places ( 0 to 59.999).  Leading zeros\n                        are added if the numeric value is less\n                        than 10.  Seconds are truncated, not\n                        rounded.\n\n\n");

/* void et2lst_c ( SpiceDouble et,SpiceInt body,SpiceDouble lon,
ConstSpiceChar * type,SpiceInt timlen,SpiceInt ampmlen,SpiceInt * hr,
SpiceInt * mn,SpiceInt * sc,SpiceChar * time,SpiceChar * ampm ); */
static PyObject * spice_et2lst(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt hr;
  SpiceInt mn;
  SpiceInt sc;
  SpiceChar time[STRING_LEN];
  SpiceChar ampm[STRING_LEN];
  /* variables for inputs */
  double et;
  int body;
  double lon;
  char * type;
  int timlen = STRING_LEN;
  int ampmlen = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dids", &et, &body, &lon, &type));
  et2lst_c(et, body, lon, type, timlen, ampmlen, &hr, &mn, &sc, time, ampm);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, hr, mn, sc, time, ampm);
  return returnVal;
}
PyDoc_STRVAR(et2lst_doc, "-Abstract\n\n   Given an ephemeris epoch, compute the local solar time for\n   an object on the surface of a body at a specified longitude.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   et         I   Epoch in seconds past J2000 epoch.\n   body       I   ID-code of the body of interest.\n   lon        I   Longitude of surface point (RADIANS).\n   type       I   Type of longitude \"PLANETOCENTRIC\", etc.\n   timlen     I   Available room in output time string.\n   ampmlen    I   Available room in output `ampm' string.\n   hr         O   Local hour on a \"24 hour\" clock.\n   mn         O   Minutes past the hour.\n   sc         O   Seconds past the minute.\n   time       O   String giving local time on 24 hour clock.\n   ampm       O   String giving time on A.M./ P.M. scale.\n\n-Detailed_Input\n\n   `et'         is the epoch expressed in TDB seconds past\n              the J2000 epoch at which a local time is desired.\n\n   body       is the NAIF ID-code of a body on which local\n              time is to be measured.\n\n   lon        is the longitude (either planetocentric or\n              planetographic) in radians of the site on the\n              surface of body for which local time should be\n              computed.\n\n   type       is the form of longitude supplied by the variable\n              lon.   Allowed values are \"PLANETOCENTRIC\" and\n              \"PLANETOGRAPHIC\".  Note the case of the letters\n              in type is insignificant.  Both \"PLANETOCENTRIC\"\n              and \"planetocentric\" are recognized.  Leading and\n              trailing blanks in type are not significant.\n\n   timlen     The maximum allowed length of the output time string.\n              This length must large enough to hold the time string\n              plus the terminator.  If the output string is expected to\n              have x characters, timlen needs to be x + 1.\n\n   ampmlen    The maximum allowed length of the output `ampm' string.\n              This length must large enough to hold the apmpm string\n              plus the terminator.  If the output string is expected to\n              have x characters, ampmlen needs to be x + 1.\n\n-Detailed_Output\n\n   hr         is the local \"hour\" of the site specified at the epoch\n              `et'. Note that an \"hour\" of local time does not have the\n              same duration as an hour measured by conventional clocks.\n              It is simply a representation of an angle.  See\n              Particulars for a more complete discussion of the meaning\n              of local time.\n\n   mn         is the number of \"minutes\" past the hour of the local\n              time of the site at the epoch `et'. Again note that a\n              \"local minute\" is not the same as a minute you would\n              measure with conventional clocks.\n\n   sc         is the number of \"seconds\" past the minute of the local\n              time of the site at the epoch `et'.  Again note that a\n              \"local second\" is not the same as a second you would\n              measure with conventional clocks.\n\n   time       is a string expressing the local time on a \"24 hour\"\n              local clock.\n\n   ampm       is a string expressing the local time on a \"12 hour\"\n              local clock together with the traditional AM/PM label to\n              indicate whether the sun has crossed the local zenith\n              meridian.\n\n");

/* void et2utc_c ( SpiceDouble et ,ConstSpiceChar * format,SpiceInt prec,
SpiceInt lenout,SpiceChar * utcstr ); */
static PyObject * spice_et2utc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar utcstr[STRING_LEN];
  /* variables for inputs */
  double et;
  char * format;
  int prec;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dsi", &et, &format, &prec));
  et2utc_c(et, format, prec, lenout, utcstr);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, utcstr);
  return returnVal;
}
PyDoc_STRVAR(et2utc_doc, "-Abstract\n\n   Convert an input time from ephemeris seconds past J2000\n   to Calendar, Day-of-Year, or Julian Date format, UTC.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   et         I   Input epoch, given in ephemeris seconds past J2000.\n   format     I   Format of output epoch.\n   prec       I   Digits of precision in fractional seconds or days.\n   lenout     I   The length of the output string plus 1.\n   utcstr     O   Output time string, UTC.\n\n-Detailed_Input\n\n   et          is the input epoch, ephemeris seconds past J2000.\n\n   format      is the format of the output time string. It may be\n               any of the following:\n\n\n                 \"C\"      Calendar format, UTC.\n\n                 \"D\"      Day-of-Year format, UTC.\n\n                 \"J\"      Julian Date format, UTC.\n\n                 \"ISOC\"   ISO Calendar format, UTC.\n\n                 \"ISOD\"   ISO Day-of-Year format, UTC.\n\n   prec        is the number of digits of precision to which\n               fractional seconds (for Calendar and Day-of-Year\n               formats) or days (for Julian Date format) are to\n               be computed. If PREC is zero or smaller, no decimal\n               point is appended to the output string. If PREC is\n               greater than 14, it is treated as 14.\n\n   lenout      The allowed length of the output string.  This length\n               must large enough to hold the output string plus the\n               null terminator.  If the output string is expected to\n               have x characters, lenout must be x + 1.\n\n-Detailed_Output\n\n   utcstr      is the output time string equivalent to the input\n               epoch, in the specified format.  Some examples are\n               shown below.\n\n                     \"C\"      \"1986 APR 12 16:31:09.814\"\n                     \"D\"      \"1986-102 // 16:31:12.814\"\n                     \"J\"      \"JD 2446533.18834276\"\n                     \"ISOC\"   \"1987-04-12T16:31:12.814\"\n                     \"ISOD\"   \"1987-102T16:31:12.814\"\n\n               If an error occurs, utcstr is not changed.\n\n               Fractional seconds, or for Julian dates, fractional\n               days, are rounded to the precision level specified\n               by the input argument `prec'.\n\n               utcstr should be declared to be at least\n               20 + prec characters in length to ensure\n               sufficient room to hold calendar strings\n               for modern epochs.  For epochs prior to\n               1000 A.D. at least 24 + prec characters in\n               length are required to hold the output\n               calendar string.\n\n               For epochs prior to 1000 A.D. Jan 1 calendar\n               and day of year formats are returned with the\n               era (A.D. or B.C.) attached to the year.  For\n               example\n\n                    \"877 A.D. MAR 17 13:29:11.829\"\n                    \"471 B.C. Jan 01 12:00:00.000\"\n                    \"471 B.C. 001 // 12:00:00.000\"\n\n               ISO formats do not support the inclusion of\n               an era.  For years prior to 1 A.D. an error\n               will be signaled if ISO format has been requested.\n\n");

/* void eul2m_c ( SpiceDouble angle3,SpiceDouble angle2,SpiceDouble angle1,
SpiceInt axis3,SpiceInt axis2,SpiceInt axis1,SpiceDouble r [3][3] ); */
static PyObject * spice_eul2m(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble r[3][3];
  /* variables for inputs */
  double angle3;
  double angle2;
  double angle1;
  int axis3;
  int axis2;
  int axis1;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dddiii", &angle3, &angle2, &angle1, &axis3, &axis2, &axis1));
  eul2m_c(angle3, angle2, angle1, axis3, axis2, axis1, r);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, r[0][0], r[0][1], r[0][2], r[1][0], r[1][1], r[1][2], r[2][0], r[2][1], r[2][2]);
  return returnVal;
}
PyDoc_STRVAR(eul2m_doc, "-Abstract\n\n   Construct a rotation matrix from a set of Euler angles.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   angle3,\n   angle2,\n   angle1     I   Rotation angles about third, second, and first\n                  rotation axes (radians).\n   axis3,\n   axis2,\n   axis1      I   Axis numbers of third, second, and first rotation\n                  axes.\n\n   r          O   Product of the 3 rotations.\n\n-Detailed_Input\n\n   angle3,\n   angle2,\n   angle1,\n\n   axis3,\n   axis2,\n   axis1          are, respectively, a set of three angles and three\n                  coordinate axis numbers; each pair angleX and\n                  axisX specifies a coordinate transformation\n                  consisting of a rotation by angleX radians about\n                  the coordinate axis indexed by axisX.  These\n                  coordinate transformations are typically\n                  symbolized by\n\n                     [ angleX ]     .\n                               axisX\n\n                  See the -Particulars section below for details\n                  concerning this notation.\n\n                  Note that these coordinate transformations rotate\n                  vectors by\n\n                     -angleX\n\n                  radians about the axis indexed by axisX.\n\n                  The values of axisX may be 1, 2, or 3, indicating\n                  the x, y, and z axes respectively.\n\n-Detailed_Output\n\n   r              is a rotation matrix representing the composition\n                  of the rotations defined by the input angle-axis\n                  pairs.  Together, the three pairs specify a\n                  composite transformation that is the result of\n                  performing the rotations about the axes indexed\n                  by axis1, axis2, and axis3, in that order.  So,\n\n                     r = [ angle3 ]     [ angle2 ]      [ angle1 ]\n                                  axis3          axis2           axis1\n\n                  See the -Particulars section below for details\n                  concerning this notation.\n\n                  The resulting matrix r may be thought of as a\n                  coordinate transformation; applying it to a vector\n                  yields the vector's coordinates in the rotated\n                  system.\n\n                  Viewing r as a coordinate transformation matrix,\n                  the basis that r transforms vectors to is created\n                  by rotating the original coordinate axes first by\n                  angle1 radians about the coordinate axis indexed\n                  by axis1, next by angle2 radians about the\n                  coordinate axis indexed by axis2, and finally by\n                  angle3 radians about coordinate axis indexed by\n                  axis3.  At the second and third steps of this\n                  process, the coordinate axes about which rotations\n                  are performed belong to the bases resulting from\n                  the previous rotations.\n\n");

/* void eul2xf_c ( ConstSpiceDouble eulang[6],SpiceInt axisa,SpiceInt axisb,
SpiceInt axisc,SpiceDouble xform [6][6] ); */
static PyObject * spice_eul2xf(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble xform[6][6];
  /* variables for inputs */
  double eulang[6];
  int axisa;
  int axisb;
  int axisc;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddd)iii", &eulang[0], &eulang[1], &eulang[2], &eulang[3], &eulang[4], &eulang[5], &axisa, &axisb, &axisc));
  eul2xf_c(eulang, axisa, axisb, axisc, xform);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((dddddd)(dddddd)(dddddd)(dddddd)(dddddd)(dddddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, xform[0][0], xform[0][1], xform[0][2], xform[0][3], xform[0][4], xform[0][5], xform[1][0], xform[1][1], xform[1][2], xform[1][3], xform[1][4], xform[1][5], xform[2][0], xform[2][1], xform[2][2], xform[2][3], xform[2][4], xform[2][5], xform[3][0], xform[3][1], xform[3][2], xform[3][3], xform[3][4], xform[3][5], xform[4][0], xform[4][1], xform[4][2], xform[4][3], xform[4][4], xform[4][5], xform[5][0], xform[5][1], xform[5][2], xform[5][3], xform[5][4], xform[5][5]);
  return returnVal;
}
PyDoc_STRVAR(eul2xf_doc, "-Abstract\n\n   This routine computes a state transformation from an Euler angle\n   factorization of a rotation and the derivatives of those Euler\n   angles.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   eulang     I   An array of Euler angles and their derivatives.\n   axisa      I   Axis A of the Euler angle factorization.\n   axisb      I   Axis B of the Euler angle factorization.\n   axisc      I   Axis C of the Euler angle factorization.\n   xform      O   A state transformation matrix.\n\n-Detailed_Input\n\n\n   eulang      is the set of Euler angles corresponding to the\n               specified factorization.\n\n               If we represent r as shown here:\n\n                   r =  [ alpha ]     [ beta ]     [ gamma ]\n                                 axisa        axisb         axisc\n\n               then\n\n\n                  eulang[0] = alpha\n                  eulang[1] = beta\n                  eulang[2] = gamma\n                  eulang[3] = dalpha/dt\n                  eulang[4] = dbeta/dt\n                  eulang[5] = dgamma/dt\n\n\n   axisa       are the axes desired for the factorization of r.\n   axisb       All must be in the range from 1 to 3.  Moreover\n   axisc       it must be the case that axisa and axisb are distinct\n               and that axisb and axisc are distinct.\n\n               Every rotation matrix can be represented as a product\n               of three rotation matrices about the principal axes\n               of a reference frame.\n\n                   r =  [ alpha ]     [ beta ]     [ gamma ]\n                                 axisa        axisb         axisc\n\n               The value 1 corresponds to the X axis.\n               The value 2 corresponds to the Y axis.\n               The value 3 corresponds to the Z axis.\n\n\n-Detailed_Output\n\n   xform       is the state transformation corresponding r and dr/dt\n               as described above.  Pictorially,\n\n                    [       |        ]\n                    |  r    |    0   |\n                    |       |        |\n                    |-------+--------|\n                    |       |        |\n                    | dr/dt |    r   |\n                    [       |        ]\n\n               where r is a rotation that varies with respect to time\n               and dr/dt is its time derivative.\n\n");

/* SpiceBoolean exists_c ( ConstSpiceChar * name ); */
static PyObject * spice_exists(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * name;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &name));
  result = exists_c(name);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(exists_doc, "-Abstract\n\n   Determine whether a file exists.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   fname      I   Name of the file in question.\n\n   The function returns the value SPICETRUE if the file exists,\n   SPICEFALSE otherwise.\n\n-Detailed_Input\n\n   fname        is the name of the file in question. This may be\n                a system name, e.g.\n\n                      \"DISK:[USER.SUB1.SUB2]DATA.DAT\"\n                      \"\\usr\\dir1\\dir2\\data.dat\"\n\n                or a logical name, e.g.\n\n                      \"EPHEMERIS\"\n                      \"DATA$DIR:SAMPLE.DAT\"\n\n-Detailed_Output\n\n   The function returns the value SPICETRUE if the file exists,\n   SPICEFALSE otherwise.\n\n");

/* void expool_c ( ConstSpiceChar * name,SpiceBoolean * found ); */
static PyObject * spice_expool(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceBoolean found;
  /* variables for inputs */
  char * name;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &name));
  expool_c(name, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */

  if(found) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(expool_doc, "-Abstract\n\n   Confirm the existence of a kernel variable in the kernel\n   pool.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   Name of the variable whose value is to be returned.\n   found      O   True when the variable is in the pool.\n\n-Detailed_Input\n\n   name       is the name of the variable whose values are to be\n              returned.\n\n-Detailed_Output\n\n   found      is true whenever the specified variable is included\n              in the pool.\n\n");

/* SpiceBoolean failed_c ( void ); */
static PyObject * spice_failed(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  result = failed_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(failed_doc, "-Abstract\n\n   True if an error condition has been signalled via sigerr_c.\n   failed_c is the CSPICE status indicator.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n\n   The function takes the value SPICETRUE if an error condition\n   was detected; it is SPICEFALSE otherwise.\n\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   Please read the required reading file before reading this!\n\n   The value taken by failed_c indicates status.\n\n   The status value applies to the CSPICE routines,\n   and to any other routines which call the status-setting\n   routine, sigerr_c.\n\n   When failed_c has the value, SPICETRUE, an error condition\n   exists.   SPICEFALSE means \"no error.\"\n\n   More specifically, when failed_c has the value SPICETRUE,\n   some routine has indicated an error by calling the\n   CSPICE routine, sigerr_c.  All CSPICE routines\n   which can detect errors do this.  Non-CSPICE\n   routines may also reference sigerr_c if desired.\n\n   When failed_c has the value SPICEFALSE, either no routine\n   has yet signalled an error via sigerr_c, or the status\n   has been reset using, what else, reset_c.\n\n   failed_c is initialized to have the value, SPICEFALSE\n   This indicates a  \"no error\" status.\n\n   See \"particulars\" below for (slightly) more information.\n\n");

/* void frame_c ( SpiceDouble x[3],SpiceDouble y[3],SpiceDouble z[3] ); */
static PyObject * spice_frame(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble x[3];
  SpiceDouble y[3];
  SpiceDouble z[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  frame_c(x, y, z);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
  return returnVal;
}
PyDoc_STRVAR(frame_doc, "-Abstract\n\n    Given a vector x, this routine builds a right handed\n    orthonormal frame x,y,z where the output x is parallel to\n    the input x.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  ------------------------------------------------\n    x         I/O  Input vector. A parallel unit vector on output.\n    y          O   Unit vector in the plane orthogonal to x.\n    z          O   Unit vector given by x X y.\n\n-Detailed_Input\n\n\n    x      This vector is used to form the first vector of a\n           right-handed orthonormal triple.\n\n-Detailed_Output\n\n    x,\n    y,\n    z      form a right handed orthonormal frame, where x is\n           now a unit vector parallel to the original input\n           vector x.  There are no special geometric properties\n           connected to y and z (other than that they complete the\n           right handed frame).\n\n");

/* void frinfo_c ( SpiceInt frcode,SpiceInt * cent,SpiceInt * clss,
SpiceInt * clssid,SpiceBoolean * found ); */
static PyObject * spice_frinfo(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt cent;
  SpiceInt clss;
  SpiceInt clssid;
  SpiceBoolean found;
  /* variables for inputs */
  int frcode;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &frcode));
  frinfo_c(frcode, &cent, &clss, &clssid, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, cent, clss, clssid);
  return returnVal;
  }

}
PyDoc_STRVAR(frinfo_doc, "-Abstract\n\n   Retrieve the minimal attributes associated with a frame\n   needed for converting transformations to and from it.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   frcode     I   the idcode for some frame\n   cent       O   the center of the frame\n   frclss     O   the class (type) of the frame\n   clssid     O   the idcode for the frame within its class.\n   found      O   SPICETRUE if the requested information is available.\n\n-Detailed_Input\n\n   frcode      is the ID code for some reference frame.\n\n-Detailed_Output\n\n   cent        is the body ID code for the center of the reference\n               frame (if such an ID code is appropriate).\n\n   frclss      is the class or type of the frame.  This identifies\n               which subsystem will be used to perform frame\n               transformations.\n\n   clssid      is the ID-code used for the frame within its class.\n               This may be different from the frame ID-code.\n\n   found       is SPICETRUE if cent, frclss and frcode are available.\n               Otherwise, found is returned with the value SPICEFALSE.\n\n");

/* void frmnam_c ( SpiceInt frcode,SpiceInt lenout,SpiceChar * frname ); */
static PyObject * spice_frmnam(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar frname[STRING_LEN];
  /* variables for inputs */
  int frcode;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &frcode));
  frmnam_c(frcode, lenout, frname);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, frname);
  return returnVal;
}
PyDoc_STRVAR(frmnam_doc, "-Abstract\n\n   Retrieve the name of a reference frame associated with\n   a SPICE ID code.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   frcode     I   an integer code for a reference frame\n   lenout     I   Maximum length of output string.\n   frname     O   the name associated with the reference frame.\n\n-Detailed_Input\n\n   frcode         is an integer code for a reference frame.\n\n   lenout         is the maximum number of characters that can be\n                  accommodated in the output string.  This count\n                  includes room for the terminating null character.\n                  For example, if the maximum allowed length of the\n                  output string, including the terminating null, is 33\n                  characters, then lenout should be set to 33.\n\n-Detailed_Output\n\n   frname      is the name associated with the reference frame.\n               It will be returned left-justified.\n\n               If frcode is not recognized as the name of a\n               known reference frame, frname will be returned\n               as an empty string.\n\n               If frname is not sufficiently long to hold the\n               name, it will be truncated on the right.\n\n               All reference frame names are 32 or fewer characters\n               in length.  Thus declaring frname to be SpiceChar[33]\n               will ensure that the returned name will not be\n               truncated.\n\n");

/* void ftncls_c ( SpiceInt unit ); */
static PyObject * spice_ftncls(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int unit;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &unit));
  ftncls_c(unit);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ftncls_doc, "-Abstract\n\n   Close a file designated by a Fortran-style integer logical unit.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   unit       I   Fortran-style logical unit.\n\n\n-Detailed_Input\n\n   unit           is an integer representing a Fortran logical unit.\n\n                  Fortran logical units are integers which in the\n                  Fortran language play a role analogous to pointers to\n                  FILE structures in C.  In Fortran, when a file is\n                  opened and a logical unit is associated with the\n                  file, the file and unit are said to be ``connected.''\n                  A logical unit, once connected to a file, may be used\n                  to refer to the file in Fortran I/O statements.\n\n-Detailed_Output\n\n   None.\n\n");

/* void furnsh_c ( ConstSpiceChar * file ); */
static PyObject * spice_furnsh(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * file;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &file));
  furnsh_c(file);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(furnsh_doc, "-Abstract\n\n   Load one or more SPICE kernels into a program.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   file       I   Name of SPICE kernel file (text or binary).\n\n-Detailed_Input\n\n   file       is the name of a SPICE kernel file. The file may be\n              either binary or text. If the file is a binary SPICE\n              kernel it will be loaded into the appropriate SPICE\n              subsystem.  If `file' is a SPICE text kernel it will be\n              loaded into the kernel pool.  If `file' is a SPICE\n              meta-kernel containing initialization instructions\n              (through use of the correct kernel pool variables), the\n              files specified in those variables will be loaded into\n              the appropriate SPICE subsystem.\n\n              The SPICE text kernel format supports association of\n              names and data values using a \"keyword = value\" format.\n              The keyword-value pairs thus defined are called \"kernel\n              variables.\"\n\n              While any information can be placed in a text kernel\n              file, the following string valued kernel variables are\n              recognized by SPICE as meta-kernel keywords:\n\n                 KERNELS_TO_LOAD\n                 PATH_SYMBOLS\n                 PATH_VALUES\n\n              Each kernel variable is discussed below.\n\n                 KERNELS_TO_LOAD   is a list of SPICE kernels to be\n                                   loaded into a program.  If file\n                                   names do not fit within the kernel\n                                   pool 80 character limit, they may be\n                                   continued to subsequent array\n                                   elements by placing the continuation\n                                   character ('+') at the end of an\n                                   element and then placing the\n                                   remainder of the file name in the\n                                   next array element.  (See the\n                                   examples below for an illustration\n                                   of this technique or consult the\n                                   routine stpool_c for further\n                                   details.)\n\n                                   Alternatively you may use a\n                                   PATH_SYMBOL (see below) to\n                                   substitute for some part of a file\n                                   name.\n\n                 PATH_SYMBOLS      is a list of strings (without\n                                   embedded blanks), which if\n                                   encountered following the '$'\n                                   character will be replaced with the\n                                   corresponding PATH_VALUES string.\n                                   Note that PATH_SYMBOLS are\n                                   interpreted only in the\n                                   KERNELS_TO_LOAD variable. There must\n                                   be a one-to-one correspondence\n                                   between the values supplied for\n                                   PATH_SYMBOLS and PATH_VALUES.\n\n                 PATH_VALUES       is a list of expansions to use when\n                                   PATH_SYMBOLS are encountered.  See\n                                   the examples section for an\n                                   illustration of use of PATH_SYMBOLS\n                                   and PATH_VALUES.\n\n              These kernel pool variables persist within the kernel\n              pool only until all kernels associated with the\n              variable KERNELS_TO_LOAD have been loaded.  Once all\n              specified kernels have been loaded, the variables\n              KERNELS_TO_LOAD, PATH_SYMBOLS and PATH_VALUES are\n              removed from the kernel pool.\n\n-Detailed_Output\n\n   None. The routine loads various SPICE kernels for use by your\n   application.\n\n");

/* void gdpool_c ( ConstSpiceChar * name,SpiceInt start,SpiceInt room,
SpiceInt * n,SpiceDouble * values,SpiceBoolean * found ); */
static PyObject * spice_gdpool(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt n;
  SpiceDouble values;
  SpiceBoolean found;
  /* variables for inputs */
  char * name;
  int start;
  int room;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sii", &name, &start, &room));
  gdpool_c(name, start, room, &n, &values, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "d");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, n, values);
  return returnVal;
  }

}
PyDoc_STRVAR(gdpool_doc, "-Abstract\n\n   Return the d.p. value of a kernel variable from the kernel pool.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   Name of the variable whose value is to be returned.\n   start      I   Which component to start retrieving for name\n   room       I   The largest number of values to return.\n   n          O   Number of values returned for name.\n   values     O   Values associated with name.\n   found      O   True if variable is in pool.\n\n-Detailed_Input\n\n   name       is the name of the variable whose values are to be\n              returned. If the variable is not in the pool with\n              numeric type, found will be SPICEFALSE.\n\n   start      is the index of the first component of name to return.\n              The index follows the C convention of being 0 based.\n              If start is less than 0, it will be treated as 0.  If\n              start is greater than the total number of components\n              available for name, no values will be returned (n will\n              be set to zero).  However, found will still be set to\n              SPICETRUE\n\n   room       is the maximum number of components that should be\n              returned for this variable.  (Usually it is the amount\n              of room available in the array values). If room is\n              less than 1 the error SPICE(BADARRAYSIZE) will be\n              signaled.\n\n-Detailed_Output\n\n   n          is the number of values associated with name that\n              are returned.  It will always be less than or equal\n              to room.\n\n              If name is not in the pool with numeric type, no value\n              is given to n.\n\n   values     is the array of values associated with name.\n              If name is not in the pool with numeric type, no\n              values are given to the elements of values.\n\n   found      is SPICETRUE if the variable is in the pool and has\n              numeric type, SPICEFALSE if it is not.\n\n");

/* void georec_c ( SpiceDouble lon,SpiceDouble lat,SpiceDouble alt,
SpiceDouble re,SpiceDouble f,SpiceDouble rectan[3] ); */
static PyObject * spice_georec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rectan[3];
  /* variables for inputs */
  double lon;
  double lat;
  double alt;
  double re;
  double f;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddddd", &lon, &lat, &alt, &re, &f));
  georec_c(lon, lat, alt, re, f, rectan);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rectan[0], rectan[1], rectan[2]);
  return returnVal;
}
PyDoc_STRVAR(georec_doc, "-Abstract\n\n   Convert geodetic coordinates to rectangular coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   lon        I   Geodetic longitude of point (radians).\n   lat        I   Geodetic latitude  of point (radians).\n   alt        I   Altitude of point above the reference spheroid.\n   re         I   Equatorial radius of the reference spheroid.\n   f          I   Flattening coefficient.\n   rectan     O   Rectangular coordinates of point.\n\n-Detailed_Input\n\n   lon        Geodetic longitude of the input point.  This is the\n              angle between the prime meridian and the meridian\n              containing `rectan'.  The direction of increasing\n              longitude is from the +X axis towards the +Y axis.\n\n              Longitude is measured in radians.  On input, the\n              range of longitude is unrestricted.\n\n\n   lat        Geodetic latitude of the input point.  For a point P on\n              the reference spheroid, this is the angle between the XY\n              plane and the outward normal vector at P. For a point P\n              not on the reference spheroid, the geodetic latitude is\n              that of the closest point to P on the spheroid.\n\n              Latitude is measured in radians.  On input, the\n              range of latitude is unrestricted.\n\n\n   alt        Altitude of point above the reference spheroid.\n\n\n   re         Equatorial radius of a reference spheroid.  This spheroid\n              is a volume of revolution:  its horizontal cross sections\n              are circular.  The shape of the spheroid is defined by\n              an equatorial radius `re' and a polar radius `rp'.\n\n\n   f          Flattening coefficient = (re-rp) / re,  where `rp' is\n              the polar radius of the spheroid.\n\n-Detailed_Output\n\n   rectan     Rectangular coordinates of the input point.\n\n              The units associated with `rectan' are those associated\n              with the input `alt'.\n\n");

/* void getfat_c ( ConstSpiceChar * file,SpiceInt arclen,SpiceInt typlen,
SpiceChar * arch,SpiceChar * type ); */
static PyObject * spice_getfat(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar arch[STRING_LEN];
  SpiceChar type[STRING_LEN];
  /* variables for inputs */
  char * file;
  int arclen = STRING_LEN;
  int typlen = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &file));
  getfat_c(file, arclen, typlen, arch, type);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, arch, type);
  return returnVal;
}
PyDoc_STRVAR(getfat_doc, "-Abstract\n\n   Determine the file architecture and file type of most SPICE kernel\n   files.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   file       I   The name of a file to be examined.\n   arclen     I   Maximum length of output architecture string.\n   typlen     I   Maximum length of output type\n   string.\n   arch       O   The architecture of the kernel file.\n   type       O   The type of the kernel file.\n\n-Detailed_Input\n\n   arclen     is the maximum length of output architecture string arch,\n              including the terminating null.  For example, if arch\n              is to hold strings having 10 characters of actual data,\n              arclen should be set to 1l.\n\n   typlen     is the maximum length of output file type string type,\n              including the terminating null.  For example, if type\n              is to hold strings having 10 characters of actual data,\n              arclen should be set to 1l.\n\n   file       is the name of a SPICE kernel file whose architecture\n              and type are desired. This file must be closed when\n              this routine is called.\n\n-Detailed_Output\n\n   arch        is the file architecture of the SPICE kernel file\n               specified by file. If the architecture cannot be\n               determined or is not recognized the value \"?\" is\n               returned.\n\n               Architectures currently recognized are:\n\n                  DAF - The file is based on the DAF architecture.\n                  DAS - The file is based on the DAS architecture.\n                  XFR - The file is in a SPICE transfer file format.\n                  DEC - The file is an old SPICE decimal text file.\n                  ASC -- An ASCII text file.\n                  KPL -- Kernel Pool File (i.e., a text kernel)\n                  TXT -- An ASCII text file.\n                  TE1 -- Text E-Kernel type 1.\n                   ?  - The architecture could not be determined.\n\n               This variable must be at least 3 characters long.\n\n   type        is the type of the SPICE kernel file. If the type\n               can not be determined the value \"?\" is returned.\n\n               Kernel file types may be any sequence of at most four\n               printing characters. NAIF has reserved for its use\n               types which contain all upper case letters.\n\n               A file type of \"PRE\" means that the file is a\n               pre-release file.\n\n               This variable may be at most 4 characters long.\n\n");

/* void getmsg_c ( ConstSpiceChar * option,SpiceInt lenout,SpiceChar * msg ); */
static PyObject * spice_getmsg(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar msg[STRING_LEN];
  /* variables for inputs */
  char * option;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &option));
  getmsg_c(option, lenout, msg);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, msg);
  return returnVal;
}
PyDoc_STRVAR(getmsg_doc, "-Abstract\n\n   Retrieve the current short error message,\n   the explanation of the short error message, or the\n   long error message.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   option     I   Indicates type of error message.\n   lenout     I   Available space in the output string msg.\n   msg        O   The error message to be retrieved.\n\n\n-Detailed_Input\n\n   option  Indicates the type of error message to be retrieved.\n           The choices are:  The current short error message,\n           the explanation of the short error message,\n           or the current long error message.\n\n           Possible values of option are:\n\n              \"SHORT\"   -- indicates that the short message is to\n                           be retrieved\n\n              \"EXPLAIN\" -- indicates that the explanation of the\n                           short message is to be retrieved\n\n              \"LONG\"    -- indicates that the long message is to\n                           be retrieved\n\n           The input strings indicating the choice of option\n           may be in mixed case.  For example, there is no\n           problem with the call,\n\n              getmsg_c ( \"loNg\", MSGLEN, msg );\n\n\n\n   lenout  is the maximum allowed length of the output message string,\n           including the terminating null character.  For example,\n           if the caller wishes to be able to accept an 1840-character\n           message, lenout must be set to (at least) 1841.  The current\n           maximum long error message length is in fact 1840 characters.\n\n\n-Detailed_Output\n\n   msg     is the error message to be retrieved. Its value depends on\n           option, and on whether an error condition exists.\n\n           When there is no error condition, msg is empty.\n\n           If an error condition does exist,\n\n             When option is\n\n             \"SHORT\"    --  msg is the current short error message.\n                            This is a very condensed, 25-character\n                            description of the error.\n\n             \"EXPLAIN\"  --  msg is the explanation of the current\n                            short error message.  This is a one-line\n                            expansion of the text of the short\n                            message.\n\n                            Most CSPICE short error messages\n                            have corresponding explanation text.\n                            For other short error messages, if\n                            there is no explanation text, msg\n                            will be blank.\n\n             \"LONG\"     --  msg is the current long error message.\n                            The long error message is a detailed\n                            explanation of the error, possibly\n                            containing data specific to the\n                            particular occurrence of the error.\n                            Not all errors have long error messages.\n                            If there is none, msg will be empty.\n                            Long error messages are no longer than\n                            320 characters.\n\n             invalid    --  msg will remain unchanged from\n                            its value on input.\n\n\n");

/* SpiceBoolean gfbail_c ( void ); */
static PyObject * spice_gfbail(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  result = gfbail_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(gfbail_doc, "-Abstract\n\n   Indicate whether an interrupt signal (SIGINT) has been received.\n\n-Brief_I/O\n\n   The function returns SPICETRUE if an interrupt signal has\n   been received by the GF handler.\n\n-Detailed_Input\n\n   None\n\n-Detailed_Output\n\n   The function returns SPICETRUE if an interrupt signal has been\n   received by the GF handler gfinth_c since the first setting of the\n   handler or the last call to gfclrh_c, whichever is most recent.\n   Otherwise the function returns SPICEFALSE.\n\n");

/* void gfclrh_c ( void ); */
static PyObject * spice_gfclrh(PyObject *self, PyObject *args)
{

  char failed = 0;

  gfclrh_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(gfclrh_doc, "-Abstract\n\n   Clear the interrupt signal handler status, so that future calls\n   to gfbail_c will indicate no interrupt was received.\n\n-Brief_I/O\n\n   None. This routine operates by side effects; see Particulars\n   below.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   None.\n\n");

/* void gfdist_c ( ConstSpiceChar * target,ConstSpiceChar * abcorr,
ConstSpiceChar * obsrvr,ConstSpiceChar * relate,SpiceDouble refval,
SpiceDouble adjust,SpiceDouble step,SpiceInt nintvls,SpiceCell * cnfine,
SpiceCell * result ); */
static PyObject * spice_gfdist(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * target;
  char * abcorr;
  char * obsrvr;
  char * relate;
  double refval;
  double adjust;
  double step;
  int nintvls;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssssdddi", &target, &abcorr, &obsrvr, &relate, &refval, &adjust, &step, &nintvls));
  gfdist_c(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gfdist_doc, "-Abstract\n\n   Return the time window over which a specified constraint on\n   observer-target distance is met.\n\n-Brief_I/O\n\n   Variable         I/O  Description\n   ---------------  ---  ------------------------------------------------\n   SPICE_GF_CNVTOL   P   Convergence tolerance\n   target            I   Name of the target body.\n   abcorr            I   Aberration correction flag.\n   obsrvr            I   Name of the observing body.\n   relate            I   Relational operator.\n   refval            I   Reference value.\n   adjust            I   Adjustment value for absolute extrema searches.\n   step              I   Step size used for locating extrema and roots.\n   nintvls           I   Workspace window interval count.\n   cnfine           I-O  SPICE window to which the search is confined.\n   result            O   SPICE window containing results.\n\n-Detailed_Input\n\n   target      is the name of a target body. Optionally, you may supply\n               a string containing the integer ID code for the object.\n               For example both \"MOON\" and \"301\" are legitimate strings\n               that indicate the Moon is the target body.\n\n               The target and observer define a position vector which\n               points from the observer to the target; the length of\n               this vector is the \"distance\" that serves as the subject\n               of the search performed by this routine.\n\n               Case and leading or trailing blanks are not significant\n               in the string `target'.\n\n\n   abcorr      indicates the aberration corrections to be applied to\n               the observer-target position vector to account for\n               one-way light time and stellar aberration.\n\n               Any aberration correction accepted by the SPICE\n               routine spkezr_c is accepted here. See the header\n               of spkezr_c for a detailed description of the\n               aberration correction options. For convenience,\n               the options are listed below:\n\n                  \"NONE\"     Apply no correction.\n\n                  \"LT\"       \"Reception\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  \"LT+S\"     \"Reception\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  \"CN\"       \"Reception\" case:  converged\n                             Newtonian light time correction.\n\n                  \"CN+S\"     \"Reception\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n               Case and leading or trailing blanks are not significant\n               in the string `abcorr'.\n\n\n   obsrvr      is the name of the observing body. Optionally, you may\n               supply a string containing the integer ID code for the\n               object. For example both \"MOON\" and \"301\" are legitimate\n               strings that indicate the Moon is the observer.\n\n               Case and leading or trailing blanks are not significant\n               in the string `obsrvr'.\n\n\n   relate      is a relational operator used to define a constraint on\n               the observer-target distance. The result window found by\n               this routine indicates the time intervals where the\n               constraint is satisfied. Supported values of `relate'\n               and corresponding meanings are shown below:\n\n                  \">\"      Distance is greater than the reference\n                           value `refval'.\n\n                  \"=\"      Distance is equal to the reference\n                           value `refval'.\n\n                  \"<\"      Distance is less than the reference\n                           value `refval'.\n\n                  \"ABSMAX\"  Distance is at an absolute maximum.\n\n                  \"ABSMIN\"  Distance is at an absolute  minimum.\n\n                  \"LOCMAX\"  Distance is at a local maximum.\n\n                  \"LOCMIN\"  Distance is at a local minimum.\n\n               `relate' may be used to specify an \"adjusted\" absolute\n               extremum constraint: this requires the distance\n               to be within a specified offset relative to an\n               absolute extremum. The argument `adjust' (described\n               below) is used to specify this offset.\n\n               Local extrema are considered to exist only in the\n               interiors of the intervals comprising the confinement\n               window:  a local extremum cannot exist at a boundary\n               point of the confinement window.\n\n               Case and leading or trailing blanks are not significant\n               in the string `relate'.\n\n\n   `refval'    is the reference value used together with the argument\n               `relate' to define an equality or inequality to be\n               satisfied by the distance between the specified target\n               and observer. See the discussion of `relate' above for\n               further information.\n\n               The units of `refval' are km.\n\n\n   adjust      is a parameter used to modify searches for absolute\n               extrema: when `relate' is set to \"ABSMAX\" or \"ABSMIN\"\n               and `adjust' is set to a positive value, gfdist_c will\n               find times when the observer-target distance is within\n               `adjust' km of the specified extreme value.\n\n               If `adjust' is non-zero and a search for an absolute\n               minimum `min' is performed, the result window contains\n               time intervals when the observer-target distance has\n               values between `min' and min+adjust.\n\n               If the search is for an absolute maximum `max', the\n               corresponding range is from max-adjust to `max'.\n\n               `adjust' is not used for searches for local extrema,\n               equality or inequality conditions.\n\n\n   step        is the step size to be used in the search. `step' must\n               be shorter than any maximal time interval on which the\n               specified distance function is monotone increasing or\n               decreasing. That is, if the confinement window is\n               partitioned into alternating intervals on which the\n               distance function is either monotone increasing or\n               decreasing, `step' must be shorter than any of these\n               intervals.\n\n               However, `step' must not be *too* short, or the search\n               will take an unreasonable amount of time.\n\n               The choice of `step' affects the completeness but not\n               the precision of solutions found by this routine; the\n               precision is controlled by the convergence tolerance.\n               See the discussion of the parameter SPICE_GF_CNVTOL for\n               details.\n\n               STEP has units of TDB seconds.\n\n\n\n   nintvls     is a parameter specifying the number of intervals that\n               can be accommodated by each of the dynamically allocated\n               workspace windows used internally by this routine.\n\n               In many cases, it's not necessary to compute an accurate\n               estimate of how many intervals are needed; rather, the\n               user can pick a size considerably larger than what's\n               really required.\n\n               However, since excessively large arrays can prevent\n               applications from compiling, linking, or running\n               properly, sometimes `nintvls' must be set according to\n               the actual workspace requirement. A rule of thumb for\n               the number of intervals needed is\n\n                  nintvls  =  2*n  +  ( m / step )\n\n               where\n\n                  n     is the number of intervals in the confinement\n                        window\n\n                  m     is the measure of the confinement window, in\n                        units of seconds\n\n                  step  is the search step size in seconds\n\n\n   cnfine      is a SPICE window that confines the time period over\n               which the specified search is conducted. `cnfine' may\n               consist of a single interval or a collection of\n               intervals.\n\n               The endpoints of the time intervals comprising `cnfine'\n               are interpreted as seconds past J2000 TDB.\n\n               See the Examples section below for a code example that\n               shows how to create a confinement window.\n\n\n-Detailed_Output\n\n\n   cnfine      is the input confinement window, updated if necessary so\n               the control area of its data array indicates the\n               window's size and cardinality. The window data are\n               unchanged.\n\n\n   result      is the window of intervals, contained within the\n               confinement window `cnfine', on which the specified\n               distance constraint is satisfied.\n\n               The endpoints of the time intervals comprising `result'\n               are interpreted as seconds past J2000 TDB.\n\n               If `result' is non-empty on input, its contents will be\n               discarded before gfdist_c conducts its search.\n\n");

/* void gfinth_c ( int sigcode ); */
static PyObject * spice_gfinth(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int sigcode;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &sigcode));
  gfinth_c(sigcode);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(gfinth_doc, "-Abstract\n\n   Respond to the interrupt signal SIGINT: save an indication\n   that the signal has been received. This routine restores\n   itself as the handler for SIGINT.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   sigcode    I   Interrupt signal ID code.\n\n-Detailed_Input\n\n   sigcode    is a signal code. `sigcode' is expected to be the\n              ANSI C parameter SIGINT, which represents the\n              interrupt signal.\n\n-Detailed_Output\n\n   None.\n\n");

/* void gfoclt_c ( ConstSpiceChar * occtyp,ConstSpiceChar * front,
ConstSpiceChar * fshape,ConstSpiceChar * fframe,ConstSpiceChar * back,
ConstSpiceChar * bshape,ConstSpiceChar * bframe,ConstSpiceChar * obsrvr,
ConstSpiceChar * abcorr,SpiceDouble step,SpiceCell * cnfine,
SpiceCell * result ); */
static PyObject * spice_gfoclt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * occtyp;
  char * front;
  char * fshape;
  char * fframe;
  char * back;
  char * bshape;
  char * bframe;
  char * obsrvr;
  char * abcorr;
  double step;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sssssssssd", &occtyp, &front, &fshape, &fframe, &back, &bshape, &bframe, &obsrvr, &abcorr, &step));
  gfoclt_c(occtyp, front, fshape, fframe, back, bshape, bframe, obsrvr, abcorr, step, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gfoclt_doc, "-Abstract\n\n   Determine time intervals when an observer sees one target\n   occulted by, or in transit across, another.\n\n-Brief_I/O\n\n   VARIABLE        I/O  DESCRIPTION\n   --------------- ---  -------------------------------------------------\n   SPICE_GF_CNVTOL  P   Convergence tolerance.\n   occtyp           I   Type of occultation.\n   front            I   Name of body occulting the other.\n   fshape           I   Type of shape model used for front body.\n   fframe           I   Body-fixed, body-centered frame for front body.\n   back             I   Name of body occulted by the other.\n   bshape           I   Type of shape model used for back body.\n   bframe           I   Body-fixed, body-centered frame for back body.\n   abcorr           I   Aberration correction flag.\n   obsrvr           I   Name of the observing body.\n   step             I   Step size in seconds for finding occultation\n                        events.\n   cnfine          I-O  SPICE window to which the search is restricted.\n   result           O   SPICE window containing results.\n\n-Detailed_Input\n\n\n   occtyp     indicates the type of occultation that is to be found.\n              Note that transits are considered to be a type of\n              occultation.\n\n              Supported values and corresponding definitions are:\n\n                 \"FULL\"               denotes the full occultation\n                                      of the body designated by\n                                      `back' by the body designated\n                                      by `front', as seen from\n                                      the location of the observer.\n                                      In other words, the occulted\n                                      body is completely invisible\n                                      as seen from the observer's\n                                      location.\n\n                 \"ANNULAR\"            denotes an annular\n                                      occultation: the body\n                                      designated by `front' blocks\n                                      part of, but not the limb of,\n                                      the body designated by `back',\n                                      as seen from the location of\n                                      the observer.\n\n                 \"PARTIAL\"            denotes a partial, non-annular\n                                      occultation: the body designated\n                                      by `front' blocks part, but not\n                                      all, of the limb of the body\n                                      designated by `back', as seen\n                                      from the location of the\n                                      observer.\n\n                 \"ANY\"                denotes any of the above three\n                                      types of occultations:\n                                      \"PARTIAL\", \"ANNULAR\", or\n                                      \"FULL\".\n\n                                      \"ANY\" should be used to search\n                                      for times when the body\n                                      designated by `front' blocks\n                                      any part of the body designated\n                                      by `back'.\n\n                                      The option \"ANY\" must be used\n                                      if either the front or back\n                                      target body is modeled as\n                                      a point.\n\n              Case and leading or trailing blanks are not\n              significant in the string `occtyp'.\n\n\n   front      is the name of the target body that occults---that is,\n              passes in front of---the other. Optionally, you may\n              supply the integer NAIF ID code for the body as a\n              string. For example both \"MOON\" and \"301\" are\n              legitimate strings that designate the Moon.\n\n              Case and leading or trailing blanks are not\n              significant in the string `front'.\n\n\n   fshape     is a string indicating the geometric model used to\n              represent the shape of the front target body. The\n              supported options are:\n\n                 \"ELLIPSOID\"     Use a triaxial ellipsoid model\n                                 with radius values provided via the\n                                 kernel pool. A kernel variable\n                                 having a name of the form\n\n                                    \"BODYnnn_RADII\"\n\n                                 where nnn represents the NAIF\n                                 integer code associated with the\n                                 body, must be present in the kernel\n                                 pool. This variable must be\n                                 associated with three numeric\n                                 values giving the lengths of the\n                                 ellipsoid's X, Y, and Z semi-axes.\n\n                 \"POINT\"         Treat the body as a single point.\n                                 When a point target is specified,\n                                 the occultation type must be\n                                 set to \"ANY\".\n\n              At least one of the target bodies `front' and `back' must\n              be modeled as an ellipsoid.\n\n              Case and leading or trailing blanks are not\n              significant in the string `fshape'.\n\n\n   fframe     is the name of the body-fixed, body-centered reference\n              frame associated with the front target body. Examples\n              of such names are \"IAU_SATURN\" (for Saturn) and\n              \"ITRF93\" (for the Earth).\n\n              If the front target body is modeled as a point, `fframe'\n              should be left empty or blank.\n\n              Case and leading or trailing blanks bracketing a\n              non-blank frame name are not significant in the string\n              `fframe'.\n\n\n   back       is the name of the target body that is occulted\n              by---that is, passes in back of---the other.\n              Optionally, you may supply the integer NAIF ID code\n              for the body as a string. For example both \"MOON\" and\n              \"301\" are legitimate strings that designate the Moon.\n\n              Case and leading or trailing blanks are not\n              significant in the string `back'.\n\n\n   bshape     is the shape specification for the body designated by\n              `back'. The supported options are those for `fshape'. See\n              the description of `fshape' above for details.\n\n\n   bframe     is the name of the body-fixed, body-centered reference\n              frame associated with the ``back'' target body.\n              Examples of such names are \"IAU_SATURN\" (for Saturn)\n              and \"ITRF93\" (for the Earth).\n\n              If the back target body is modeled as a point, `bframe'\n              should be left empty or blank.\n\n              Case and leading or trailing blanks bracketing a\n              non-blank frame name are not significant in the string\n              `bframe'.\n\n\n   abcorr     indicates the aberration corrections to be applied to\n              the state of each target body to account for one-way\n              light time.  Stellar aberration corrections are\n              ignored if specified, since these corrections don't\n              improve the accuracy of the occultation determination.\n\n              See the header of the SPICE routine spkezr_c for a\n              detailed description of the aberration correction\n              options. For convenience, the options supported by\n              this routine are listed below:\n\n                 \"NONE\"     Apply no correction.\n\n                 \"LT\"       \"Reception\" case:  correct for\n                            one-way light time using a Newtonian\n                            formulation.\n\n                 \"CN\"       \"Reception\" case:  converged\n                            Newtonian light time correction.\n\n                 \"XLT\"      \"Transmission\" case:  correct for\n                            one-way light time using a Newtonian\n                            formulation.\n\n                 \"XCN\"      \"Transmission\" case:  converged\n                            Newtonian light time correction.\n\n              Case and blanks are not significant in the string\n              `abcorr'.\n\n\n   obsrvr     is the name of the body from which the occultation is\n              observed. Optionally, you may supply the integer NAIF\n              ID code for the body as a string.\n\n              Case and leading or trailing blanks are not\n              significant in the string `obsrvr'.\n\n\n   step       is the step size to be used in the search. `step' must\n              be shorter than any interval, within the confinement\n              window, over which the specified condition is met. In\n              other words, `step' must be shorter than the shortest\n              occultation event that the user wishes to detect; `step'\n              must also be shorter than the shortest time interval\n              between two occultation events that occur within the\n              confinement window (see below). However, `step' must not\n              be *too* short, or the search will take an unreasonable\n              amount of time.\n\n              The choice of `step' affects the completeness but not the\n              precision of solutions found by this routine; the\n              precision is controlled by the convergence tolerance. See\n              the discussion of the parameter SPICE_GF_CNVTOL for\n              details.\n\n              `step' has units of TDB seconds.\n\n\n   cnfine     is a SPICE window that confines the time period over\n              which the specified search is conducted. `cnfine' may\n              consist of a single interval or a collection of\n              intervals.\n\n              The endpoints of the time intervals comprising `cnfine'\n              are interpreted as seconds past J2000 TDB.\n\n              See the Examples section below for a code example\n              that shows how to create a confinement window.\n\n\n-Detailed_Output\n\n   cnfine     is the input confinement window, updated if necessary\n              so the control area of its data array indicates the\n              window's size and cardinality. The window data are\n              unchanged.\n\n\n   result     is a SPICE window representing the set of time\n              intervals, within the confinement period, when the\n              specified occultation occurs.\n\n              The endpoints of the time intervals comprising `result'\n              are interpreted as seconds past J2000 TDB.\n\n              If `result' is non-empty on input, its contents\n              will be discarded before gfoclt_c conducts its\n              search.\n\n");

/* void gfposc_c ( ConstSpiceChar * target,ConstSpiceChar * frame,
ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,ConstSpiceChar * crdsys,
ConstSpiceChar * coord,ConstSpiceChar * relate,SpiceDouble refval,
SpiceDouble adjust,SpiceDouble step,SpiceInt nintvls,SpiceCell * cnfine,
SpiceCell * result ); */
static PyObject * spice_gfposc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * target;
  char * frame;
  char * abcorr;
  char * obsrvr;
  char * crdsys;
  char * coord;
  char * relate;
  double refval;
  double adjust;
  double step;
  int nintvls;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sssssssdddi", &target, &frame, &abcorr, &obsrvr, &crdsys, &coord, &relate, &refval, &adjust, &step, &nintvls));
  gfposc_c(target, frame, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step, nintvls, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gfposc_doc, "-Abstract\n\n     Determine time intervals for which a coordinate of an\n     observer-target position vector satisfies a numerical constraint.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   SPICE_GF_CNVTOL\n              P   Convergence tolerance.\n   target     I   Name of the target body\n   frame      I   Name of the reference frame for coordinate calculations\n   abcorr     I   Aberration correction flag\n   obsrvr     I   Name of the observing body\n   crdsys     I   Name of the coordinate system containing COORD\n   coord      I   Name of the coordinate of interest\n   relate     I   Operator that either looks for an extreme value\n                  (max, min, local, absolute) or compares the\n                  coordinate value and refval\n   refval     I   Reference value\n   adjust     I   Adjustment value for absolute extrema searches\n   step       I   Step size used for locating extrema and roots\n   nintvls    I   Workspace window interval count\n   cnfine    I-O  SPICE window to which the search is restricted\n   result     O   SPICE window containing results\n\n-Detailed_Input\n\n   target     the string name of a target body.  Optionally, you may\n              supply the integer ID code for the object as an\n              integer string.  For example both 'MOON' and '301'\n              are legitimate strings that indicate the moon is the\n              target body.\n\n              The target and observer define a position vector\n              that points from the observer to the target.\n\n   frame      the string name of the reference frame in which to perform\n              state look-ups and coordinate calculations.\n\n              The SPICE frame subsystem must recognize the 'frame' name.\n\n   abcorr     the string description of the aberration corrections to apply\n              to the state evaluations to account for one-way light time\n              and stellar aberration.\n\n              This routine accepts the same aberration corrections as does\n              the SPICE routine SPKEZR. See the header of SPKEZR for a\n              detailed description of the aberration correction options.\n              For convenience, the options are listed below:\n\n                  'NONE'     Apply no correction.\n\n                  'LT'       \"Reception\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  'LT+S'     \"Reception\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  'CN'       \"Reception\" case:  converged\n                             Newtonian light time correction.\n\n                  'CN+S'     \"Reception\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n                  'XLT'      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  'XLT+S'    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  'XCN'      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  'XCN+S'    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n              The abcorr string lacks sensitivity to case, and to embedded,\n              leading and trailing blanks.\n\n   obsrvr     the string naming the observing body. Optionally, you\n              may supply the ID code of the object as an integer\n              string. For example, both 'EARTH' and '399' are\n              legitimate strings to supply to indicate the\n              observer is Earth.\n\n   crdsys     the string name of the coordinate system for which the\n              coordinate of interest is a member.\n\n   coord      the string name of the coordinate of interest in crdsys.\n\n              The supported coordinate systems and coordinate names are:\n\n              Coordinate System (CRDSYS)    Coordinates (COORD)      Range\n\n                 'RECTANGULAR'                  'X'\n                                                'Y'\n                                                'Z'\n\n                 'LATITUDINAL'                  'RADIUS'\n                                                'LONGITUDE'        (-Pi,Pi]\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n\n                 'RA/DEC'                       'RANGE'\n                                                'RIGHT ASCENSION'  [0,2Pi)\n                                                'DECLINATION'      [-Pi/2,Pi/2]\n\n                 'SPHERICAL'                    'RADIUS'\n                                                'COLATITUDE'       [0,Pi]\n                                                'LONGITUDE'        (-Pi,Pi]\n\n                 'CYLINDRICAL'                  'RADIUS'\n                                                'LONGITUDE'        [0,2Pi)\n                                                'Z'\n\n                 'GEODETIC'                     'LONGITUDE'        (-Pi,Pi]\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n                                                'ALTITUDE'\n\n                 'PLANETOGRAPHIC'               'LONGITUDE'        [0,2Pi)\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n                                                'ALTITUDE'\n\n                  Limit searches for coordinate events in the GEODETIC and\n                  PLANETOGRAPHIC coordinate systems to TARGET bodies with\n                  axial symmetry in the equatorial plane, i.e. equality\n                  of the body X and Y radii (oblate or prolate spheroids).\n\n     relate    the string or character describing the relational operator\n               used to define a constraint on the selected coordinate of the\n               observer-target vector. The result window found by this routine\n               indicates the time intervals where the constraint is satisfied.\n               Supported values of relate and corresponding meanings are\n               shown below:\n\n                  '>'      Separation is greater than the reference\n                           value refval.\n\n                  '='      Separation is equal to the reference\n                           value refval.\n\n                  '<'      Separation is less than the reference\n                           value refval.\n\n                 'ABSMAX'  Separation is at an absolute maximum.\n\n                 'ABSMIN'  Separation is at an absolute  minimum.\n\n                 'LOCMAX'  Separation is at a local maximum.\n\n                 'LOCMIN'  Separation is at a local minimum.\n\n              The caller may indicate that the region of interest\n              is the set of time intervals where the quantity is\n              within a specified measure of an absolute extremum.\n              The argument ADJUST (described below) is used to\n              specify this measure.\n\n              Local extrema are considered to exist only in the\n              interiors of the intervals comprising the confinement\n              window:  a local extremum cannot exist at a boundary\n              point of the confinement window.\n\n              The relate string lacks sensitivity to case, leading\n              and trailing blanks.\n\n   refval     the double precision reference value used together with\n              relate argument to define an equality or inequality to\n              satisfy by the selected coordinate of the observer-target\n              vector. See the discussion of relate above for\n              further information.\n\n              The units of refval correspond to the type as defined\n              by coord, radians for angular measures, kilometers for\n              distance measures.\n\n   adjust     a double precision value used to modify searches for\n              absolute extrema: when relate is set to ABSMAX or ABSMIN and\n              adjust is set to a positive value, gfposc_c finds times when the\n              observer-target vector coordinate is within adjust\n              radians/kilometers of the specified extreme value.\n\n              For relate set to ABSMAX, the result window contains\n              time intervals when the observer-target vector coordinate has\n              values between ABSMAX - adjust and ABSMAX.\n\n              For relate set to ABSMIN, the result window contains\n              time intervals when the observer-target vector coordinate has\n              values between ABSMIN and ABSMIN + adjust.\n\n              adjust is not used for searches for local extrema,\n              equality or inequality conditions.\n\n   step       the double precision time step size to use in the search.\n              step must be short enough for a search using this step\n              size to locate the time intervals where coordinate function\n              of the observer-target vector is monotone increasing or\n              decreasing. However, step must not be *too* short, or\n              the search will take an unreasonable amount of time.\n\n              The choice of step affects the completeness but not\n              the precision of solutions found by this routine; the\n              precision is controlled by the convergence tolerance.\n\n              step has units of seconds.\n\n   nintvls    an integer value specifying the number of intervals in the\n              the internal workspace array used by this routine. 'nintvls'\n              should be at least as large as the number of intervals\n              within the search region on which the specified observer-target\n              vector coordinate function is monotone increasing or decreasing.\n              It does no harm to pick a value of 'nintvls' larger than the\n              minimum required to execute the specified search, but if chosen\n              too small, the search will fail.\n\n   cnfine     a double precision SPICE window that confines the time\n              period over which the specified search is conducted.\n              cnfine may consist of a single interval or a collection\n              of intervals.\n\n              In some cases the confinement window can be used to\n              greatly reduce the time period that must be searched\n              for the desired solution. See the Particulars section\n              below for further discussion.\n\n              See the Examples section below for a code example\n              that shows how to create a confinement window.\n\n-Detailed_Output\n\n   cnfine     is the input confinement window, updated if necessary\n              so the control area of its data array indicates the\n              window's size and cardinality. The window data are\n              unchanged.\n\n   result     the SPICE window of intervals, contained within the\n              confinement window cnfine, on which the specified\n              constraint is satisfied.\n\n              If result is non-empty on input, its contents\n              will be discarded before gfposc_c conducts its\n              search.\n\n              result must be declared and initialized with sufficient\n              size to capture the full set of time intervals\n              within the search region on which the specified constraint\n              is satisfied.\n\n              If the search is for local extrema, or for absolute\n              extrema with adjust set to zero, then normally each\n              interval of result will be a singleton: the left and\n              right endpoints of each interval will be identical.\n\n              If no times within the confinement window satisfy the\n              constraint, result will be returned with a\n              cardinality of zero.\n\n");

/* void gfrefn_c ( SpiceDouble t1,SpiceDouble t2,SpiceBoolean s1,
SpiceBoolean s2,SpiceDouble * t ); */
static PyObject * spice_gfrefn(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble t;
  /* variables for inputs */
  double t1;
  double t2;
  char s1;
  char s2;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddOO", &t1, &t2, &s1, &s2));
  gfrefn_c(t1, t2, s1, s2, &t);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, t);
  return returnVal;
}
PyDoc_STRVAR(gfrefn_doc, "-Abstract\n\n   For those times when we can't do better, we use a bisection\n   method to find the next time at which to test for state change.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   t1         I   One of two values bracketing a state change.\n   t2         I   The other value that brackets a state change.\n   s1         I   State at t1.\n   s2         I   State at t2.\n   t          O   New value at which to check for transition.\n\n-Detailed_Input\n\n   t1         One of two abscissa values (usually times)\n              bracketing a state change.\n\n   t2         The other abscissa value that brackets a state change.\n\n   s1         System state at t1. This argument is provided\n              for forward compatibility; it's not currently used.\n\n   s2         System state at t2. This argument is provided\n              for forward compatibility; it's not currently used.\n\n-Detailed_Output\n\n   t          is the midpoint of t1 and t2.\n\n");

/* void gfrepf_c ( void ); */
static PyObject * spice_gfrepf(PyObject *self, PyObject *args)
{

  char failed = 0;

  gfrepf_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(gfrepf_doc, "-Abstract\n\n   Finish a GF progress report.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   None.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   None. This routine does perform console I/O when progress\n   reporting is enabled.\n\n");

/* void gfrepi_c ( SpiceCell * window,ConstSpiceChar * begmss,
ConstSpiceChar * endmss ); */
static PyObject * spice_gfrepi(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  SpiceCell * window;
  PyObject * py_window = NULL;
  char * begmss;
  char * endmss;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "Oss", &py_window, &begmss, &endmss));
  window = get_spice_cell(py_window);

  gfrepi_c(window, begmss, endmss);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(gfrepi_doc, "-Abstract\n\n   This entry point initializes a search progress report.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   MXBEGM     P   Maximum progress report message prefix length.\n   MXENDM     P   Maximum progress report message suffix length.\n   window     I   A window over which a job is to be performed.\n   begmss     I   Beginning of the text portion of the output message.\n   endmss     I   End of the text portion of the output message.\n\n-Detailed_Input\n\n   window   is the name of a constraint window. This is the window\n            associated with some root finding activity. It is\n            used to determine how much total time is being searched\n            in order to find the events of interest.\n\n\n   begmss   is the beginning of the progress report message\n            written to standard output by the GF subsystem.\n            This output message has the form\n\n               begmss xxx.xx% endmss\n\n            For example, the progress report message created\n            by the CSPICE routine gfocce_c at the completion\n            of a search is\n\n               Occultation/transit search 100.00% done.\n\n            In this message, begmss is\n\n               \"Occultation/transit search\"\n\n            The total length of `begmss' must be less than\n            MXBEGM characters.\n\n            All characters of `begmss' must be printable.\n\n\n   endmss   is the last portion of the output message\n            written to standard output by the GF subsystem.\n\n            The total length of `endmss' must be less than\n            MXENDM characters.\n\n            All characters of `endmss' must be printable.\n\n\n-Detailed_Output\n\n  None.\n\n");

/* void gfrepu_c ( SpiceDouble ivbeg,SpiceDouble ivend,SpiceDouble time ); */
static PyObject * spice_gfrepu(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double ivbeg;
  double ivend;
  double time;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &ivbeg, &ivend, &time));
  gfrepu_c(ivbeg, ivend, time);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(gfrepu_doc, "-Abstract\n\n   This function tells the progress reporting system\n   how far a search has progressed.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   ivbeg      I   Start time of work interval.\n   ivend      I   End time of work interval.\n   time       I   Current time being examined in the search process.\n\n-Detailed_Input\n\n   ivbeg,\n   ivend    are the bounds of a time interval. Normally this interval\n            is contained within the confinement window `cnfine' passed to\n            gfrepi_c on the latest call to that function, but this is\n            not a requirement.\n\n            In order for a meaningful progress report to be displayed,\n            `ivbeg' and `ivend' must satisfy the following constraints:\n\n               - `ivbeg' must be less than or equal to `ivend'.\n\n               - Over a search pass, the sum of the differences\n\n                    ivend - ivbeg\n\n                 for all calls to this routine made during the pass\n                 must equal the measure (that is, the sum of the\n                 lengths of the intervals) of the confinement window\n                 `cnfine'.\n\n\n   time     is the current time reached in the search for an event.\n            `time' must lie in the interval\n\n               ivbeg : ivend\n\n            inclusive. The input values of `time' for a given interval\n            need not form an increasing sequence.\n\n\n-Detailed_Output\n\n   None. This routine does perform console I/O when progress\n   reporting is enabled.\n\n");

/* void gfrfov_c ( ConstSpiceChar * inst,ConstSpiceDouble raydir [3],
ConstSpiceChar * rframe,ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,
SpiceDouble step,SpiceCell * cnfine,SpiceCell * result ); */
static PyObject * spice_gfrfov(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * inst;
  double raydir[3];
  char * rframe;
  char * abcorr;
  char * obsrvr;
  double step;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s(ddd)sssd", &inst, &raydir[0], &raydir[1], &raydir[2], &rframe, &abcorr, &obsrvr, &step));
  gfrfov_c(inst, raydir, rframe, abcorr, obsrvr, step, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gfrfov_doc, "-Abstract\n\n   Determine time intervals when a specified ray intersects the\n   space bounded by the field-of-view (FOV) of a specified\n   instrument.\n\n-Brief_I/O\n\n   VARIABLE         I/O  DESCRIPTION\n   ---------------  ---  ------------------------------------------------\n   SPICE_GF_MARGIN   P   Minimum complement of FOV cone angle.\n   SPICE_GF_CNVTOL   P   Convergence tolerance.\n   SPICE_GF_MAXVRT   P   Maximum number of FOV boundary vertices.\n   inst              I   Name of the instrument.\n   raydir            I   Ray's direction vector.\n   rframe            I   Reference frame of ray's direction vector.\n   abcorr            I   Aberration correction flag.\n   obsrvr            I   Name of the observing body.\n   step              I   Step size in seconds for finding FOV events.\n   cnfine           I-O  SPICE window to which the search is restricted.\n   result            O   SPICE window containing results.\n\n\n-Detailed_Input\n\n\n   inst       indicates the name of an instrument, such as a\n              spacecraft-mounted framing camera, the field of view\n              (FOV) of which is to be used for an target intersection\n              search: the direction from the observer to a target\n              is represented by a ray, and times when the specified\n              ray intersects the region of space bounded by the FOV\n              are sought.\n\n              The position of the instrument designated by `inst' is\n              considered to coincide with that of the ephemeris\n              object designated by the input argument `obsrvr' (see\n              description below).\n\n              `inst' must have a corresponding NAIF ID and a frame\n              defined, as is normally done in a frame kernel. It\n              must also have an associated reference frame and a FOV\n              shape, boresight and boundary vertices (or reference\n              vector and reference angles) defined, as is usually\n              done in an instrument kernel.\n\n              See the header of the CSPICE routine getfov_c for a\n              description of the required parameters associated with\n              an instrument.\n\n\n   raydir     is the direction vector associated with a ray\n              representing a target. The ray emanates from the\n              location of the ephemeris object designated by the\n              input argument `obsrvr' and is expressed relative to the\n              reference frame designated by `rframe' (see descriptions\n              below).\n\n\n   rframe     is the name of the reference frame associated with\n              the input ray's direction vector `raydir'.\n\n              Since light time corrections are not supported for\n              rays, the orientation of the frame is always evaluated\n              at the epoch associated with the observer, as opposed\n              to the epoch associated with the light-time corrected\n              position of the frame center.\n\n              Case and leading or trailing blanks bracketing a\n              non-blank frame name are not significant in the string\n              `rframe'.\n\n\n   abcorr     indicates the aberration corrections to be applied\n              when computing the ray's direction.\n\n              The supported aberration correction options are\n\n                 \"NONE\"          No correction.\n                 \"S\"             Stellar aberration correction,\n                                 reception case.\n                 \"XS\"            Stellar aberration correction,\n                                 transmission case.\n\n              For detailed information, see the geometry finder\n              required reading, gf.req.\n\n              Case, leading and trailing blanks are not significant\n              in the string `abcorr'.\n\n\n   obsrvr     is the name of the body from which the target\n              represented by `raydir' is observed. The instrument\n              designated by `inst' is treated as if it were co-located\n              with the observer.\n\n\n   step       is the step size to be used in the search. `step' must\n              be shorter than any interval, within the confinement\n              window, over which the specified condition is met. In\n              other words, `step' must be shorter than the shortest\n              visibility event that the user wishes to detect. `step'\n              also must be shorter than the minimum duration\n              separating any two visibility events. However, `step'\n              must not be *too* short, or the search will take an\n              unreasonable amount of time.\n\n              The choice of `step' affects the completeness but not\n              the precision of solutions found by this routine; the\n              precision is controlled by the convergence tolerance.\n              See the discussion of the parameter SPICE_GF_CNVTOL for\n              details.\n\n              `step' has units of seconds.\n\n\n   cnfine     is a SPICE window that confines the time period over\n              which the specified search is conducted. `cnfine' may\n              consist of a single interval or a collection of\n              intervals.\n\n              The endpoints of the time intervals comprising `cnfine'\n              are interpreted as seconds past J2000 TDB.\n\n              See the Examples section below for a code example\n              that shows how to create a confinement window.\n\n-Detailed_Output\n\n\n   cnfine     is the input confinement window, updated if necessary\n              so the control area of its data array indicates the\n              window's size and cardinality. The window data are\n              unchanged.\n\n\n   result     is a SPICE window representing the set of time\n              intervals, within the confinement period, when the\n              input ray is \"visible\"; that is, when the ray is\n              contained in the space bounded by the specified\n              instrument's field of view.\n\n              The endpoints of the time intervals comprising `result'\n              are interpreted as seconds past J2000 TDB.\n\n              If `result' is non-empty on input, its contents\n              will be discarded before gfrfov_c conducts its\n              search.\n\n");

/* void gfrr_c ( ConstSpiceChar * target,ConstSpiceChar * abcorr,
ConstSpiceChar * obsrvr,ConstSpiceChar * relate,SpiceDouble refval,
SpiceDouble adjust,SpiceDouble step,SpiceInt nintvls,SpiceCell * cnfine,
SpiceCell * result ); */
static PyObject * spice_gfrr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * target;
  char * abcorr;
  char * obsrvr;
  char * relate;
  double refval;
  double adjust;
  double step;
  int nintvls;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssssdddi", &target, &abcorr, &obsrvr, &relate, &refval, &adjust, &step, &nintvls));
  gfrr_c(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gfrr_doc, "-Abstract\n\n   Determine time intervals for which a specified constraint\n   on the observer-target range rate is met.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   SPICE_GF_CNVTOL   P   Convergence tolerance\n   target            I   Name of the target body.\n   abcorr            I   Aberration correction flag.\n   obsrvr            I   Name of the observing body.\n   relate            I   Relational operator.\n   refval            I   Reference value.\n   adjust            I   Adjustment value for absolute extrema searches.\n   step              I   Step size used for locating extrema and roots.\n   nintvls           I   Workspace window interval count.\n   cnfine           I-O  SPICE window to which the search is confined.\n   result            O   SPICE window containing results.\n\n-Detailed_Input\n\n   target      is the name of a target body. The target body is\n               an ephemeris object; its trajectory is given by\n               SPK data.\n\n               The string `target' is case-insensitive, and leading\n               and trailing blanks in `target' are not significant.\n               Optionally, you may supply a string containing the\n               integer ID code for the object. For example both\n               \"MOON\" and \"301\" are legitimate strings that indicate\n               the Moon is the target body.\n\n               The target and observer define a position vector which\n               points from the observer to the target; the time derivative\n               length of this vector is the \"range rate\" that serves as\n               the subject of the search performed by this routine.\n\n\n   abcorr      indicates the aberration corrections to be applied to\n               the observer-target state vector to account for\n               one-way light time and stellar aberration.\n\n               Any aberration correction accepted by the SPICE\n               routine spkezr_c is accepted here. See the header\n               of spkezr_c for a detailed description of the\n               aberration correction options. For convenience,\n               the options are listed below:\n\n                  \"NONE\"     Apply no correction.\n\n                  \"LT\"       \"Reception\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  \"LT+S\"     \"Reception\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  \"CN\"       \"Reception\" case:  converged\n                             Newtonian light time correction.\n\n                  \"CN+S\"     \"Reception\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n               Case and blanks are not significant in the string\n               `abcorr'.\n\n   obsrvr      is the name of the observing body. The observing body is\n               an ephemeris object; its trajectory is given by SPK\n               data. `obsrvr' is case-insensitive, and leading and\n               trailing blanks in `obsrvr' are not significant.\n               Optionally, you may supply a string containing the\n               integer ID code for the object. For example both \"MOON\"\n               and \"301\" are legitimate strings that indicate the Moon\n               is the observer.\n\n   relate      is a relational operator used to define a constraint\n               on observer-target range rate. The result window found\n               by this routine indicates the time intervals where\n               the constraint is satisfied. Supported values of\n               `relate' and corresponding meanings are shown below:\n\n                  \">\"      Distance is greater than the reference\n                           value `refval'.\n\n                  \"=\"      Distance is equal to the reference\n                           value `refval'.\n\n                  \"<\"      Distance is less than the reference\n                           value `refval'.\n\n\n                 \"ABSMAX\"  Distance is at an absolute maximum.\n\n                 \"ABSMIN\"  Distance is at an absolute  minimum.\n\n                 \"LOCMAX\"  Distance is at a local maximum.\n\n                 \"LOCMIN\"  Distance is at a local minimum.\n\n              The caller may indicate that the region of interest\n              is the set of time intervals where the quantity is\n              within a specified distance of an absolute extremum.\n              The argument `adjust' (described below) is used to\n              specify this distance.\n\n              Local extrema are considered to exist only in the\n              interiors of the intervals comprising the confinement\n              window:  a local extremum cannot exist at a boundary\n              point of the confinement window.\n\n              Case is not significant in the string `relate'.\n\n    refval    is the reference value used together with the argument\n              `relate' to define an equality or inequality to be\n              satisfied by the range rate between the specified target\n              and observer. See the discussion of `relate' above for\n              further information.\n\n              The units of `refval' are km/sec.\n\n   adjust     is a parameter used to modify searches for absolute\n              extrema: when `relate' is set to \"ABSMAX\" or \"ABSMIN\" and\n              `adjust' is set to a positive value, gfdist_c will find\n              times when the observer-target range rate is within\n              `adjust' km/sec of the specified extreme value.\n\n              If `adjust' is non-zero and a search for an absolute\n              minimum `min' is performed, the result window contains\n              time intervals when the observer-target range rate has\n              values between `min' and min+adjust.\n\n              If the search is for an absolute maximum `max', the\n              corresponding range is from max-adjust to `max'.\n\n              `adjust' is not used for searches for local extrema,\n              equality or inequality conditions.\n\n   step       is the step size to be used in the search. `step' must\n              be short enough for a search using this step size\n              to locate the time intervals where the specified\n              range rate function is monotone increasing or\n              decreasing. However, `step' must not be *too* short, or\n              the search will take an unreasonable amount of time.\n\n              The choice of `step' affects the completeness but not\n              the precision of solutions found by this routine; the\n              precision is controlled by the convergence tolerance.\n              See the discussion of the parameter SPICE_GF_CNVTOL for\n              details.\n\n              `step' has units of TDB seconds.\n\n   nintvls    is a parameter specifying the number of intervals that\n              can be accommodated by each of the dynamically allocated\n              windows used internally by this routine. `nintvls' should\n              be at least as large as the number of intervals within\n              the search region on which the specified range rate\n              function is monotone increasing or decreasing. See\n              the Examples section below for code examples illustrating\n              the use of this parameter.\n\n   cnfine     is a SPICE window that confines the time period over\n              which the specified search is conducted. `cnfine' may\n              consist of a single interval or a collection of\n              intervals.\n\n              In some cases the confinement window can be used to\n              greatly reduce the time period that must be searched\n              for the desired solution. See the Particulars section\n              below for further discussion.\n\n              See the Examples section below for a code example\n              that shows how to create a confinement window.\n\n-Detailed_Output\n\n   cnfine     is the input confinement window, updated if necessary\n              so the control area of its data array indicates the\n              window's size and cardinality. The window data are\n              unchanged.\n\n\n   result     is the window of intervals, contained within the\n              confinement window `cnfine', on which the specified\n              constraint is satisfied.\n\n              If `result' is non-empty on input, its contents will be\n              discarded before 'gfrr_c' conducts its search.\n\n              `result' must be declared with sufficient size to capture\n              the full set of time intervals within the search region\n              on which the specified constraint is satisfied.\n\n              If the search is for local extrema, or for absolute\n              extrema with `adjust' set to zero, then normally each\n              interval of `result' will be a singleton: the left and\n              right endpoints of each interval will be identical.\n\n              If no times within the confinement window satisfy the\n              constraint, `result' will be returned with a cardinality\n              of zero.\n\n");

/* void gfsep_c ( ConstSpiceChar * targ1,ConstSpiceChar * frame1,
ConstSpiceChar * shape1,ConstSpiceChar * targ2,ConstSpiceChar * frame2,
ConstSpiceChar * shape2,ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,
ConstSpiceChar * relate,SpiceDouble refval,SpiceDouble adjust,SpiceDouble step,
SpiceInt nintvls,SpiceCell * cnfine,SpiceCell * result ); */
static PyObject * spice_gfsep(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * targ1;
  char * frame1;
  char * shape1;
  char * targ2;
  char * frame2;
  char * shape2;
  char * abcorr;
  char * obsrvr;
  char * relate;
  double refval;
  double adjust;
  double step;
  int nintvls;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sssssssssdddi", &targ1, &frame1, &shape1, &targ2, &frame2, &shape2, &abcorr, &obsrvr, &relate, &refval, &adjust, &step, &nintvls));
  gfsep_c(targ1, frame1, shape1, targ2, frame2, shape2, abcorr, obsrvr, relate, refval, adjust, step, nintvls, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gfsep_doc, "-Abstract\n\n   Determine time intervals when the angular separation between\n   the position vectors of two target bodies relative to an observer\n   satisfies a numerical relationship.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   SPICE_GF_CNVTOL\n              P   Convergence tolerance.\n   targ1      I   Name of first body\n   shape1     I   Name of shape model describing the first body\n   frame1     I   The body-fixed reference frame of the first body\n   targ2      I   Name of second body\n   shape2     I   Name of the shape model describing the second body\n   frame2     I   The body-fixed reference frame of the second body\n   abcorr     I   Aberration correction flag\n   obsrvr     I   Name of the observing body\n   relate     I   Operator that either looks for an extreme value\n                  (max, min, local, absolute) or compares the\n                  angular separation value and refval\n   refval     I   Reference value\n   adjust     I   Absolute extremum adjustment value\n   step       I   Step size in seconds for finding angular separation\n                  events\n   nintvls    I   Workspace window interval count\n   cnfine    I-O  SPICE window to which the search is restricted\n   result     O   SPICE window containing results\n\n-Detailed_Input\n\n   targ1       the string naming the first body of interest. You can\n               also supply the integer ID code for the object as an\n               integer string.  For example both 'MOON' and '301'\n               are legitimate strings that indicate the moon is the\n               target body.\n\n   shape1      the string naming the geometric model used to represent\n               the shape of the targ1 body. Models supported by this routine:\n\n                 'ELLIPSOID'     Use a triaxial ellipsoid model,\n                                 with radius values provided by the\n                                 kernel pool. A kernel variable\n                                 having a name of the form\n\n                                    'BODYnnn_RADII'\n\n                                 where nnn represents the NAIF\n                                 integer code associated with the\n                                 body, must be present in the kernel\n                                 pool. This variable must be\n                                 associated with three numeric\n                                 values giving the lengths of the\n                                 ellipsoid's X, Y, and Z semi-axes.\n\n                                 *This option not yet implemented.*\n\n                 'SPHERE'        Treat the body as a sphere with radius\n                                 equal to the maximum value of\n                                 BODYnnn_RADII\n\n                 'POINT'         Treat the body as a point;\n                                 radius has value zero.\n\n               The shape1 string lacks sensitivity to case, leading\n               and trailing blanks.\n\n   frame1      the string naming the body-fixed reference frame\n               corresponding to targ1.\n\n   targ2       the string naming the second body of interest. You can\n               also supply the integer ID code for the object as an\n               integer string.  For example both 'MOON' and '301'\n               are legitimate strings that indicate the moon is the\n               target body.\n\n   shape2      the string naming the geometric model used to represent\n               the shape of the targ2. Models supported by this routine:\n\n                 'ELLIPSOID'     Use a triaxial ellipsoid model,\n                                 with radius values provided by the\n                                 kernel pool. A kernel variable\n                                 having a name of the form\n\n                                    'BODYnnn_RADII'\n\n                                 where nnn represents the NAIF\n                                 integer code associated with the\n                                 body, must be present in the kernel\n                                 pool. This variable must be\n                                 associated with three numeric\n                                 values giving the lengths of the\n                                 ellipsoid's X, Y, and Z semi-axes.\n\n                 'SPHERE'        Treat the body as a sphere with radius\n                                 equal to the maximum value of\n                                 BODYnnn_RADII\n\n                 'POINT'         Treat the body as a single point;\n                                 radius has value zero.\n\n               The shape2 string lacks sensitivity to case, leading\n               and trailing blanks.\n\n   frame2      the string naming the body-fixed reference frame\n               corresponding to targ2.\n\n   abcorr      the string indicating the aberration corrections to apply\n               to the observer-target position vector to account for\n               one-way light time and stellar aberration.\n\n               This routine accepts the same aberration corrections as does\n               the SPICE routine SPKEZR. See the header of SPKEZR for a\n               detailed description of the aberration correction options.\n               For convenience, the options are listed below:\n\n                  'NONE'     Apply no correction.\n\n                  'LT'       \"Reception\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  'LT+S'     \"Reception\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  'CN'       \"Reception\" case:  converged\n                             Newtonian light time correction.\n\n                  'CN+S'     \"Reception\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n                  'XLT'      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  'XLT+S'    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  'XCN'      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  'XCN+S'    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n               The abcorr string lacks sensitivity to case, leading\n               and trailing blanks.\n\n   obsrvr      the string naming the observing body. Optionally, you\n               may supply the ID code of the object as an integer\n               string. For example, both 'EARTH' and '399' are\n               legitimate strings to supply to indicate the\n               observer is Earth.\n\n   relate      the string identifying the relational operator used to\n               define a constraint on the angular separation. The result\n               window found by this routine indicates the time intervals\n               where the constraint is satisfied. Supported values of\n               relate and corresponding meanings are shown below:\n\n                  '>'      Separation is greater than the reference\n                           value refval.\n\n                  '='      Separation is equal to the reference\n                           value refval.\n\n                  '<'      Separation is less than the reference\n                           value refval.\n\n                 'ABSMAX'  Separation is at an absolute maximum.\n\n                 'ABSMIN'  Separation is at an absolute  minimum.\n\n                 'LOCMAX'  Separation is at a local maximum.\n\n                 'LOCMIN'  Separation is at a local minimum.\n\n              The caller may indicate that the region of interest\n              is the set of time intervals where the quantity is\n              within a specified angular separation of an absolute extremum.\n              The argument adjust (described below) is used to\n              specify this angular separation.\n\n              Local extrema are considered to exist only in the\n              interiors of the intervals comprising the confinement\n              window:  a local extremum cannot exist at a boundary\n              point of the confinement window.\n\n              The relate string lacks sensitivity to case, leading\n              and trailing blanks.\n\n   refval     the double precision reference value used together with\n              relate argument to define an equality or inequality to be\n              satisfied by the angular separation between the specified target\n              and observer. See the discussion of relate above for\n              further information.\n\n              The units of refval are radians.\n\n   adjust     a double precision value used to modify searches for\n              absolute extrema: when relate is set to ABSMAX or ABSMIN and\n              adjust is set to a positive value, GFSEP finds times when the\n              angular separation between the bodies is within adjust radians\n              of the specified extreme value.\n\n              For relate set to ABSMAX, the result window contains\n              time intervals when the angular separation has\n              values between ABSMAX - adjust and ABSMAX.\n\n              For relate set to ABSMIN, the result window contains\n              time intervals when the angular separation has\n              values between ABSMIN and ABSMIN + adjust.\n\n              adjust is not used for searches for local extrema,\n              equality or inequality conditions.\n\n   step       a double precision value defining the step size to use in\n              the search. step must be short enough for a search using step\n              to locate the time intervals where the specified\n              angular separation function is monotone increasing or\n              decreasing. However, step must not be *too* short, or\n              the search will take an unreasonable amount of time.\n\n              The choice of step affects the completeness but not\n              the precision of solutions found by this routine; the\n              precision is controlled by the convergence tolerance.\n              See the discussion of the parameter SPICE_GF_CNVTOL for\n              details.\n\n              'step' has units of TDB seconds.\n\n   nintvls    an integer value specifying the number of intervals in the\n              the internal workspace array used by this routine. 'nintvls'\n              should be at least as large as the number of intervals\n              within the search region on which the specified observer-target\n              vector coordinate function is monotone increasing or decreasing.\n              It does no harm to pick a value of 'nintvls' larger than the\n              minimum required to execute the specified search, but if chosen\n              too small, the search will fail.\n\n   cnfine     a double precision SPICE window that confines the time\n              period over which the specified search is conducted.\n              cnfine may consist of a single interval or a collection\n              of intervals.\n\n              In some cases the confinement window can be used to\n              greatly reduce the time period that must be searched\n              for the desired solution. See the Particulars section\n              below for further discussion.\n\n              See the Examples section below for a code example\n              that shows how to create a confinement window.\n\n-Detailed_Output\n\n   cnfine     is the input confinement window, updated if necessary\n              so the control area of its data array indicates the\n              window's size and cardinality. The window data are\n              unchanged.\n\n   result     the SPICE window of intervals, contained within the\n              confinement window cnfine, on which the specified\n              constraint is satisfied.\n\n              If result is non-empty on input, its contents\n              will be discarded before gfsep_c conducts its\n              search.\n\n              result must be declared and initialized with sufficient\n              size to capture the full set of time intervals\n              within the search region on which the specified constraint\n              is satisfied.\n\n              If the search is for local extrema, or for absolute\n              extrema with adjust set to zero, then normally each\n              interval of result will be a singleton: the left and\n              right endpoints of each interval will be identical.\n\n              If no times within the confinement window satisfy the\n              constraint, result will be returned with a\n              cardinality of zero.\n\n");

/* void gfsntc_c ( ConstSpiceChar * target,ConstSpiceChar * fixref,
ConstSpiceChar * method,ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,
ConstSpiceChar * dref,ConstSpiceDouble dvec [3],ConstSpiceChar * crdsys,
ConstSpiceChar * coord,ConstSpiceChar * relate,SpiceDouble refval,
SpiceDouble adjust,SpiceDouble step,SpiceInt nintvls,SpiceCell * cnfine,
SpiceCell * result ); */
static PyObject * spice_gfsntc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * target;
  char * fixref;
  char * method;
  char * abcorr;
  char * obsrvr;
  char * dref;
  double dvec[3];
  char * crdsys;
  char * coord;
  char * relate;
  double refval;
  double adjust;
  double step;
  int nintvls;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssssss(ddd)sssdddi", &target, &fixref, &method, &abcorr, &obsrvr, &dref, &dvec[0], &dvec[1], &dvec[2], &crdsys, &coord, &relate, &refval, &adjust, &step, &nintvls));
  gfsntc_c(target, fixref, method, abcorr, obsrvr, dref, dvec, crdsys, coord, relate, refval, adjust, step, nintvls, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gfsntc_doc, "-Abstract\n\n     Determine time intervals for which a coordinate of an\n     surface intercept position vector satisfies a numerical constraint.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   SPICE_GF_CNVTOL\n              P   Convergence tolerance\n   target     I   Name of the target body\n   fixref     I   Body fixed frame associated with 'target'\n   method     I   Name of method type for surface intercept calculation\n   abcorr     I   Aberration correction flag\n   obsrvr     I   Name of the observing body\n   dref       I   Reference frame of direction vector 'dvec'\n   dvec       I   Pointing direction vector from 'obsrvr'\n   crdsys     I   Name of the coordinate system containing COORD\n   coord      I   Name of the coordinate of interest\n   relate     I   Operator that either looks for an extreme value\n                  (max, min, local, absolute) or compares the\n                  coordinate value and refval\n   refval     I   Reference value\n   adjust     I   Adjustment value for absolute extrema searches\n   step       I   Step size used for locating extrema and roots\n   nintvls    I   Workspace window interval count\n   cnfine    I-O  SPICE window to which the search is restricted\n   result     O   SPICE window containing results\n\n-Detailed_Input\n\n   target     the string name of a target body.  Optionally, you may\n              supply the integer ID code for the object as an\n              integer string.  For example both 'MOON' and '301'\n              are legitimate strings that indicate the moon is the\n              target body.\n\n              On calling gfsntc_c, the kernel pool must contain the\n              radii data corresponding to 'target'.\n\n   fixref     the string name of the body-fixed, body-centered\n              reference frame associated with the target body target.\n\n              The SPICE frame subsystem must recognize the 'fixref' name.\n\n   method     the string name of the method to use for the surface intercept\n              calculation. The accepted values for method:\n\n                 'Ellipsoid'        The intercept computation uses\n                                    a triaxial ellipsoid to model\n                                    the surface of the target body.\n                                    The ellipsoid's radii must be\n                                    available in the kernel pool.\n\n              The method string lacks sensitivity to case, and to leading\n              and trailing blanks.\n\n   abcorr     the string description of the aberration corrections to apply\n              to the state evaluations to account for one-way light time\n              and stellar aberration.\n\n              This routine accepts the same aberration corrections as does\n              the SPICE routine SPKEZR. See the header of SPKEZR for a\n              detailed description of the aberration correction options.\n              For convenience, the options are listed below:\n\n                  'NONE'     Apply no correction.\n\n                  'LT'       \"Reception\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  'LT+S'     \"Reception\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  'CN'       \"Reception\" case:  converged\n                             Newtonian light time correction.\n\n                  'CN+S'     \"Reception\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n                  'XLT'      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  'XLT+S'    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  'XCN'      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  'XCN+S'    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n              The abcorr string lacks sensitivity to case, and to embedded,\n              leading and trailing blanks.\n\n     obsrvr   the string naming the observing body. Optionally, you\n              may supply the ID code of the object as an integer\n              string. For example, both 'EARTH' and '399' are\n              legitimate strings to supply to indicate the\n              observer is Earth.\n\n     dref     the string name of the reference frame corresponding to dvec.\n\n              The dref string lacks sensitivity to case, leading\n              and trailing blanks.\n\n     dvec     the pointing or boresight vector from the observer. The\n              intercept of this vector and target is the event of interest.\n\n     crdsys   the string name of the coordinate system for which the\n              coordinate of interest is a member.\n\n     coord    the string name of the coordinate of interest in crdsys.\n\n              The supported coordinate systems and coordinate names are:\n\n              Coordinate System (CRDSYS)    Coordinates (COORD)      Range\n\n                 'RECTANGULAR'                  'X'\n                                                'Y'\n                                                'Z'\n\n                 'LATITUDINAL'                  'RADIUS'\n                                                'LONGITUDE'        (-Pi,Pi]\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n\n                 'RA/DEC'                       'RANGE'\n                                                'RIGHT ASCENSION'  [0,2Pi)\n                                                'DECLINATION'      [-Pi/2,Pi/2]\n\n                 'SPHERICAL'                    'RADIUS'\n                                                'COLATITUDE'       [0,Pi]\n                                                'LONGITUDE'        (-Pi,Pi]\n\n                 'CYLINDRICAL'                  'RADIUS'\n                                                'LONGITUDE'        [0,2Pi)\n                                                'Z'\n\n                 'GEODETIC'                     'LONGITUDE'        (-Pi,Pi]\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n                                                'ALTITUDE'\n\n                 'PLANETOGRAPHIC'               'LONGITUDE'        [0,2Pi)\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n                                                'ALTITUDE'\n\n                  The ALTITUDE coordinates have a constant value\n                  of zero +/- roundoff for ellipsoid targets.\n\n                  Limit searches for coordinate events in the GEODETIC and\n                  PLANETOGRAPHIC coordinate systems to TARGET bodies with\n                  axial symmetry in the equatorial plane, i.e. equality\n                  of the body X and Y radii (oblate or prolate spheroids).\n\n     relate    the string or character describing the relational operator\n               used to define a constraint on the selected coordinate of the\n               surface intercept vector. The result window found by this routine\n               indicates the time intervals where the constraint is satisfied.\n               Supported values of relate and corresponding meanings are\n               shown below:\n\n                  '>'      Separation is greater than the reference\n                           value refval.\n\n                  '='      Separation is equal to the reference\n                           value refval.\n\n                  '<'      Separation is less than the reference\n                           value refval.\n\n                 'ABSMAX'  Separation is at an absolute maximum.\n\n                 'ABSMIN'  Separation is at an absolute  minimum.\n\n                 'LOCMAX'  Separation is at a local maximum.\n\n                 'LOCMIN'  Separation is at a local minimum.\n\n              The caller may indicate that the region of interest\n              is the set of time intervals where the quantity is\n              within a specified measure of an absolute extremum.\n              The argument ADJUST (described below) is used to\n              specify this measure.\n\n              Local extrema are considered to exist only in the\n              interiors of the intervals comprising the confinement\n              window:  a local extremum cannot exist at a boundary\n              point of the confinement window.\n\n              The relate string lacks sensitivity to case, leading\n              and trailing blanks.\n\n   refval     the double precision reference value used together with\n              relate argument to define an equality or inequality to\n              satisfy by the selected coordinate of the surface intercept\n              vector. See the discussion of relate above for\n              further information.\n\n              The units of refval correspond to the type as defined\n              by coord, radians for angular measures, kilometers for\n              distance measures.\n\n   adjust     a double precision value used to modify searches for\n              absolute extrema: when relate is set to ABSMAX or ABSMIN and\n              adjust is set to a positive value, gfsntc_c finds times when the\n              position vector coordinate is within adjust radians/kilometers\n              of the specified extreme value.\n\n              For relate set to ABSMAX, the result window contains\n              time intervals when the position vector coordinate has\n              values between ABSMAX - adjust and ABSMAX.\n\n              For relate set to ABSMIN, the result window contains\n              time intervals when the position vector coordinate has\n              values between ABSMIN and ABSMIN + adjust.\n\n              adjust is not used for searches for local extrema,\n              equality or inequality conditions.\n\n   step       the double precision time step size to use in the search.\n\n              Selection of the time step for surface intercept geometry\n              requires consideration of the mechanics of a surface intercept\n              event. In most cases, two distinct searches will be needed,\n              one to determine the windows when the boresight vector\n              intercepts the surface and then the search based on the user\n              defined constraints within those windows. The boresight of\n              nadir pointing instrument may continually intercept a body, but\n              an instrument scanning across a disc will have configurations\n              when the boresight does not intercept the body.\n\n              The step size must be smaller than the shortest interval\n              within the confinement window over which the intercept exists\n              and also smaller than the shortest interval over which the\n              intercept does not exist.\n\n              For coordinates other than LONGITUDE and RIGHT ASCENSION,\n              the step size must be shorter than the shortest interval,\n              within the confinement window, over which the coordinate\n              is monotone increasing or decreasing.\n\n              For LONGITUDE and RIGHT ASCENSION, the step size must\n              be shorter than the shortest interval, within the\n              confinement window, over which either the sin or cos\n              of the coordinate is monotone increasing or decreasing.\n\n              The choice of 'step' affects the completeness but not\n              the precision of solutions found by this routine; the\n              precision is controlled by the convergence tolerance.\n              See the discussion of the parameter SPICE_GF_CNVTOL for\n              details.\n\n              'step' has units of TDB seconds.\n\n   nintvls    an integer value specifying the number of intervals in the\n              the internal workspace array used by this routine. 'nintvls'\n              should be at least as large as the number of intervals\n              within the search region on which the specified intercept\n              vector coordinate function is monotone increasing or decreasing.\n              It does no harm to pick a value of 'nintvls' larger than the\n              minimum required to execute the specified search, but if chosen\n              too small, the search will fail.\n\n   cnfine     a double precision SPICE window that confines the time\n              period over which the specified search is conducted.\n              cnfine may consist of a single interval or a collection\n              of intervals.\n\n              In some cases the confinement window can be used to\n              greatly reduce the time period that must be searched\n              for the desired solution. See the Particulars section\n              below for further discussion.\n\n              See the Examples section below for a code example\n              that shows how to create a confinement window.\n\n-Detailed_Output\n\n   cnfine     is the input confinement window, updated if necessary\n              so the control area of its data array indicates the\n              window's size and cardinality. The window data are\n              unchanged.\n\n   result     the SPICE window of intervals, contained within the\n              confinement window cnfine, on which the specified\n              constraint is satisfied.\n\n              If result is non-empty on input, its contents\n              will be discarded before gfsntc_c conducts its\n              search.\n\n              result must be declared and initialized with sufficient\n              size to capture the full set of time intervals\n              within the search region on which the specified constraint\n              is satisfied.\n\n              If the search is for local extrema, or for absolute\n              extrema with adjust set to zero, then normally each\n              interval of result will be a singleton: the left and\n              right endpoints of each interval will be identical.\n\n              If no times within the confinement window satisfy the\n              constraint, result will be returned with a\n              cardinality of zero.\n\n");

/* void gfsstp_c ( SpiceDouble step ); */
static PyObject * spice_gfsstp(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double step;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &step));
  gfsstp_c(step);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(gfsstp_doc, "-Abstract\n\n   Set the step size to be returned by gfstep_c.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   step       I   Time step to take.\n\n-Detailed_Input\n\n   step      is the output step size to be returned by the next call\n             to gfstep_c. Units are TDB seconds.\n\n             `step' is used in the GF search root-bracketing process.\n             `step' indicates how far to advance the gfstep_c input\n             argument `time' so that `time' and time+step may bracket a\n             state transition and definitely do not bracket more than\n             one state transition.\n\n-Detailed_Output\n\n   None.\n\n");

/* void gfstep_c ( SpiceDouble time,SpiceDouble * step ); */
static PyObject * spice_gfstep(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble step;
  /* variables for inputs */
  double time;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &time));
  gfstep_c(time, &step);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, step);
  return returnVal;
}
PyDoc_STRVAR(gfstep_doc, "-Abstract\n\n   Return the time step set by the most recent call to gfsstp_c.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   time       I   Ignored ET value.\n   step       O   Time step to take.\n\n-Detailed_Input\n\n   time     is an ignored double precision number. This argument\n            is present so the argument list of this routine is\n            compatible with the GF step size routine argument list\n            specification.\n\n            When this routine is called from within the GF\n            root-finding system, either the initial ET value of the\n            current interval of the confinement window, or the\n            value resulting from the last search step, is passed in\n            via the `time' argument.\n\n\n\n-Detailed_Output\n\n   step     is the output step size. This is the value set by the\n            most recent call to gfsstp_c. Units are TDB seconds.\n\n            `step' is used in the GF search root-bracketing process.\n            `step' indicates how far to advance `time' so that `time' and\n            time+step may bracket a state transition and definitely\n            do not bracket more than one state transition.\n\n");

/* void gfsubc_c ( ConstSpiceChar * target,ConstSpiceChar * fixref,
ConstSpiceChar * method,ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,
ConstSpiceChar * crdsys,ConstSpiceChar * coord,ConstSpiceChar * relate,
SpiceDouble refval,SpiceDouble adjust,SpiceDouble step,SpiceInt nintvls,
SpiceCell * cnfine,SpiceCell * result ); */
static PyObject * spice_gfsubc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * target;
  char * fixref;
  char * method;
  char * abcorr;
  char * obsrvr;
  char * crdsys;
  char * coord;
  char * relate;
  double refval;
  double adjust;
  double step;
  int nintvls;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssssssssdddi", &target, &fixref, &method, &abcorr, &obsrvr, &crdsys, &coord, &relate, &refval, &adjust, &step, &nintvls));
  gfsubc_c(target, fixref, method, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step, nintvls, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gfsubc_doc, "-Abstract\n\n   Determine time intervals for which a coordinate of an\n   subpoint position vector satisfies a numerical constraint.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   SPICE_GF_CNVTOL\n              P   Convergence tolerance.\n   target     I   Name of the target body\n   fixref     I   Body fixed frame associated with 'target'\n   method     I   Name of method type for subpoint calculation\n   abcorr     I   Aberration correction flag\n   obsrvr     I   Name of the observing body\n   crdsys     I   Name of the coordinate system containing 'coord'\n   coord      I   Name of the coordinate of interest\n   relate     I   Operator that either looks for an extreme value\n                  (max, min, local, absolute) or compares the\n                  coordinate value and refval\n   refval     I   Reference value\n   adjust     I   Adjustment value for absolute extrema searches\n   step       I   Step size used for locating extrema and roots\n   nintvls    I   Workspace window interval count\n   cnfine    I-O  SPICE window to which the search is restricted\n   result     O   SPICE window containing results\n\n-Detailed_Input\n\n   target     the string name of a target body.  Optionally, you may\n              supply the integer ID code for the object as an\n              integer string.  For example both 'MOON' and '301'\n              are legitimate strings that indicate the moon is the\n              target body.\n\n              The target and observer define a position vector\n              that points from the observer to the target.\n\n   fixref     the string name of the body-fixed, body-centered\n              reference frame associated with the target body target.\n\n              The SPICE frame subsystem must recognize the 'fixref' name.\n\n   method     the string name of the method to use for the subpoint\n              calculation. The accepted values for method:\n\n                 'Near point: ellipsoid'   The sub-observer point\n                                           computation uses a\n                                           triaxial ellipsoid to\n                                           model the surface of the\n                                           target body. The\n                                           sub-observer point is\n                                           defined as the nearest\n                                           point on the target\n                                           relative to the\n                                           observer.\n\n                 'Intercept: ellipsoid'    The sub-observer point\n                                           computation uses a\n                                           triaxial ellipsoid to\n                                           model the surface of the\n                                           target body. The\n                                           sub-observer point is\n                                           defined as the target\n                                           surface intercept of the\n                                           line containing the\n                                           observer and the\n                                           target's center.\n\n              The method string lacks sensitivity to case, embedded, leading\n              and trailing blanks.\n\n   abcorr     the string description of the aberration corrections to apply\n              to the state evaluations to account for one-way light time\n              and stellar aberration.\n\n              This routine accepts the same aberration corrections as does\n              the SPICE routine SPKEZR. See the header of SPKEZR for a\n              detailed description of the aberration correction options.\n              For convenience, the options are listed below:\n\n                  'NONE'     Apply no correction.\n\n                  'LT'       \"Reception\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  'LT+S'     \"Reception\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  'CN'       \"Reception\" case:  converged\n                             Newtonian light time correction.\n\n                  'CN+S'     \"Reception\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n                  'XLT'      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation.\n\n                  'XLT+S'    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation.\n\n                  'XCN'      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  'XCN+S'    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n              The abcorr string lacks sensitivity to case, and to embedded,\n              leading and trailing blanks.\n\n     obsrvr   the string naming the observing body. Optionally, you\n              may supply the ID code of the object as an integer\n              string. For example, both 'EARTH' and '399' are\n              legitimate strings to supply to indicate the\n              observer is Earth.\n\n     crdsys   the string name of the coordinate system for which the\n              coordinate of interest is a member.\n\n     coord    the string name of the coordinate of interest in crdsys.\n\n              The supported coordinate systems and coordinate names are:\n\n              The supported coordinate systems and coordinate names are:\n\n              Coordinate System (CRDSYS)    Coordinates (COORD)      Range\n\n                 'RECTANGULAR'                  'X'\n                                                'Y'\n                                                'Z'\n\n                 'LATITUDINAL'                  'RADIUS'\n                                                'LONGITUDE'        (-Pi,Pi]\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n\n                 'RA/DEC'                       'RANGE'\n                                                'RIGHT ASCENSION'  [0,2Pi)\n                                                'DECLINATION'      [-Pi/2,Pi/2]\n\n                 'SPHERICAL'                    'RADIUS'\n                                                'COLATITUDE'       [0,Pi]\n                                                'LONGITUDE'        (-Pi,Pi]\n\n                 'CYLINDRICAL'                  'RADIUS'\n                                                'LONGITUDE'        [0,2Pi)\n                                                'Z'\n\n                 'GEODETIC'                     'LONGITUDE'        (-Pi,Pi]\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n                                                'ALTITUDE'\n\n                 'PLANETOGRAPHIC'               'LONGITUDE'        [0,2Pi)\n                                                'LATITUDE'         [-Pi/2,Pi/2]\n                                                'ALTITUDE'\n\n                  The ALTITUDE coordinates have a constant value\n                  of zero +/- roundoff for ellipsoid targets.\n\n                  Limit searches for coordinate events in the GEODETIC and\n                  PLANETOGRAPHIC coordinate systems to TARGET bodies with\n                  axial symmetry in the equatorial plane, i.e. equality\n                  of the body X and Y radii (oblate or prolate spheroids).\n\n     relate    the string or character describing the relational operator\n               used to define a constraint on the selected coordinate of the\n               subpoint vector. The result window found by this routine\n               indicates the time intervals where the constraint is satisfied.\n               Supported values of relate and corresponding meanings are\n               shown below:\n\n                  '>'      Separation is greater than the reference\n                           value refval.\n\n                  '='      Separation is equal to the reference\n                           value refval.\n\n                  '<'      Separation is less than the reference\n                           value refval.\n\n                 'ABSMAX'  Separation is at an absolute maximum.\n\n                 'ABSMIN'  Separation is at an absolute  minimum.\n\n                 'LOCMAX'  Separation is at a local maximum.\n\n                 'LOCMIN'  Separation is at a local minimum.\n\n              The caller may indicate that the region of interest\n              is the set of time intervals where the quantity is\n              within a specified measure of an absolute extremum.\n              The argument ADJUST (described below) is used to\n              specify this measure.\n\n              Local extrema are considered to exist only in the\n              interiors of the intervals comprising the confinement\n              window:  a local extremum cannot exist at a boundary\n              point of the confinement window.\n\n              The relate string lacks sensitivity to case, leading\n              and trailing blanks.\n\n   refval     the double precision reference value used together with\n              relate argument to define an equality or inequality to\n              satisfy by the selected coordinate of the subpoint\n              vector. See the discussion of relate above for\n              further information.\n\n              The units of refval correspond to the type as defined\n              by coord, radians for angular measures, kilometers for\n              distance measures.\n\n   adjust     a double precision value used to modify searches for\n              absolute extrema: when 'relate' is set to ABSMAX or ABSMIN and\n              'adjust' is set to a positive value, gfsubc_c finds times\n              when the position vector coordinate is within adjust\n              radians/kilometers of the specified extreme value.\n\n              For 'relate' set to ABSMAX, the result window contains\n              time intervals when the position vector coordinate has\n              values between ABSMAX - adjust and ABSMAX.\n\n              For 'relate' set to ABSMIN, the result window contains\n              time intervals when the position vector coordinate has\n              values between ABSMIN and ABSMIN + adjust.\n\n              'adjust' is not used for searches for local extrema,\n              equality or inequality conditions.\n\n   step       the double precision time step size to use in the search.\n              step must be short enough for a search using this step\n              size to locate the time intervals where coordinate function\n              of the subpoint vector is monotone increasing or\n              decreasing. However, step must not be *too* short, or\n              the search will take an unreasonable amount of time.\n\n              The choice of step affects the completeness but not\n              the precision of solutions found by this routine; the\n              precision is controlled by the convergence tolerance.\n\n              step has units of TDB seconds.\n\n   nintvls    an integer value specifying the number of intervals in the\n              the internal workspace array used by this routine. 'nintvls'\n              should be at least as large as the number of intervals\n              within the search region on which the specified observer-target\n              vector coordinate function is monotone increasing or decreasing.\n              It does no harm to pick a value of 'nintvls' larger than the\n              minimum required to execute the specified search, but if chosen\n              too small, the search will fail.\n\n   cnfine     a double precision SPICE window that confines the time\n              period over which the specified search is conducted.\n              cnfine may consist of a single interval or a collection\n              of intervals.\n\n              In some cases the confinement window can be used to\n              greatly reduce the time period that must be searched\n              for the desired solution. See the Particulars section\n              below for further discussion.\n\n              See the Examples section below for a code example\n              that shows how to create a confinement window.\n\n-Detailed_Output\n\n   cnfine     is the input confinement window, updated if necessary\n              so the control area of its data array indicates the\n              window's size and cardinality. The window data are\n              unchanged.\n\n   result     the SPICE window of intervals, contained within the\n              confinement window cnfine, on which the specified\n              constraint is satisfied.\n\n              If result is non-empty on input, its contents\n              will be discarded before gfsubc_c conducts its\n              search.\n\n              result must be declared and initialized with sufficient\n              size to capture the full set of time intervals\n              within the search region on which the specified constraint\n              is satisfied.\n\n              If the search is for local extrema, or for absolute\n              extrema with adjust set to zero, then normally each\n              interval of result will be a singleton: the left and\n              right endpoints of each interval will be identical.\n\n              If no times within the confinement window satisfy the\n              constraint, result will be returned with a\n              cardinality of zero.\n\n");

/* void gftfov_c ( ConstSpiceChar * inst,ConstSpiceChar * target,
ConstSpiceChar * tshape,ConstSpiceChar * tframe,ConstSpiceChar * abcorr,
ConstSpiceChar * obsrvr,SpiceDouble step,SpiceCell * cnfine,
SpiceCell * result ); */
static PyObject * spice_gftfov(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cnfine;
  SpiceCell result;
  /* variables for inputs */
  char * inst;
  char * target;
  char * tshape;
  char * tframe;
  char * abcorr;
  char * obsrvr;
  double step;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssssssd", &inst, &target, &tshape, &tframe, &abcorr, &obsrvr, &step));
  gftfov_c(inst, target, tshape, tframe, abcorr, obsrvr, step, &cnfine, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cnfine), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(gftfov_doc, "-Abstract\n\n   Determine time intervals when a specified ephemeris object\n   intersects the space bounded by the field-of-view (FOV) of a\n   specified instrument.\n\n-Brief_I/O\n\n   VARIABLE         I/O  DESCRIPTION\n   ---------------  ---  ------------------------------------------------\n   SPICE_GF_MARGIN   P   Minimum complement of FOV cone angle.\n   SPICE_GF_CNVTOL   P   Convergence tolerance.\n   SPICE_GF_MAXVRT   P   Maximum number of FOV boundary vertices.\n   inst              I   Name of the instrument.\n   target            I   Name of the target body.\n   tshape            I   Type of shape model used for target body.\n   tframe            I   Body-fixed, body-centered frame for target body.\n   abcorr            I   Aberration correction flag.\n   obsrvr            I   Name of the observing body.\n   step              I   Step size in seconds for finding FOV events.\n   cnfine           I-O  SPICE window to which the search is restricted.\n   result            O   SPICE window containing results.\n\n\n-Detailed_Input\n\n   inst       indicates the name of an instrument, such as a\n              spacecraft-mounted framing camera, the field of view\n              (FOV) of which is to be used for a target intersection\n              search: times when the specified target intersects the\n              region of space corresponding to the FOV are sought.\n\n              The position of the instrument designated by `inst' is\n              considered to coincide with that of the ephemeris\n              object designated by the input argument `obsrvr' (see\n              description below).\n\n              `inst' must have a corresponding NAIF ID and a frame\n              defined, as is normally done in a frame kernel. It\n              must also have an associated reference frame and a FOV\n              shape, boresight and boundary vertices (or reference\n              vector and reference angles) defined, as is usually\n              done in an instrument kernel.\n\n              See the header of the CSPICE routine getfov_c for a\n              description of the required parameters associated with\n              an instrument.\n\n\n   target     is the name of the target body, the appearances of\n              which in the specified instrument's field of view are\n              sought. The body must be an ephemeris object.\n\n              Optionally, you may supply the integer NAIF ID code\n              for the body as a string. For example both \"MOON\" and\n              \"301\" are legitimate strings that designate the Moon.\n\n              Case and leading or trailing blanks are not\n              significant in the string `target'.\n\n\n   tshape     is a string indicating the geometric model used to\n              represent the shape of the target body. The supported\n              options are:\n\n                 \"ELLIPSOID\"     Use a triaxial ellipsoid model,\n                                 with radius values provided via the\n                                 kernel pool. A kernel variable\n                                 having a name of the form\n\n                                    \"BODYnnn_RADII\"\n\n                                 where nnn represents the NAIF\n                                 integer code associated with the\n                                 body, must be present in the kernel\n                                 pool. This variable must be\n                                 associated with three numeric\n                                 values giving the lengths of the\n                                 ellipsoid's X, Y, and Z semi-axes.\n\n                 \"POINT\"         Treat the body as a single point.\n\n              Case and leading or trailing blanks are not\n              significant in the string `tshape'.\n\n\n   tframe     is the name of the body-fixed, body-centered reference\n              frame associated with the target body. Examples of\n              such names are \"IAU_SATURN\" (for Saturn) and \"ITRF93\"\n              (for the Earth).\n\n              If the target body is modeled as a point, `tframe'\n              is ignored and should be left blank.\n\n              Case and leading or trailing blanks bracketing a\n              non-blank frame name are not significant in the string\n              `tframe'.\n\n\n   abcorr     indicates the aberration corrections to be applied\n              when computing the target's position and orientation.\n\n              For remote sensing applications, where the apparent\n              position and orientation of the target seen by the\n              observer are desired, normally either of the\n              corrections\n\n                 \"LT+S\"\n                 \"CN+S\"\n\n              should be used. These and the other supported options\n              are described below.\n\n              Supported aberration correction options for\n              observation (the case where radiation is received by\n              observer at ET) are:\n\n                 \"NONE\"         No correction.\n                 \"LT\"           Light time only\n                 \"LT+S\"         Light time and stellar aberration.\n                 \"CN\"           Converged Newtonian (CN) light time.\n                 \"CN+S\"         CN light time and stellar aberration.\n\n              Supported aberration correction options for\n              transmission (the case where radiation is emitted from\n              observer at ET) are:\n\n                 \"XLT\"          Light time only.\n                 \"XLT+S\"        Light time and stellar aberration.\n                 \"XCN\"          Converged Newtonian (CN) light time.\n                 \"XCN+S\"        CN light time and stellar aberration.\n\n              For detailed information, see the GF Required Reading,\n              gf.req.\n\n              Case, leading and trailing blanks are not significant\n              in the string `abcorr'.\n\n\n   obsrvr     is the name of the body from which the target is\n              observed. The instrument designated by `inst' is treated\n              as if it were co-located with the observer.\n\n              Optionally, you may supply the integer NAIF ID code\n              for the body as a string.\n\n              Case and leading or trailing blanks are not\n              significant in the string `obsrvr'.\n\n\n   step       is the step size to be used in the search. `step' must\n              be shorter than any interval, within the confinement\n              window, over which the specified condition is met. In\n              other words, `step' must be shorter than the shortest\n              visibility event that the user wishes to detect. `step'\n              also must be shorter than the minimum duration\n              separating any two visibility events. However, `step'\n              must not be *too* short, or the search will take an\n              unreasonable amount of time.\n\n              The choice of `step' affects the completeness but not\n              the precision of solutions found by this routine; the\n              precision is controlled by the convergence tolerance.\n              See the discussion of the parameter SPICE_GF_CNVTOL for\n              details.\n\n              `step' has units of seconds.\n\n\n   cnfine     is a SPICE window that confines the time period over\n              which the specified search is conducted. `cnfine' may\n              consist of a single interval or a collection of\n              intervals.\n\n              The endpoints of the time intervals comprising `cnfine'\n              are interpreted as seconds past J2000 TDB.\n\n              See the Examples section below for a code example\n              that shows how to create a confinement window.\n\n-Detailed_Output\n\n   cnfine     is the input confinement window, updated if necessary\n              so the control area of its data array indicates the\n              window's size and cardinality. The window data are\n              unchanged.\n\n\n   result     is a SPICE window representing the set of time\n              intervals, within the confinement period, when the\n              target body is visible; that is, when the target body\n              intersects the space bounded by the specified\n              instrument's field of view.\n\n              The endpoints of the time intervals comprising `result'\n              are interpreted as seconds past J2000 TDB.\n\n              If `result' is non-empty on input, its contents\n              will be discarded before gftfov_c conducts its\n              search.\n\n");

/* void gipool_c ( ConstSpiceChar * name,SpiceInt start,SpiceInt room,
SpiceInt * n,SpiceInt * ivals,SpiceBoolean * found ); */
static PyObject * spice_gipool(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt n;
  SpiceInt ivals;
  SpiceBoolean found;
  /* variables for inputs */
  char * name;
  int start;
  int room;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sii", &name, &start, &room));
  gipool_c(name, start, room, &n, &ivals, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, n, ivals);
  return returnVal;
  }

}
PyDoc_STRVAR(gipool_doc, "-Abstract\n\n   Return the integer value of a kernel variable from the\n   kernel pool.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   Name of the variable whose value is to be returned.\n   start      I   Which component to start retrieving for name\n   room       I   The largest number of values to return.\n   n          O   Number of values returned for name.\n   ivals      O   Values associated with name.\n   found      O   True if variable is in pool.\n\n-Detailed_Input\n\n   name       is the name of the variable whose values are to be\n              returned. If the variable is not in the pool with\n              numeric type, found will be SPICEFALSE.\n\n   start      is the index of the first component of name to return.\n              The index follows the C convention of being 0 based.\n              If start is less than 0, it will be treated as 0.  If\n              start is greater than the total number of components\n              available for name, no values will be returned (n will\n              be set to zero).  However, found will still be set to\n              SPICETRUE\n\n   room       is the maximum number of components that should be\n              returned for this variable.  (Usually it is the amount\n              of room available in the array ivals). If room is\n              less than 1 the error SPICE(BADARRAYSIZE) will be\n              signaled.\n\n-Detailed_Output\n\n   n          is the number of values associated with name that\n              are returned.  It will always be less than or equal\n              to room.\n\n              If name is not in the pool with numeric type, no value\n              is given to n.\n\n   ivals      is the array of values associated with name.\n              If name is not in the pool with numeric type, no\n              values are given to the elements of ivals.\n\n   found      is SPICETRUE if the variable is in the pool and has\n              numeric type, SPICEFALSE if it is not.\n\n");

/* SpiceDouble halfpi_c ( void ); */
static PyObject * spice_halfpi(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = halfpi_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(halfpi_doc, "-Abstract\n\n   Return half the value of pi (the ratio of the circumference of\n   a circle to its diameter).\n\n-Brief_I/O\n\n   The function returns half the value of pi.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns half the value of pi (the ratio of\n   a circle's circumference to its diameter), determined by\n   the ACOS function. That is,\n\n         halfpi_c = acos ( -1.0 ) * 0.50\n\n");

/* void hx2dp_c ( ConstSpiceChar * string,SpiceInt lenout,SpiceDouble * number,
SpiceBoolean * error,SpiceChar * errmsg); */
static PyObject * spice_hx2dp(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble number;
  SpiceBoolean error;
  SpiceChar errmsg[STRING_LEN];
  /* variables for inputs */
  char * string;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &string));
  hx2dp_c(string, lenout, &number, &error, errmsg);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, number, get_py_boolean(&error), errmsg);
  return returnVal;
}
PyDoc_STRVAR(hx2dp_doc, "-Abstract\n\n   Convert a string representing a double precision number in a\n   base 16 ``scientific notation'' into its equivalent double\n   precision number.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   string     I   Hex form string to convert to double precision.\n   lenout     I   Available space for output string 'errmsg'.\n   number     O   Double precision value to be returned.\n   error      O   A logical flag which is true on error.\n   errmsg     O   A descriptive error message.\n\n-Detailed_Input\n\n   string   a character string containing a base 16 ``scientific\n            notation'' representation of a double precision number\n            which is to be converted to a double precision number,\n            e.g.:\n\n               '2A^3' = ( 2/16 + 10/( 16**2 ) ) * 16**3 = 672.0\n\n            and\n\n               '-B^1' = - ( 11/16 ) * 16**1             = -11.0\n\n            The following table describes the character set used to\n            represent the hexadecimal digits and their corresponding\n            values.\n\n            Character     Value         Character     Value\n            ---------    -------        ---------    -------\n              '0'         0.0D0           '8'         8.0D0\n              '1'         1.0D0           '9'         9.0D0\n              '2'         2.0D0         'A','a'      10.0D0\n              '3'         3.0D0         'B','b'      11.0D0\n              '4'         4.0D0         'C','c'      12.0D0\n              '5'         5.0D0         'D','d'      13.0D0\n              '6'         6.0D0         'E','e'      14.0D0\n              '7'         7.0D0         'F','f'      15.0D0\n\n            The caret, or hat, character, '^', is used to\n            distinguish the exponent.\n\n            The plus sign, '+', and the minus sign, '-', are used,\n            and they have their usual meanings.\n\n            A base 16 ``scientific notation'' character string which\n            is to be parsed by this routine should consist of a sign,\n            '+' or '-' (the plus sign is optional for nonnegative\n            numbers), followed immediately by a contiguous sequence\n            of hexadecimal digits, the exponent character, and a\n            signed hexadecimal exponent. The exponent is required,\n            but the sign is optional for a nonnegative exponent.\n\n            A number in base 16 ``scientific notation'' consists of\n            a contiguous sequence of characters with one of the\n            following formats:\n\n                (1)   h h h h  ... h ^H H  ... H\n                       1 2 3 4      n  1 2      m\n\n                (2)   +h h h h  ... h ^H H  ... H\n                        1 2 3 4      n  1 2      m\n\n                (3)   -h h h h  ... h ^H H  ... H\n                        1 2 3 4      n  1 2      m\n\n                (4)    h h h h  ... h ^+H H  ... H\n                        1 2 3 4      n   1 2      m\n\n                (5)   +h h h h  ... h ^+H H  ... H\n                        1 2 3 4      n   1 2      m\n\n                (6)   -h h h h  ... h ^+H H  ... H\n                        1 2 3 4      n   1 2      m\n\n                (7)   h h h h  ... h ^-H H  ... H\n                       1 2 3 4      n   1 2      m\n\n                (8)   +h h h h  ... h ^-H H  ... H\n                        1 2 3 4      n   1 2      m\n\n                (9)   -h h h h  ... h ^-H H  ... H\n                        1 2 3 4      n   1 2      m\n\n            where\n\n               h  and H  denote hexadecimal digits;\n                i      j\n\n               '^'         denotes exponentiation;\n\n            and\n\n               + and - have their usual interpretations.\n\n            'string' may have leading and trailing blanks, but blanks\n            embedded within the significant portion of the input\n            string are not allowed.\n\n   lenout   the maximum length of the output 'errmsg'. The value\n            defined by lenout should be one plus the value large\n            enough to hold any possible output.\n\n-Detailed_Output\n\n   number   the double precision value to be returned. The value of\n            this argument is not changed if an error occurs while\n            parsing the input string.\n\n   error    a logical flag which indicates whether an error occurred\n            while attempting to parse 'number' from the input\n            character string 'string'. 'error' will have the value\n            true if an error occurs. It will have the value\n            false otherwise.\n\n   errmsg   contains a descriptive error message if an error\n            occurs while attempting to parse the number 'number'\n            from the hexadecimal character string 'string', blank\n            otherwise.\n\n");

/* void ident_c ( SpiceDouble matrix[3][3] ); */
static PyObject * spice_ident(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble matrix[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  ident_c(matrix);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, matrix[0][0], matrix[0][1], matrix[0][2], matrix[1][0], matrix[1][1], matrix[1][2], matrix[2][0], matrix[2][1], matrix[2][2]);
  return returnVal;
}
PyDoc_STRVAR(ident_doc, "-Abstract\n\n  This routine returns the 3x3 identity matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   matrix     O   is the 3x3 identity matrix.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   matrix     is the 3x3 Identity matrix.  That is MATRIX is\n              the following\n                _                 _\n               |  1.0   0.0   0.0  |\n               |  0.0   1.0   0.0  |\n               |  0.0   0.0   1.0  |\n                -                  -\n");

/* void ilumin_c ( ConstSpiceChar * method,ConstSpiceChar * target,
SpiceDouble et,ConstSpiceChar * fixref,ConstSpiceChar * abcorr,
ConstSpiceChar * obsrvr,ConstSpiceDouble spoint [3],SpiceDouble * trgepc,
SpiceDouble srfvec [3],SpiceDouble * phase,SpiceDouble * solar,
SpiceDouble * emissn ); */
static PyObject * spice_ilumin(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble trgepc;
  SpiceDouble srfvec[3];
  SpiceDouble phase;
  SpiceDouble solar;
  SpiceDouble emissn;
  /* variables for inputs */
  char * method;
  char * target;
  double et;
  char * fixref;
  char * abcorr;
  char * obsrvr;
  double spoint[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdsss(ddd)", &method, &target, &et, &fixref, &abcorr, &obsrvr, &spoint[0], &spoint[1], &spoint[2]));
  ilumin_c(method, target, et, fixref, abcorr, obsrvr, spoint, &trgepc, srfvec, &phase, &solar, &emissn);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, trgepc, srfvec[0], srfvec[1], srfvec[2], phase, solar, emissn);
  return returnVal;
}
PyDoc_STRVAR(ilumin_doc, "-Abstract\n\n   Find the illumination angles (phase, solar incidence, and\n   emission) at a specified surface point of a target body.\n\n   This routine supersedes illum_c.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   method     I   Computation method.\n   target     I   Name of target body.\n   et         I   Epoch in ephemeris seconds past J2000 TDB.\n   fixref     I   Body-fixed, body-centered target body frame.\n   abcorr     I   Desired aberration correction.\n   obsrvr     I   Name of observing body.\n   spoint     I   Body-fixed coordinates of a target surface point.\n   trgepc     O   Target surface point epoch.\n   srfvec     O   Vector from observer to target surface point.\n   phase      O   Phase angle at the surface point.\n   solar      O   Solar incidence angle at the surface point.\n   emissn     O   Emission angle at the surface point.\n\n-Detailed_Input\n\n\n   method      is a short string providing parameters defining\n               the computation method to be used. Parameters\n               include, but are not limited to, the shape model\n               used to represent the surface of the target body.\n\n               The only choice currently supported is\n\n                  \"Ellipsoid\"        The illumination angle computation\n                                     uses a triaxial ellipsoid to model\n                                     the surface of the target body.\n                                     The ellipsoid's radii must be\n                                     available in the kernel pool.\n\n               Neither case nor white space are significant in\n               `method'. For example, the string ' eLLipsoid ' is\n               valid.\n\n\n   target      is the name of the target body. `target' is\n               case-insensitive, and leading and trailing blanks in\n               `target' are not significant. Optionally, you may supply\n               a string containing the integer ID code for the object.\n               For example both \"MOON\" and \"301\" are legitimate strings\n               that indicate the Moon is the target body.\n\n\n   et          is the epoch, specified as ephemeris seconds past J2000\n               TDB, at which the apparent illumination angles at the\n               specified surface point on the target body, as seen from\n               the observing body, are to be computed.\n\n\n   fixref      is the name of the body-fixed, body-centered reference\n               frame associated with the target body. The input surface\n               point `spoint' and the output vector `srfvec' are\n               expressed relative to this reference frame. The string\n               `fixref' is case-insensitive, and leading and trailing\n               blanks in `fixref' are not significant.\n\n\n   abcorr      is the aberration correction to be used in computing the\n               position and orientation of the target body and the\n               location of the Sun.\n\n               For remote sensing applications, where the apparent\n               illumination angles seen by the observer are desired,\n               normally either of the corrections\n\n                  \"LT+S\"\n                  \"CN+S\"\n\n               should be used. These and the other supported options\n               are described below. `abcorr' may be any of the\n               following:\n\n                  \"NONE\"     No aberration correction.\n\n\n               Let `lt' represent the one-way light time between the\n               observer and `spoint' (note: NOT between the observer\n               and the target body's center). The following values of\n               `abcorr' apply to the \"reception\" case in which photons\n               depart from `spoint' at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at `et':\n\n                  \"LT\"       Correct both the position of `spoint' as\n                             seen by the observer, and the position of\n                             the Sun as seen by the target, for light\n                             time.\n\n                  \"LT+S\"     Correct both the position of `spoint' as\n                             seen by the observer, and the position of\n                             the Sun as seen by the target, for light\n                             time and stellar aberration.\n\n                  \"CN\"       Converged Newtonian light time correction.\n                             In solving the light time equations for\n                             target and the Sun, the \"CN\" correction\n                             iterates until the solution converges.\n\n                  \"CN+S\"     Converged Newtonian light time and\n                             stellar aberration corrections. This\n                             option produces a solution that is at\n                             least as accurate at that obtainable\n                             with the \"LT+S\" option. Whether the\n                             \"CN+S\" solution is substantially more\n                             accurate depends on the geometry of the\n                             participating objects and on the\n                             accuracy of the input data. In all\n                             cases this routine will execute more\n                             slowly when a converged solution is\n                             computed.\n\n               Neither case nor white space are significant in\n               `abcorr'. For example, the string\n\n                 \"Lt + s\"\n\n               is valid.\n\n\n   obsrvr      is the name of the observing body.  This is typically a\n               spacecraft, the earth, or a surface point on the earth.\n               `obsrvr' is case-insensitive, and leading and trailing\n               blanks in `obsrvr' are not significant. Optionally, you\n               may supply a string containing the integer ID code for\n               the object. For example both \"MOON\" and \"301\" are\n               legitimate strings that indicate the Moon is the\n               observer.\n\n               `obsrvr' may be not be identical to `target'.\n\n\n   spoint      is a surface point on the target body, expressed in\n               Cartesian coordinates, relative to the body-fixed\n               target frame designated by `fixref'.\n\n               `spoint' need not be visible from the observer's\n               location at the epoch `et'.\n\n               The components of `spoint' have units of km.\n\n\n-Detailed_Output\n\n   trgepc      is the \"surface point point epoch.\" `trgepc' is defined\n               as follows: letting `lt' be the one-way light time\n               between the observer and the input surface point\n               `spoint', `trgepc' is either the epoch et-lt or `et'\n               depending on whether the requested aberration correction\n               is, respectively, for received radiation or omitted.\n               `lt' is computed using the method indicated by `abcorr'.\n\n               `trgepc' is expressed as seconds past J2000 TDB.\n\n\n   srfvec      is the vector from the observer's position at `et' to\n               the aberration-corrected (or optionally, geometric)\n               position of `spoint', where the aberration corrections\n               are specified by `abcorr'. `srfvec' is expressed in the\n               target body-fixed reference frame designated by\n               `fixref', evaluated at `trgepc'.\n\n               The components of `srfvec' are given in units of km.\n\n               One can use the CSPICE function vnorm_c to obtain the\n               distance between the observer and `spoint':\n\n                  dist = vnorm_c ( srfvec );\n\n               The observer's position `obspos', relative to the\n               target body's center, where the center's position is\n               corrected for aberration effects as indicated by\n               `abcorr', can be computed via the call:\n\n                  vsub_c ( spoint, srfvec, obspos );\n\n               To transform the vector `srfvec' to a time-dependent\n               reference frame `ref' at `et', a sequence of two frame\n               transformations is required. For example, let `mfix'\n               and `mref' be 3x3 matrices respectively describing the\n               target body-fixed to J2000 frame transformation at\n               `trgepc' and the J2000 to (time-dependent frame) `ref'\n               transformation at `et', and let `xform' be the 3x3 matrix\n               representing the composition of `mref' with `mfix'. Then\n               `srfvec' can be transformed to the result `refvec' as\n               follows:\n\n                   pxform_c ( fixref,  \"j2000\", trgepc, mfix   );\n                   pxform_c ( \"j2000\", ref,     et,     mref   );\n                   mxm_c    ( mref,    mfix,            xform  );\n                   mxv_c    ( xform,   srfvec,          refvec );\n\n\n   phase       is the phase angle at `spoint', as seen from `obsrvr' at\n               time `et'. This is the angle between the spoint-obsrvr\n               vector and the spoint-sun vector. Units are radians. The\n               range of `phase' is [0, pi]. See Particulars below for a\n               detailed discussion of the definition.\n\n\n   solar       is the solar incidence angle at `spoint', as seen from\n               `obsrvr' at time `et'. This is the angle between the\n               surface normal vector at `spoint' and the spoint-sun\n               vector. Units are radians. The range of `solar' is [0,\n               pi]. See Particulars below for a detailed discussion of\n               the definition.\n\n\n   emissn      is the emission angle at `spoint', as seen from `obsrvr'\n               at time `et'. This is the angle between the surface\n               normal vector at `spoint' and the spoint-observer\n               vector. Units are radians. The range of `emissn' is [0,\n               pi]. See Particulars below for a detailed discussion of\n               the definition.\n\n");

/* void illum_c ( ConstSpiceChar * target,SpiceDouble et,
ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,ConstSpiceDouble spoint [3],
SpiceDouble * phase,SpiceDouble * solar,SpiceDouble * emissn ); */
static PyObject * spice_illum(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble phase;
  SpiceDouble solar;
  SpiceDouble emissn;
  /* variables for inputs */
  char * target;
  double et;
  char * abcorr;
  char * obsrvr;
  double spoint[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sdss(ddd)", &target, &et, &abcorr, &obsrvr, &spoint[0], &spoint[1], &spoint[2]));
  illum_c(target, et, abcorr, obsrvr, spoint, &phase, &solar, &emissn);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, phase, solar, emissn);
  return returnVal;
}
PyDoc_STRVAR(illum_doc, "-Abstract\n\n   Deprecated: This routine has been superseded by the CSPICE\n   routine ilumin_c. This routine is supported for purposes of\n   backward compatibility only.\n\n   Find the illumination angles at a specified surface point of a\n   target body.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   target     I   Name of target body.\n   et         I   Epoch in ephemeris seconds past J2000.\n   abcorr     I   Desired aberration correction.\n   obsrvr     I   Name of observing body.\n   spoint     I   Body-fixed coordinates of a target surface point.\n   phase      O   Phase angle at the surface point.\n   solar      O   Solar incidence angle at the surface point.\n   emissn     O   Emission angle at the surface point.\n\n-Detailed_Input\n\n   target         is the name of the target body.  `target' is\n                  case-insensitive, and leading and trailing blanks in\n                  `target' are not significant. Optionally, you may\n                  supply a string containing the integer ID code for\n                  the object. For example both \"MOON\" and \"301\" are\n                  legitimate strings that indicate the moon is the\n                  target body.\n\n   et             is the epoch, specified in ephemeris seconds past\n                  J2000, at which the apparent illumination angles at\n                  the specified surface point on the target body, as\n                  seen from the observing body, are to be computed.\n\n   abcorr         is the aberration correction to be used in\n                  computing the location and orientation of the\n                  target body and the location of the Sun.  Possible\n                  values are:\n\n                     \"NONE\"        No aberration correction.\n\n                     \"LT\"          Correct the position and\n                                   orientation of target body for\n                                   light time, and correct the\n                                   position of the Sun for light\n                                   time.\n\n                     \"LT+S\"        Correct the observer-target vector\n                                   for light time and stellar\n                                   aberration, correct the\n                                   orientation of the target body\n                                   for light time, and correct the\n                                   target-Sun vector for light time\n                                   and stellar aberration.\n\n                     \"CN\"          Converged Newtonian light time\n                                   corrections.  This is the same as LT\n                                   corrections but with further\n                                   iterations to a converged Newtonian\n                                   light time solution. Given that\n                                   relativistic effects may be as large\n                                   as the higher accuracy achieved by\n                                   this computation, this is correction\n                                   is seldom worth the additional\n                                   computations required unless the\n                                   user incorporates additional\n                                   relativistic corrections.  Both the\n                                   state and rotation of the target\n                                   body are corrected for light time.\n\n                     \"CN+S\"        Converged Newtonian light time\n                                   corrections and stellar aberration.\n                                   Both the state and rotation of the\n                                   target body are corrected for light\n                                   time.\n\n   obsrvr         is the name of the observing body.   This is\n                  typically a spacecraft, the earth, or a surface point\n                  on the earth.  `obsrvr' is case-insensitive, and\n                  leading and trailing blanks in `obsrvr' are not\n                  significant. Optionally, you may supply a string\n                  containing the integer ID code for the object.  For\n                  example both \"EARTH\" and \"399\" are legitimate strings\n                  that indicate the earth is the observer.\n\n                  `obsrvr' may be not be identical to `target'.\n\n   spoint         is a surface point on the target body, expressed\n                  in rectangular body-fixed (body equator and prime\n                  meridian) coordinates.  `spoint' need not be visible\n                  from the observer's location at time `et'.\n\n-Detailed_Output\n\n\n   phase          is the phase angle at `spoint', as seen from `obsrvr'\n                  at time `et'.  This is the angle between the\n                  spoint-obsrvr vector and the spoint-sun vector.\n                  Units are radians.  The range of `phase' is [0, pi].\n                  See Particulars below for a detailed discussion of\n                  the definition.\n\n   solar          is the solar incidence angle at `spoint', as seen\n                  from `obsrvr' at time `et'.  This is the angle\n                  between the surface normal vector at `spoint' and the\n                  spoint-sun vector.  Units are radians.  The range\n                  of `solar' is [0, pi]. See Particulars below for a\n                  detailed discussion of the definition.\n\n   emissn         is the emission angle at `spoint', as seen from\n                  `obsrvr' at time `et'.  This is the angle between the\n                  surface normal vector at `spoint' and the\n                  spoint-observer vector.  Units are radians.  The\n                  range of `emissn' is [0, pi]. See Particulars below\n                  for a detailed discussion of the definition.\n\n");

/* void inedpl_c ( SpiceDouble a,SpiceDouble b,SpiceDouble c,
ConstSpicePlane * plane,SpiceEllipse * ellipse,SpiceBoolean * found ); */
static PyObject * spice_inedpl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceEllipse ellipse;
  SpiceBoolean found;
  /* variables for inputs */
  double a;
  double b;
  double c;
  ConstSpicePlane * plane;
  PyObject * py_plane = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dddO", &a, &b, &c, &py_plane));
  plane = get_spice_plane(py_plane);

  inedpl_c(a, b, c, plane, &ellipse, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_ellipse(&ellipse));
  return returnVal;
  }

}
PyDoc_STRVAR(inedpl_doc, "-Abstract\n\n   Find the intersection of a triaxial ellipsoid and a plane.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   a          I   Length of ellipsoid semi-axis lying on the x-axis.\n   b          I   Length of ellipsoid semi-axis lying on the y-axis.\n   c          I   Length of ellipsoid semi-axis lying on the z-axis.\n   plane      I   Plane that intersects ellipsoid.\n   ellipse    O   Intersection ellipse, when found is SPICETRUE.\n   found      O   Flag indicating whether ellipse was found.\n\n-Detailed_Input\n\n   a,\n   b,\n   c              are the lengths of the semi-axes of a triaxial\n                  ellipsoid.  The ellipsoid is centered at the\n                  origin and oriented so that its axes lie on the\n                  x, y and z axes.  a, b, and c are the lengths of\n                  the semi-axes that point in the x, y, and z\n                  directions respectively.\n\n   plane          is a CSPICE plane.\n\n-Detailed_Output\n\n   ellipse        is the CSPICE ellipse formed by the intersection\n                  of the input plane and ellipsoid. ellipse will\n                  represent a single point if the ellipsoid and\n                  plane are tangent.\n\n                  If the intersection of the ellipsoid and plane is\n                  empty, ellipse is not modified.\n\n\n   found          is SPICETRUE if and only if the intersection of the\n                  ellipsoid and plane is non-empty.\n\n");

/* void inelpl_c ( ConstSpiceEllipse * ellips,ConstSpicePlane * plane,
SpiceInt * nxpts,SpiceDouble xpt1[3],SpiceDouble xpt2[3] ); */
static PyObject * spice_inelpl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt nxpts;
  SpiceDouble xpt1[3];
  SpiceDouble xpt2[3];
  /* variables for inputs */
  ConstSpiceEllipse * ellips;
  PyObject * py_ellips = NULL;
  ConstSpicePlane * plane;
  PyObject * py_plane = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "OO", &py_ellips, &py_plane));
  ellips = get_spice_ellipse(py_ellips);
plane = get_spice_plane(py_plane);

  inelpl_c(ellips, plane, &nxpts, xpt1, xpt2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, nxpts, xpt1[0], xpt1[1], xpt1[2], xpt2[0], xpt2[1], xpt2[2]);
  return returnVal;
}
PyDoc_STRVAR(inelpl_doc, "-Abstract\n\n   Find the intersection of an ellipse and a plane.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   ellips     I   A CSPICE ellipse.\n   plane      I   A CSPICE plane.\n   nxpts      O   Number of intersection points of plane and ellipse.\n   xpt1,\n   xpt2       O   Intersection points.\n\n-Detailed_Input\n\n   ellips         is a CSPICE ellipse. The ellipse is allowed to\n                  be degenerate: one or both semi-axes may have\n                  zero length.\n\n   plane          is a CSPICE plane.  The intersection of plane\n                  and ellipse is sought.\n\n-Detailed_Output\n\n   nxpts          is the number of points of intersection of the\n                  geometric plane and ellipse represented by `plane' and\n                  `ellips'. `nxpts' may take the values 0, 1, 2 or -1.\n                  The value -1 indicates that the ellipse consists of\n                  more than one point lies in the plane, so the number\n                  of intersection points is infinite.\n\n                  When the ellipse consists of a single point and\n                  lies in the plane, `nxpts' is set to 1.\n\n   xpt1,\n   xpt2           are the points of intersection of the input plane\n                  and ellipse. If there is only one intersection\n                  point, both xpt1 and xpt2 contain that point. If\n                  the number of intersection points is zero or\n                  infinite, the contents of xpt1 and xpt2 are\n                  undefined.\n\n");

/* void insrtc_c ( ConstSpiceChar * item,SpiceCell * set ); */
static PyObject * spice_insrtc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  char * item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &item));
  insrtc_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(insrtc_doc, "-Abstract\n\n   Insert an item into a character set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be inserted.\n   set       I/O  Insertion set.\n\n-Detailed_Input\n\n   item        is an item which is to be inserted into the specified\n               set. item may or may not already be an element of the\n               set.  Trailing blanks in item are not significant.\n\n\n   set         is a CSPICE set.  set must be declared as a character\n               SpiceCell.\n\n               On input, set  may or may not contain the input item\n               as an element.\n\n-Detailed_Output\n\n   set         on output contains the union of the input set and\n               the singleton set containing the input item.\n\n");

/* void insrtd_c ( SpiceDouble item,SpiceCell * set ); */
static PyObject * spice_insrtd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  double item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &item));
  insrtd_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(insrtd_doc, "-Abstract\n\n   Insert an item into a double precision set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be inserted.\n   set       I/O  Insertion set.\n\n-Detailed_Input\n\n   item        is an item which is to be inserted into the\n               specified set. item may or may not already\n               be an element of the set.\n\n\n   set         is a CSPICE set.  set must be declared as a double\n               precision SpiceCell.\n\n               On input, set  may or may not contain the input item\n               as an element.\n\n-Detailed_Output\n\n   set         on output contains the union of the input set and\n               the singleton set containing the input item.\n\n");

/* void insrti_c ( SpiceInt item,SpiceCell * set ); */
static PyObject * spice_insrti(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  int item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &item));
  insrti_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(insrti_doc, "-Abstract\n\n   Insert an item into an integer set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be inserted.\n   set       I/O  Insertion set.\n\n-Detailed_Input\n\n   item        is an item which is to be inserted into the\n               specified set. item may or may not already\n               be an element of the set.\n\n\n   set         is a CSPICE set.  set must be declared as an integer\n               SpiceCell.\n\n               On input, set  may or may not contain the input item\n               as an element.\n\n-Detailed_Output\n\n   set         on output contains the union of the input set and\n               the singleton set containing the input item.\n\n");

/* void inter_c ( SpiceCell * a,SpiceCell * b,SpiceCell * c ); */
static PyObject * spice_inter(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  SpiceCell b;
  SpiceCell c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  inter_c(&a, &b, &c);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a), get_py_cell(&b), get_py_cell(&c));
  return returnVal;
}
PyDoc_STRVAR(inter_doc, "-Abstract\n\n   Intersect two sets of any data type to form a third set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   First input set.\n   b          I   Second input set.\n   c          O   Intersection of a and b.\n\n-Detailed_Input\n\n   a           is a CSPICE set.  a must be declared as a SpiceCell\n               of data type character, double precision, or integer.\n\n   b           is a CSPICE set, distinct from a.  b must have the\n               same data type as a.\n\n-Detailed_Output\n\n   c           is a CSPICE set, distinct from sets a and b, which\n               contains the intersection of a and b (that is, all of\n               the elements which are in a AND b).  c must have the\n               same data type as a and b.\n\n               When comparing elements of character sets, this routine\n               ignores trailing blanks.  Trailing blanks will be\n               trimmed from the members of the output set c.\n\n");

/* void inrypl_c ( ConstSpiceDouble vertex [3],ConstSpiceDouble dir [3],
ConstSpicePlane * plane,SpiceInt * nxpts,SpiceDouble xpt [3] ); */
static PyObject * spice_inrypl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt nxpts;
  SpiceDouble xpt[3];
  /* variables for inputs */
  double vertex[3];
  double dir[3];
  ConstSpicePlane * plane;
  PyObject * py_plane = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)O", &vertex[0], &vertex[1], &vertex[2], &dir[0], &dir[1], &dir[2], &py_plane));
  plane = get_spice_plane(py_plane);

  inrypl_c(vertex, dir, plane, &nxpts, xpt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, nxpts, xpt[0], xpt[1], xpt[2]);
  return returnVal;
}
PyDoc_STRVAR(inrypl_doc, "-Abstract\n\n   Find the intersection of a ray and a plane.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   vertex,\n   dir        I   Vertex and direction vector of ray.\n   plane      I   A CSPICE plane.\n   nxpts      O   Number of intersection points of ray and plane.\n   xpt        O   Intersection point, if nxpts = 1.\n\n-Detailed_Input\n\n   vertex,\n   dir            are a point and direction vector that define a\n                  ray in three-dimensional space.\n\n   plane          is a CSPICE plane.\n\n-Detailed_Output\n\n   nxpts          is the number of points of intersection of the\n                  input ray and plane.  Values and meanings of\n                  nxpts are:\n\n                     0     No intersection.\n\n                     1     One point of intersection.  Note that\n                           this case may occur when the ray's\n                           vertex is in the plane.\n\n                    -1     An infinite number of points of\n                           intersection; the ray lies in the plane.\n\n\n   xpt            is the point of intersection of the input ray\n                  and plane, when there is exactly one point of\n                  intersection.\n\n                  If the ray lies in the plane, xpt is set equal to\n                  vertex.\n\n                  If there is no intersection, xpt is the zero vector.\n\n");

/* SpiceInt intmax_c ( void ); */
static PyObject * spice_intmax(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  result = intmax_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(intmax_doc, "-Abstract\n\n   Return the value of the largest (positive) number representable\n   in a SpiceInt variable.\n\n-Brief_I/O\n\n   The function returns the value of the largest (positive) number\n   that can be represented in a SpiceInt variable.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the value of the largest (positive) number\n   that can be represented in an SpiceInt variable, where SpiceInt\n   is a typedef defined in SpiceZdf.h.\n\n   The returned value will be greater than or equal to 2147483647.\n   See the Particulars section for details.\n\n");

/* SpiceInt intmax_ ( void ); */
static PyObject * spice_intmax_(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  result = intmax_();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(intmax__doc, "");

/* SpiceInt intmin_c ( void ); */
static PyObject * spice_intmin(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  result = intmin_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(intmin_doc, "-Abstract\n\n   Return the value of the smallest (negative) number representable\n   in a SpiceInt variable.\n\n-Brief_I/O\n\n   The function returns the value of the smallest (negative) number\n   that can be represented in a SpiceInt variable.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the value of the smallest (negative) number\n   that can be represented in an SpiceInt variable, where SpiceInt\n   is a typedef defined in SpiceZdf.h.\n\n   The returned value will be less than or equal to -2147483647.\n   See the Particulars section for details.\n\n");

/* SpiceInt intmin_ ( void ); */
static PyObject * spice_intmin_(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  result = intmin_();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(intmin__doc, "");

/* void invert_c ( ConstSpiceDouble m1[3][3],SpiceDouble m2[3][3] ); */
static PyObject * spice_invert(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble m2[3][3];
  /* variables for inputs */
  double m1[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2]));
  invert_c(m1, m2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, m2[0][0], m2[0][1], m2[0][2], m2[1][0], m2[1][1], m2[1][2], m2[2][0], m2[2][1], m2[2][2]);
  return returnVal;
}
PyDoc_STRVAR(invert_doc, "-Abstract\n\n   Generate the inverse of a 3x3 matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   m1         I   Matrix to be inverted.\n   mout       O   Inverted matrix (m1)**-1.  If m1 is singular, then\n                  mout will be the zero matrix.   mout can\n                  overwrite m1.\n\n-Detailed_Input\n\n   m1    An arbitrary 3x3 matrix.  The limits on the size of\n         elements of m1 are determined by the process of calculating\n         the cofactors of each element of the matrix.  For a 3x3\n         matrix this amounts to the differencing of two terms, each\n         of which consists of the multiplication of two matrix\n         elements.  This multiplication must not exceed the range\n         of double precision numbers or else an overflow error will\n         occur.\n\n-Detailed_Output\n\n   mout  is the inverse of m1 and is calculated explicitly using\n         the matrix of cofactors.  mout is set to be the zero matrix\n         if m1 is singular.\n\n");

/* void invort_c ( ConstSpiceDouble m [3][3],SpiceDouble mit[3][3] ); */
static PyObject * spice_invort(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mit[3][3];
  /* variables for inputs */
  double m[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))", &m[0][0], &m[0][1], &m[0][2], &m[1][0], &m[1][1], &m[1][2], &m[2][0], &m[2][1], &m[2][2]));
  invort_c(m, mit);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mit[0][0], mit[0][1], mit[0][2], mit[1][0], mit[1][1], mit[1][2], mit[2][0], mit[2][1], mit[2][2]);
  return returnVal;
}
PyDoc_STRVAR(invort_doc, "-Abstract\n\n   Given a matrix, construct the matrix whose rows are the\n   columns of the first divided by the length squared of the\n   the corresponding columns of the input matrix.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   m          I   A 3x3 matrix.\n   mit        I   m after transposition and scaling of rows.\n\n-Detailed_Input\n\n   m          is a 3x3 matrix.\n\n-Detailed_Output\n\n   mit        is the matrix obtained by transposing m and dividing\n              the rows by squares of their norms.\n\n");

/* SpiceBoolean isordv_c ( ConstSpiceInt * array,SpiceInt n ); */
static PyObject * spice_isordv(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int * array;
  int n;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &array, &n));
  result = isordv_c(array, n);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(isordv_doc, "-Abstract\n\n   Determine whether an array of n items contains the integers\n   0 through n-1.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   array      I   Array of integers.\n   n          I   Number of integers in array.\n\n   The function returns SPICETRUE if the array contains the integers\n   0 through n-1, otherwise it returns SPICEFALSE.\n\n-Detailed_Input\n\n   array      is an array of integers.  Often this will be an array\n              that is a candidate order vector to be passed to\n              a routine for re-ordering some parallel array.\n\n   n          is the number of elements in array.\n\n-Detailed_Output\n\n   The function returns SPICETRUE if the array contains the integers\n   1 through n.  Otherwise it returns SPICEFALSE.\n\n");

/* SpiceBoolean isrot_c ( ConstSpiceDouble m [3][3],SpiceDouble ntol,
SpiceDouble dtol ); */
static PyObject * spice_isrot(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double m[3][3];
  double ntol;
  double dtol;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))dd", &m[0][0], &m[0][1], &m[0][2], &m[1][0], &m[1][1], &m[1][2], &m[2][0], &m[2][1], &m[2][2], &ntol, &dtol));
  result = isrot_c(m, ntol, dtol);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(isrot_doc, "-Abstract\n\n   Indicate whether a 3x3 matrix is a rotation matrix.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   m          I   A matrix to be tested.\n   ntol       I   Tolerance for the norms of the columns of m.\n   dtol       I   Tolerance for the determinant of a matrix whose\n                  columns are the unitized columns of m.\n\n   The function returns the value SPICETRUE if and only if m is\n   a rotation matrix.\n\n-Detailed_Input\n\n   m              is a 3x3 matrix to be tested.\n\n   ntol           is the tolerance for the norms of the columns\n                  of m.\n\n   dtol           is the tolerance for the determinant of a matrix\n                  whose columns are the unitized columns of m.\n\n-Detailed_Output\n\n   The function returns the value SPICETRUE if and only if m is found\n   to be a rotation matrix.  The criteria that m must meet are:\n\n\n      1) The norm of each column of m must satisfy the relation\n\n            1. - ntol  <   || column ||   <  1. + ntol.\n                       -                  -\n\n      2) The determinant of the matrix whose columns are the\n         unitized columns of m must satisfy\n\n            1. - dtol  <   determinant   <  1. + dtol.\n                       -                 -\n");

/* SpiceInt isrchd_c ( SpiceDouble value,SpiceInt ndim,
ConstSpiceDouble * array ); */
static PyObject * spice_isrchd(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double value;
  int ndim;
  double * array;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "did", &value, &ndim, &array));
  result = isrchd_c(value, ndim, array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(isrchd_doc, "-Abstract\n\n   Search for a given value within a double precision array. Return\n   the index of the first matching array entry, or -1 if the key value\n   was not found.\n\n-Brief_I/O\n\n   VARIABLE  I/O              DESCRIPTION\n   --------  ---  --------------------------------------------------\n   value     I     Key value to be found in array.\n   ndim      I     Dimension of array.\n   array     I     Double Precision array to search.\n\n   The function returns the index of the first matching array\n   element or -1 if the value is not found.\n\n-Detailed_Input\n\n   value      is the key value to be found in the array.\n\n   ndim       is the dimension of the array.\n\n   array      is the double precision array to be searched.\n\n-Detailed_Output\n\n   The function returns the index of the first matching array\n   element in array. If value is not found, isrchd_c returns -1.\n\n");

/* SpiceInt isrchi_c ( SpiceInt value,SpiceInt ndim,ConstSpiceInt * array ); */
static PyObject * spice_isrchi(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int value;
  int ndim;
  int * array;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &value, &ndim, &array));
  result = isrchi_c(value, ndim, array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(isrchi_doc, "-Abstract\n\n   Search for a given value within an integer array. Return\n   the index of the first matching array entry, or -1 if the key\n   value was not found.\n\n-Brief_I/O\n\n   VARIABLE  I/O              DESCRIPTION\n   --------  ---  --------------------------------------------------\n   value     I     Key value to be found in array.\n   ndim      I     Dimension of array.\n   array     I     Integer array to search.\n\n   The function returns the index of the first matching array\n   element or -1 if the value is not found.\n\n-Detailed_Input\n\n   value      is the key value to be found in the array.\n\n   ndim       is the dimension of the array.\n\n   array      is the integer array to be searched.\n\n-Detailed_Output\n\n   The function returns the index of the first matching array\n   element in array. If value is not found, isrchi_c returns -1.\n\n");

/* SpiceBoolean iswhsp_c ( ConstSpiceChar * string ); */
static PyObject * spice_iswhsp(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * string;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &string));
  result = iswhsp_c(string);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(iswhsp_doc, "-Abstract\n\n   Return a boolean value indicating whether a string contains\n   only white space characters.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   string     I   String to be tested.\n\n   The function returns the boolean value SPICETRUE if the string is\n   empty or contains only white space characters; otherwise it returns\n   the value SPICEFALSE.\n\n-Detailed_Input\n\n   string     is a character pointer designating a string to be\n              searched for non-white-space characters.\n\n-Detailed_Output\n\n   The function returns the boolean value SPICETRUE if the string\n   contains only white space characters; otherwise it returns the\n   value SPICEFALSE.\n\n   White space characters are those in the set\n\n      { ' ', '\\f', '\\n', '\\r', '\\t', '\\v' }\n\n\n");

/* SpiceDouble j1900_c ( void ); */
static PyObject * spice_j1900(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = j1900_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(j1900_doc, "-Abstract\n\n   Return the Julian Date of 1899 DEC 31 12:00:00 (1900 JAN 0.5).\n\n-Brief_I/O\n\n   The function returns the Julian Date of 1899 DEC 31 12:00:00\n   (1900 JAN 0.5).\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns 2415020.0, the Julian Date corresponding\n   to 1899 DEC 31 12:00:00 (1900 JAN 0.5).\n\n");

/* SpiceDouble j1950_c ( void ); */
static PyObject * spice_j1950(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = j1950_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(j1950_doc, "-Abstract\n\n   Return the Julian Date of 1950 JAN 01 00:00:00 (1950 JAN 1.0).\n\n-Brief_I/O\n\n   The function returns the Julian Date of 1950 JAN 01 00:00:00\n   (1950 JAN 1.0).\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns 2433282.5, the Julian Date corresponding\n   to 1950 JAN 01 00:00:00 (1950 JAN 1.0).\n\n");

/* SpiceDouble j2000_c ( void ); */
static PyObject * spice_j2000(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = j2000_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(j2000_doc, "-Abstract\n\n   Return the Julian Date of 2000 JAN 01 12:00:00 (2000 JAN 1.5).\n\n-Brief_I/O\n\n   The function returns the Julian Date of 2000 JAN 01 12:00:00\n   (2000 JAN 1.5).\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns 2451545.0, the Julian Date corresponding\n   to 2000 JAN 01 12:00:00 (2000 JAN 1.5).\n\n");

/* SpiceDouble j2100_c ( void ); */
static PyObject * spice_j2100(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = j2100_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(j2100_doc, "-Abstract\n\n   Return the Julian Date of 2100 JAN 01 12:00:00 (2100 JAN 1.5).\n\n-Brief_I/O\n\n   The function returns the Julian Date of 2100 JAN 01 12:00:00\n   (2100 JAN 1.5).\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns 2488070.0, the Julian Date corresponding\n   to 2100 JAN 01 12:00:00 (2100 JAN 1.5).\n\n");

/* SpiceDouble jyear_c ( void ); */
static PyObject * spice_jyear(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = jyear_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(jyear_doc, "-Abstract\n\n   Return the number of seconds in a julian year.\n\n-Brief_I/O\n\n   VARIABLE  I/O              DESCRIPTION\n   --------  ---  --------------------------------------------------\n   jyear_c    O   The number of seconds/julian year\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the number of seconds per julian\n   year.\n\n");

/* void kclear_c ( void ); */
static PyObject * spice_kclear(PyObject *self, PyObject *args)
{

  char failed = 0;

  kclear_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(kclear_doc, "-Abstract\n\n   Clear the KEEPER system:  unload all kernels, clear the kernel\n   pool, and re-initialize the system.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   None.\n\n-Detailed_Input\n\n   None.  This routine operates by side effects.  See Particulars\n   below.\n\n-Detailed_Output\n\n   None.\n\n");

/* void kdata_c ( SpiceInt which,ConstSpiceChar * kind,SpiceInt fillen,
SpiceInt typlen,SpiceInt srclen,SpiceChar * file,SpiceChar * filtyp,
SpiceChar * source,SpiceInt * handle,SpiceBoolean * found ); */
static PyObject * spice_kdata(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar file[STRING_LEN];
  SpiceChar filtyp[STRING_LEN];
  SpiceChar source[STRING_LEN];
  SpiceInt handle;
  SpiceBoolean found;
  /* variables for inputs */
  int which;
  char * kind;
  int fillen = STRING_LEN;
  int typlen = STRING_LEN;
  int srclen = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "is", &which, &kind));
  kdata_c(which, kind, fillen, typlen, srclen, file, filtyp, source, &handle, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "i");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, file, filtyp, source, handle);
  return returnVal;
  }

}
PyDoc_STRVAR(kdata_doc, "-Abstract\n\n   Return data for the nth kernel that is among a list of specified\n   kernel types.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   which      I   Index of kernel to fetch from the list of kernels.\n   kind       I   The kind of kernel to which fetches are limited.\n   fillen     I   Available space in output file string.\n   typlen     I   Available space in output kernel type string.\n   srclen     I   Available space in output source string.\n   file       O   The name of the kernel file.\n   filtyp     O   The type of the kernel.\n   source     O   Name of the source file used to load file.\n   handle     O   The handle attached to file.\n   found      O   SPICETRUE if the specified file could be located.\n\n-Detailed_Input\n\n   which      is the number of the kernel to fetch (matching the\n              type specified by kind) from the list of kernels that\n              have been loaded through the entry point furnsh_c but\n              that have not been unloaded through the entry point\n              unload_c.\n\n              The range of which is 0 to count-1, where count is\n              the number of kernels loaded via furnsh_c.  This\n              count may be obtained by calling ktotal_c.  See the\n              Examples section for an illustrative code fragment.\n\n\n   kind       is a list of types of kernels to be considered when\n              fetching kernels from the list of loaded kernels. KIND\n              should consist of a list of words of kernels to\n              examine.  Recognized types are\n\n                 SPK  --- All SPK files are counted in the total.\n                 CK   --- All CK files are counted in the total.\n                 PCK  --- All binary PCK files are counted in the\n                          total.\n                 EK   --- All EK files are counted in the total.\n                 TEXT --- All text kernels that are not meta-text\n                          kernels are included in the total.\n                 META --- All meta-text kernels are counted in the\n                          total.\n                 ALL  --- Every type of kernel is counted in the\n                          total.\n\n               kind is case insensitive.  If a word appears in kind\n               that is not one of those listed above it is ignored.\n\n               See the entry point ktotal_c for examples of the use\n               of kind.\n\n   fillen      is the amount of available space in the output file\n               string, including room for the terminating null.\n               Normally, this is the declared length of the output\n               string.\n\n   typlen      is the amount of available space in the output kernel\n               type string.\n\n   srclen      is the amount of available space in the output kernel\n               source string.\n\n\n-Detailed_Output\n\n\n   file        is the name of the file having index which in the\n               sequence of files of type kind currently loaded via\n               furnsh_c.  file will be blank if there is no such kernel\n               is loaded.\n\n   filtyp      is the type of the kernel specified by file.  filtyp\n               will be empty if there is no file matching the\n               specification of which and kind.\n\n   source      is the name of the source file that was used to\n               specify file as one to load.  If file was loaded\n               directly via a call to furnsh_c, source will be empty.\n               If there is no file matching the specification of\n               which and kind, source will be empty.\n\n   handle      is the handle attached to file if it is a binary\n               kernel.  If file is a text kernel or meta-text kernel\n               handle will be zero.  If there is no file matching\n               the specification of which and kind, handle will be\n               set to zero.\n\n   found       is returned SPICETRUE if a file matching the\n               specification of which and kind exists.  If there is no\n               such file, found will be set to SPICEFALSE.\n\n");

/* void kinfo_c ( ConstSpiceChar * file,SpiceInt typlen,SpiceInt srclen,
SpiceChar * filtyp,SpiceChar * source,SpiceInt * handle,
SpiceBoolean * found ); */
static PyObject * spice_kinfo(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar filtyp[STRING_LEN];
  SpiceChar source[STRING_LEN];
  SpiceInt handle;
  SpiceBoolean found;
  /* variables for inputs */
  char * file;
  int typlen = STRING_LEN;
  int srclen = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &file));
  kinfo_c(file, typlen, srclen, filtyp, source, &handle, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "i");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, filtyp, source, handle);
  return returnVal;
  }

}
PyDoc_STRVAR(kinfo_doc, "-Abstract\n\n   Return information about a loaded kernel specified by name.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   file       I   Name of a kernel to fetch information for\n   typlen     I   Available space in output kernel type string.\n   srclen     I   Available space in output source string.\n   filtyp     O   The type of the kernel.\n   source     O   Name of the source file used to load file.\n   handle     O   The handle attached to file.\n   found      O   SPICETRUE if the specified file could be located.\n\n-Detailed_Input\n\n   file        is the name of a kernel file for which descriptive\n               information is desired.\n\n   typlen      is the amount of available space in the output kernel\n               type string.\n\n   srclen      is the amount of available space in the output kernel\n               source string.\n\n\n-Detailed_Output\n\n   filtyp      is the type of the kernel specified by file.  filtyp\n               will be empty if file is not on the list of kernels\n               loaded via furnsh_c.\n\n   source      is the name of the source file that was used to\n               specify file as one to load.  If file was loaded\n               directly via a call to furnsh_c, source will be empty.\n               If file is not on the list of kernels loaded via\n               furnsh_c, source will be empty.\n\n   handle      is the handle attached to file if it is a binary\n               kernel.  If file is a text kernel or meta-text kernel\n               handle will be zero. If file is not on the list of\n               kernels loaded via furnsh_c, handle will be set to zero.\n\n   found       is returned SPICETRUE if the specified file exists.\n               If there is no such file, found will be set to\n               SPICEFALSE.\n\n");

/* void ktotal_c ( ConstSpiceChar * kind,SpiceInt * count ); */
static PyObject * spice_ktotal(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt count;
  /* variables for inputs */
  char * kind;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &kind));
  ktotal_c(kind, &count);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, count);
  return returnVal;
}
PyDoc_STRVAR(ktotal_doc, "-Abstract\n\n   Return the current number of kernels that have been loaded\n   via the KEEPER interface that are of a specified type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   kind       I   A list of kinds of kernels to count.\n   count      O   The number of kernels of type kind.\n\n-Detailed_Input\n\n   kind       is a list of types of kernels to count when computing\n              loaded kernels.  kind should consist of a list of words\n              of kernels to examine.  Recognized types are\n\n                 SPK  --- All SPK files are counted in the total.\n                 CK   --- All CK files are counted in the total.\n                 PCK  --- All binary PCK files are counted in the\n                          total.\n                 EK   --- All EK files are counted in the total.\n                 TEXT --- All text kernels that are not meta-text.\n                          kernels are included in the total.\n                 META --- All meta-text kernels are counted in the\n                          total.\n                 ALL  --- Every type of kernel is counted in the\n                          total.\n\n               kind is case insensitive.  If a word appears in kind\n               that is not one of those listed above, it is ignored.\n\n               See the Examples section for illustrations of the\n               use of kind.\n\n-Detailed_Output\n\n   count       is the number of kernels loaded through furnsh_c that\n               belong to the list specified by kind.\n\n");

/* SpiceInt lastnb_c ( ConstSpiceChar * string ); */
static PyObject * spice_lastnb(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * string;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &string));
  result = lastnb_c(string);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(lastnb_doc, "-Abstract\n\n   Return the zero based index of the last non-blank character in\n   a character string.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   string     I   Input character string.\n\n   The function returns the zero-based index of the last non-blank\n   character in a character string.\n\n-Detailed_Input\n\n   string     is the input character string.\n\n-Detailed_Output\n\n   The function returns the zero-based index of the last non-blank\n   character in a character string.  If the string is entirely blank\n   or is empty, the value -1 is returned.\n\n");

/* void latcyl_c ( SpiceDouble radius,SpiceDouble lon,SpiceDouble lat,
SpiceDouble * r,SpiceDouble * lonc,SpiceDouble * z ); */
static PyObject * spice_latcyl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble r;
  SpiceDouble lonc;
  SpiceDouble z;
  /* variables for inputs */
  double radius;
  double lon;
  double lat;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &radius, &lon, &lat));
  latcyl_c(radius, lon, lat, &r, &lonc, &z);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, r, lonc, z);
  return returnVal;
}
PyDoc_STRVAR(latcyl_doc, "-Abstract\n\n   Convert from latitudinal coordinates to cylindrical coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   radius     I   Distance of a point from the origin.\n   lon        I   Angle of the point from the XZ plane in radians.\n   lat        I   Angle of the point from the XY plane in radians.\n   r          O   Distance of the point from the z axis.\n   lonc       O   Angle of the point from the XZ plane in radians.\n   z          O   Height of the point above the XY plane.\n\n-Detailed_Input\n\n   radius     Distance of a point from the origin.\n\n   lon        Angle of the point from the XZ plane in radians.\n\n   lat        Angle of the point from the XY plane in radians.\n\n-Detailed_Output\n\n   r          Distance of the point from the z axis.\n\n   lonc       Angle of the point from the XZ plane in radians.\n\n   z          Height of the point above the XY plane.\n\n");

/* void latrec_c ( SpiceDouble radius,SpiceDouble longitude,
SpiceDouble latitude,SpiceDouble rectan [3] ); */
static PyObject * spice_latrec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rectan[3];
  /* variables for inputs */
  double radius;
  double longitude;
  double latitude;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &radius, &longitude, &latitude));
  latrec_c(radius, longitude, latitude, rectan);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rectan[0], rectan[1], rectan[2]);
  return returnVal;
}
PyDoc_STRVAR(latrec_doc, "-Abstract\n\n   Convert from latitudinal coordinates to rectangular coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   radius     I   Distance of a point from the origin.\n   longitude  I   Longitude of point in radians.\n   latitude   I   Latitude of point in radians.\n   rectan     O   Rectangular coordinates of the point.\n\n-Detailed_Input\n\n   radius     Distance of a point from the origin.\n\n   longitude  Longitude of the input point.  This is the angle between\n              the prime meridian and the meridian containing `rectan'.\n              The direction of increasing longitude is from the +X axis\n              towards the +Y axis.\n\n              Longitude is measured in radians.  On input, the range\n              of longitude is unrestricted.\n\n   latitude   Latitude of the input point. This is the angle from\n              the XY plane of the ray from the origin through the\n              point.\n\n              Latitude is measured in radians. On input, the range of\n              latitude is unrestricted.\n\n-Detailed_Output\n\n   rectan     The rectangular coordinates of the input point.\n              `rectan' is a 3 vector.\n\n              The units associated with `rectan' are those\n              associated with the input radius.\n");

/* void latsph_c ( SpiceDouble radius,SpiceDouble lon,SpiceDouble lat,
SpiceDouble * rho,SpiceDouble * colat,SpiceDouble * lons ); */
static PyObject * spice_latsph(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rho;
  SpiceDouble colat;
  SpiceDouble lons;
  /* variables for inputs */
  double radius;
  double lon;
  double lat;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &radius, &lon, &lat));
  latsph_c(radius, lon, lat, &rho, &colat, &lons);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rho, colat, lons);
  return returnVal;
}
PyDoc_STRVAR(latsph_doc, "-Abstract\n\n   Convert from latitudinal coordinates to spherical coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   radius     I   Distance of a point from the origin.\n   lon        I   Angle of the point from the XZ plane in radians.\n   lat        I   Angle of the point from the XY plane in radians.\n   rho        O   Distance of the point from the origin.\n   colat      O   Angle of the point from positive z axis (radians).\n   lons       O   Angle of the point from the XZ plane (radians).\n\n-Detailed_Input\n\n   radius     Distance of a point from the origin.\n\n   lon        Angle of the point from the XZ plane in radians.\n\n   lat        Angle of the point from the XY plane in radians.\n\n-Detailed_Output\n\n   rho        Distance of the point from the origin.\n\n   colat      Angle between the vector from the origin to the point\n              and the positive z axis in radians.\n\n   lons       Angle of the point from the XZ plane (radians).\n\n");

/* void ldpool_c ( ConstSpiceChar * filename ); */
static PyObject * spice_ldpool(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * filename;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &filename));
  ldpool_c(filename);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(ldpool_doc, "-Abstract\n\n   Load the variables contained in a NAIF ASCII kernel file into the\n   kernel pool.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   filename   I   Name of the kernel file.\n\n-Detailed_Input\n\n   filename   is the name of the kernel file whose variables will be\n              loaded into the pool.\n\n-Detailed_Output\n\n   None.\n\n");

/* void lparss_c ( ConstSpiceChar * list,ConstSpiceChar * delims,
SpiceCell * set ); */
static PyObject * spice_lparss(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  char * list;
  char * delims;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ss", &list, &delims));
  lparss_c(list, delims, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(lparss_doc, "-Abstract\n\n   Parse a list of items separated by multiple delimiters, placing the\n   resulting items into a set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   list       I    List of items delimited by delims.\n   delims     I    Single characters which delimit items.\n   set        O    Set containing items in the list, left justified.\n\n-Detailed_Input\n\n   list        is a list of items delimited by any one of the\n               characters in the string delims. Consecutive delimiters,\n               and delimiters at the beginning and end of the list, are\n               considered to delimit empty items. A blank or empty list\n               is considered to contain a single, empty item.  Leading\n               and trailing blanks in list are ignored.\n\n   delims      contains the individual characters which delimit\n               the items in the list. These may be any ASCII\n               characters, including blanks.\n\n               However, by definition, consecutive blanks are NOT\n               considered to be consecutive delimiters. Nor are\n               a blank and any other delimiter considered to be\n               consecutive delimiters.\n\n-Detailed_Output\n\n   set         is a CSPICE set containing the items in the list,\n               left justified. Any item in the list too long to fit into\n               an element of items is truncated on the right.  Empty\n               (null) or blank items in the input string are mapped to\n               empty strings on output.\n\n               set should be declared by the caller as a character\n               SpiceCell:\n\n                  SPICECHAR_CELL ( set, NMAX, LENGTH );\n\n               where NMAX is the maximum number of strings the set is\n               expected to hold and LENGTH is the maximum length of\n               the strings, counting the terminating null.\n\n               The strings in set will be sorted in increasing order,\n               and duplicates will be removed.  Trailing blanks are\n               ignored in string comparisons.\n\n");

/* SpiceDouble lspcn_c ( ConstSpiceChar * body,SpiceDouble et,
ConstSpiceChar * abcorr ); */
static PyObject * spice_lspcn(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * body;
  double et;
  char * abcorr;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sds", &body, &et, &abcorr));
  result = lspcn_c(body, et, abcorr);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(lspcn_doc, "-Abstract\n\n   Compute L_s, the planetocentric longitude of the sun, as seen\n   from a specified body.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   body       I   Name of central body.\n   et         I   Epoch in seconds past J2000 TDB.\n   abcorr     I   Aberration correction.\n\n   The function returns the value of L_s for the specified body\n   at the specified time.\n\n-Detailed_Input\n\n   body        is the name of the central body, typically a planet.\n\n   et          is the epoch at which the longitude of the sun (L_s) is\n               to be computed. `et' is expressed as seconds past J2000\n               TDB (Barycentric Dynamical Time).\n\n   abcorr      indicates the aberration corrections to be applied\n               when computing the longitude of the sun.  `abcorr'\n               may be any of the following.\n\n                  \"NONE\"     Apply no correction.\n\n                  \"LT\"       Correct the position of the sun,\n                             relative to the central body, for\n                             planetary (light time) aberration.\n\n                  \"LT+S\"     Correct the position of the sun,\n                             relative to the central body, for\n                             planetary and stellar aberrations.\n\n-Detailed_Output\n\n   The function returns the planetocentric longitude of the sun,\n   often called \"L_s,\" for the specified body at the specified time.\n   This is the longitude of the body-sun vector in a right-handed\n   frame whose basis vectors are defined as follows:\n\n      - The positive Z direction is given by the instantaneous\n        angular velocity vector of the orbit of the body about\n        the sun.\n\n      - The positive X direction is that of the cross product of the\n        instantaneous north spin axis of the body with the\n        positive Z direction.\n\n      - The positive Y direction is Z x X.\n\n   Units are radians; the range is 0 to 2*pi.  Longitudes are\n   positive to the east.\n\n");

/* SpiceInt lstled_c ( SpiceDouble x,SpiceInt n,ConstSpiceDouble * array ); */
static PyObject * spice_lstled(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double x;
  int n;
  double * array;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "did", &x, &n, &array));
  result = lstled_c(x, n, array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(lstled_doc, "-Abstract\n\n   Given a number x and an array of non-decreasing numbers,\n   find the index of the largest array element less than or equal\n   to x.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   x          I   Value to search against\n   n          I   Number elements in array\n   array      I   Array of possible lower bounds\n\n   The function returns the index of the last element of array that\n   is less than or equal to x.\n\n-Detailed_Input\n\n   x       Double precision number.\n\n   n       Total number of elements in array.\n\n   array   Array of double precision numbers which forms a\n           non-decreasing sequence.  The elements of array need not be\n           distinct.\n\n-Detailed_Output\n\n   The function returns the index of the highest-indexed element in the\n   input array that is less than or equal to x.  The routine assumes\n   the array elements are sorted in non-decreasing order.\n\n   Indices range from 0 to n-1.\n\n   If all elements of the input array are greater than x, the function\n   returns -1.\n\n");

/* SpiceInt lstlei_c ( SpiceInt x,SpiceInt n,ConstSpiceInt * array ); */
static PyObject * spice_lstlei(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int x;
  int n;
  int * array;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &x, &n, &array));
  result = lstlei_c(x, n, array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(lstlei_doc, "-Abstract\n\n   Given a number x and an array of non-decreasing numbers,\n   find the index of the largest array element less than or equal\n   to x.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   x          I   Value to search against\n   n          I   Number elements in array\n   array      I   Array of possible lower bounds\n\n   The function returns the index of the last element of array that\n   is less than or equal to x.\n\n-Detailed_Input\n\n   x       Integer.\n\n   n       Total number of elements in array.\n\n   array   Array of integers which forms a non-decreasing sequence.\n           The elements of array need not be distinct.\n\n\n-Detailed_Output\n\n   The function returns the index of the highest-indexed element in the\n   input array that is less than or equal to x.  The routine assumes\n   the array elements are sorted in non-decreasing order.\n\n   Indices range from 0 to n-1.\n\n   If all elements of array are greater than x, this routine returns\n   the value -1.\n\n");

/* SpiceInt lstltd_c ( SpiceDouble x,SpiceInt n,ConstSpiceDouble * array ); */
static PyObject * spice_lstltd(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double x;
  int n;
  double * array;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "did", &x, &n, &array));
  result = lstltd_c(x, n, array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(lstltd_doc, "-Abstract\n\n   Given a number x and an array of non-decreasing numbers,\n   find the index of the largest array element less than x.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   x          I   Value to search against\n   n          I   Number elements in array\n   array      I   Array of possible lower bounds\n\n   The function returns the index of the last element of array that\n   is less than x.\n\n-Detailed_Input\n\n   x       Double precision number.\n\n   n       Total number of elements in array.\n\n   array   Array of double precision numbers which forms a\n           non-decreasing sequence.  The elements of array need not be\n           distinct.\n\n\n-Detailed_Output\n\n   The function returns the index of the highest-indexed element in the\n   input array that is less than x.  The routine assumes the array elements\n   are sorted in non-decreasing order.\n\n   Indices range from 0 to n-1.\n\n   If all elements of the input array are greater than or equal to x,\n   the function returns -1.\n\n");

/* SpiceInt lstlti_c ( SpiceInt x,SpiceInt n,ConstSpiceInt * array ); */
static PyObject * spice_lstlti(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int x;
  int n;
  int * array;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iii", &x, &n, &array));
  result = lstlti_c(x, n, array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(lstlti_doc, "-Abstract\n\n   Given a number x and an array of non-decreasing numbers,\n   find the index of the largest array element less than x.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   x          I   Value to search against.\n   n          I   Number of elements in array.\n   array      I   Array of possible lower bounds.\n\n   The function returns the index of the last element of array that is\n   less than x.\n\n-Detailed_Input\n\n   x              is an integer serving as a key value.\n\n   n              is the total number of elements in array.\n\n   array          is an array of integers that forms a  non-decreasing\n                  sequence.\n\n-Detailed_Output\n\n   The function returns the index of the last element of the non-decreasing\n   sequence\n\n      {array[i] : 0 <=  i < n }\n\n   that is less than x.  Indices range from zero to n-1.\n\n   If all elements of array are greater than or equal to x, this routine\n   returns the value -1.\n\n");

/* void ltime_c ( SpiceDouble etobs,SpiceInt obs,ConstSpiceChar * dir,
SpiceInt targ,SpiceDouble * ettarg,SpiceDouble * elapsd ); */
static PyObject * spice_ltime(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble ettarg;
  SpiceDouble elapsd;
  /* variables for inputs */
  double etobs;
  int obs;
  char * dir;
  int targ;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "disi", &etobs, &obs, &dir, &targ));
  ltime_c(etobs, obs, dir, targ, &ettarg, &elapsd);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, ettarg, elapsd);
  return returnVal;
}
PyDoc_STRVAR(ltime_doc, "-Abstract\n\n   This routine computes the transmit (or receive) time\n   of a signal at a specified target, given the receive\n   (or transmit) time at a specified observer. The elapsed\n   time between transmit and receive is also returned.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    etobs      I   Epoch of a signal at some observer\n    obs        I   NAIF ID of some observer\n    dir        I   Direction the signal travels ( \"->\" or \"<-\" )\n    targ       I   NAIF ID of the target object\n    ettarg     O   Epoch of the signal at the target\n    elapsd     O   Time between transmit and receipt of the signal\n\n-Detailed_Input\n\n   etobs       is an epoch expressed in ephemeris seconds (TDB)\n               past the epoch of the J2000 reference system.\n               This is the time at which an electromagnetic\n               signal is \"at\" the observer.\n\n   obs         is the NAIF ID of some observer.\n\n   dir         is the direction the signal travels.  The\n               acceptable values are \"->\" and \"<-\".  When\n               you read the calling sequence from left to\n               right, the \"arrow\" given by DIR indicates\n               which way the electromagnetic signal is traveling.\n\n               If the argument list reads as below,\n\n                ..., obs, \"->\", targ, ...\n\n               the signal is traveling from the observer to the\n               target.\n\n               If the argument reads as\n\n                ..., obs, \"<-\", targ\n\n               the signal is traveling from the target to\n               the observer.\n\n   targ        is the NAIF ID of the target.\n\n-Detailed_Output\n\n   ettarg      is the epoch, expressed in ephemeris seconds\n               past J2000 TDB, at which the electromagnetic signal is\n               \"at\" the target body.\n\n               Note ettarg is computed using only Newtonian\n               assumptions about the propagation of light.\n\n   elapsd      is the number of ephemeris seconds (TDB) between\n               transmission and receipt of the signal.\n\n                  elapsd = fabs( etobs - ettarg )\n\n");

/* void lx4dec_c ( ConstSpiceChar * string,SpiceInt first,SpiceInt * last,
SpiceInt * nchar ); */
static PyObject * spice_lx4dec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt last;
  SpiceInt nchar;
  /* variables for inputs */
  char * string;
  int first;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &string, &first));
  lx4dec_c(string, first, &last, &nchar);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, last, nchar);
  return returnVal;
}
PyDoc_STRVAR(lx4dec_doc, "-Abstract\n\n   Scan a string from a specified starting position for the\n   end of a decimal number.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   string     I   Any character string.\n   first      I   First character to scan from in string.\n   last       O   Last character that is part of a decimal number.\n   nchar      O   Number of characters in the decimal number.\n\n-Detailed_Input\n\n   string      is any character string.\n\n   first       is the location in the string to beginning scanning\n               for a decimal number.  It is assumed that the\n               decimal number begins at first.\n\n               The normal range of first is 0 : strlen(string)-1.\n\n-Detailed_Output\n\n   last        is the last character at or after first such that the\n               substring ranging from string[first] through\n               string[last] is a decimal number.  If there is no such\n               substring, last will be returned with the value first-1.\n\n               If a decimal number is found, last will be in the\n               range is 0 : strlen(string)-1.\n\n\n   nchar       is the number of characters in the decimal number that\n               begins at index first and ends at last.  If there is no\n               such string nchar will be given the value 0.\n\n");

/* void lx4num_c ( ConstSpiceChar * string,SpiceInt first,SpiceInt * last,
SpiceInt * nchar ); */
static PyObject * spice_lx4num(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt last;
  SpiceInt nchar;
  /* variables for inputs */
  char * string;
  int first;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &string, &first));
  lx4num_c(string, first, &last, &nchar);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, last, nchar);
  return returnVal;
}
PyDoc_STRVAR(lx4num_doc, "-Abstract\n\n   Scan a string from a specified starting position for the\n   end of a number.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   string     I   Any character string.\n   first      I   First character to scan from in string.\n   last       O   Last character that is part of a number.\n   nchar      O   Number of characters in the number.\n\n-Detailed_Input\n\n   string      is any character string.\n\n   first       is the location in the string to beginning scanning\n               for a number.  It is assumed that the\n               number begins at first.\n\n               The normal range of first is 0 : strlen(string)-1.\n\n-Detailed_Output\n\n   last        is the last character at or after first such that the\n               substring ranging from string[first] through\n               string[last] is a number.  If there is no such\n               substring, last will be returned with the value first-1.\n\n               If a number is found, last will be in the\n               range is 0 : strlen(string)-1.\n\n\n   nchar       is the number of characters in the number that\n               begins at index first and ends at last.  If there is no\n               such string nchar will be given the value 0.\n\n");

/* void lx4sgn_c ( ConstSpiceChar * string,SpiceInt first,SpiceInt * last,
SpiceInt * nchar ); */
static PyObject * spice_lx4sgn(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt last;
  SpiceInt nchar;
  /* variables for inputs */
  char * string;
  int first;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &string, &first));
  lx4sgn_c(string, first, &last, &nchar);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, last, nchar);
  return returnVal;
}
PyDoc_STRVAR(lx4sgn_doc, "-Abstract\n\n   Scan a string from a specified starting position for the\n   end of a signed integer.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   string     I   Any character string.\n   first      I   First character to scan from in string.\n   last       O   Last character that is part of a signed integer.\n   nchar      O   Number of characters in the signed integer.\n\n-Detailed_Input\n\n   string      is any character string.\n\n   first       is the location in the string to beginning scanning\n               for a signed integer.  It is assumed that the\n               signed integer begins at first.\n\n               The normal range of first is 0 : strlen(string)-1.\n\n-Detailed_Output\n\n   last        is the last character at or after first such that the\n               substring ranging from string[first] through\n               string[last] is a signed integer.  If there is no such\n               substring, last will be returned with the value first-1.\n\n               If a signed integer is found, last will be in the\n               range is 0 : strlen(string)-1.\n\n\n   nchar       is the number of characters in the signed integer that\n               begins at index first and ends at last.  If there is no\n               such string nchar will be given the value 0.\n\n");

/* void lx4uns_c ( ConstSpiceChar * string,SpiceInt first,SpiceInt * last,
SpiceInt * nchar ); */
static PyObject * spice_lx4uns(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt last;
  SpiceInt nchar;
  /* variables for inputs */
  char * string;
  int first;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &string, &first));
  lx4uns_c(string, first, &last, &nchar);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, last, nchar);
  return returnVal;
}
PyDoc_STRVAR(lx4uns_doc, "-Abstract\n\n   Scan a string from a specified starting position for the\n   end of an unsigned integer.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   string     I   Any character string.\n   first      I   First character to scan from in string.\n   last       O   Last character that is part of an unsigned integer.\n   nchar      O   Number of characters in the unsigned integer.\n\n-Detailed_Input\n\n   string      is any character string.\n\n   first       is the location in the string to beginning scanning\n               for an unsigned integer.  It is assumed that the\n               unsigned integer begins at first.\n\n               The normal range of first is 0 : strlen(string)-1.\n\n-Detailed_Output\n\n   last        is the last character at or after first such that the\n               substring ranging from string[first] through\n               string[last] is an unsigned integer.  If there is no such\n               substring, last will be returned with the value first-1.\n\n               If an unsigned integer is found, last will be in the\n               range is 0 : strlen(string)-1.\n\n\n   nchar       is the number of characters in the unsigned integer that\n               begins at index first and ends at last.  If there is no\n               such string nchar will be given the value 0.\n\n");

/* void lxqstr_c ( ConstSpiceChar * string,SpiceChar qchar,SpiceInt first,
SpiceInt * last,SpiceInt * nchar ); */
static PyObject * spice_lxqstr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt last;
  SpiceInt nchar;
  /* variables for inputs */
  char * string;
  char qchar;
  int first;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &string, &qchar, &first));
  lxqstr_c(string, qchar, first, &last, &nchar);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, last, nchar);
  return returnVal;
}
PyDoc_STRVAR(lxqstr_doc, "-Abstract\n\n   Lex (scan) a quoted string.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   string     I   String to be scanned.\n   qchar      I   Quote delimiter character.\n   first      I   Character position at which to start scanning.\n   last       O   Character position of end of token.\n   nchar      O   Number of characters in token.\n\n-Detailed_Input\n\n   string         is a character string that may contain a \"string\n                  token\" starting at the character position\n                  indicated by the input argument first (see below).\n                  String tokens are sequences of characters that\n                  represent literal strings.  Syntactically, a string\n                  token is a sequence of characters that begins and\n                  ends with a designated \"quote character\".  Within\n                  the token, any occurrence of the quote character\n                  is indicated by an adjacent pair of quote\n                  characters:  for example, if the quote character is\n\n                     \"\n\n                  then the token representing one instance of this\n                  character is\n\n                     \"\"\"\"\n\n                  Here the first quote indicates the beginning of the\n                  token, the next two quotes together indicate a\n                  single quote character that constitutes the\n                  \"contents\" of the token, and the final quote\n                  indicates the end of the token.\n\n   qchar          is the quote character.  This is always a single\n                  character.  The characters\n\n                     \"  and '\n\n                  are common choices, but any non-blank character is\n                  accepted.  Case *is* significant in qchar.\n\n\n   first          is the character position at which the routine\n                  is to start scanning a quoted string token.  Note\n                  that the character string[first] must equal\n                  qchar if a string token is to be found; this\n                  routine does *not* attempt to locate the first\n                  quoted string following the position first.\n\n-Detailed_Output\n\n   last           is the last character position such that the subtring\n                  ranging from string[first] to string[last] is a\n                  quoted string token, if such a substring exists.\n                  Otherwise, the returned value of last is first-1.\n\n   nchar          is the length of the string token found by this\n                  routine, if such a token exists.  This length\n                  includes the starting and ending bracketing quotes.\n                  If a string token is not found, the returned value\n                  of nchar is zero.\n\n");

/* void m2eul_c ( ConstSpiceDouble r[3][3],SpiceInt axis3,SpiceInt axis2,
SpiceInt axis1,SpiceDouble * angle3,SpiceDouble * angle2,
SpiceDouble * angle1 ); */
static PyObject * spice_m2eul(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble angle3;
  SpiceDouble angle2;
  SpiceDouble angle1;
  /* variables for inputs */
  double r[3][3];
  int axis3;
  int axis2;
  int axis1;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))iii", &r[0][0], &r[0][1], &r[0][2], &r[1][0], &r[1][1], &r[1][2], &r[2][0], &r[2][1], &r[2][2], &axis3, &axis2, &axis1));
  m2eul_c(r, axis3, axis2, axis1, &angle3, &angle2, &angle1);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, angle3, angle2, angle1);
  return returnVal;
}
PyDoc_STRVAR(m2eul_doc, "-Abstract\n\n   Factor a rotation matrix as a product of three rotations about\n   specified coordinate axes.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   r          I   A rotation matrix to be factored.\n   axis3,\n   axis2,\n   axis1      I   Numbers of third, second, and first rotation axes.\n   angle3,\n   angle2,\n   angle1     O   Third, second, and first Euler angles, in radians.\n\n-Detailed_Input\n\n   r              is a 3x3 rotation matrix that is to be factored as\n                  a product of three rotations about a specified\n                  coordinate axes.  The angles of these rotations are\n                  called `Euler angles'.\n\n   axis3,\n   axis2,\n   axis1          are the indices of the rotation axes of the\n                  `factor' rotations, whose product is r.  r is\n                  factored as\n\n                     r = [ angle3 ]     [ angle2 ]     [ angle1 ]   .\n                                  axis3          axis2          axis1\n\n                  The axis numbers must belong to the set {1, 2, 3}.\n                  The second axis number MUST differ from the first\n                  and third axis numbers.\n\n                  See the Particulars section below for details\n                  concerning this notation.\n\n-Detailed_Output\n\n   angle3,\n   angle2,\n   angle1         are the Euler angles corresponding to the matrix\n                  r and the axes specified by axis3, axis2, and\n                  axis1.  These angles satisfy the equality\n\n                     r = [ angle3 ]     [ angle2 ]     [ angle1 ]\n                                 axis3           axis2          axis1\n\n\n                  See the Particulars section below for details\n                  concerning this notation.\n\n                  The range of angle3 and angle1 is (-pi, pi].\n\n                  The range of angle2 depends on the exact set of\n                  axes used for the factorization.  For\n                  factorizations in which the first and third axes\n                  are the same,\n\n                     r = [R]  [S]  [T] ,\n                            a    b    a\n\n                  the range of angle2 is [0, pi].\n\n\n                  For factorizations in which the first and third\n                  axes are different,\n\n                     r = [R]  [S]  [T] ,\n                            a    b    c\n\n                  the range of angle2 is [-pi/2, pi/2].\n\n                  For rotations such that angle3 and angle1 are not\n                  uniquely determined, angle3 will always be set to\n                  zero; angle1 is then uniquely determined.\n\n");

/* void m2q_c ( ConstSpiceDouble r[3][3],SpiceDouble q[4] ); */
static PyObject * spice_m2q(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble q[4];
  /* variables for inputs */
  double r[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))", &r[0][0], &r[0][1], &r[0][2], &r[1][0], &r[1][1], &r[1][2], &r[2][0], &r[2][1], &r[2][2]));
  m2q_c(r, q);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, q[0], q[1], q[2], q[3]);
  return returnVal;
}
PyDoc_STRVAR(m2q_doc, "-Abstract\n\n   Find a unit quaternion corresponding to a specified rotation\n   matrix.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   r          I   A rotation matrix.\n   q          O   A unit quaternion representing `r'.\n\n-Detailed_Input\n\n   r              is a rotation matrix.\n\n-Detailed_Output\n\n   q              is a unit-length SPICE-style quaternion representing\n                  `r'. See the discussion of quaternion styles in\n                  Particulars below.\n\n                  `q' is a 4-dimensional vector. If `r' rotates vectors in\n                  the counterclockwise sense by an angle of `theta' radians\n                  about a unit vector `a', where\n\n                     0 < theta < pi\n                       -       -\n\n                  then letting h = theta/2,\n\n                     q = ( cos(h), sin(h)a ,  sin(h)a ,  sin(h)a ).\n                                          1          2          3\n\n                  The restriction that `theta' must be in the range [0, pi]\n                  determines the output quaternion `q' uniquely\n                  except when theta = pi; in this special case, both of\n                  the quaternions\n\n                     q = ( 0,  a ,  a ,  a  )\n                                1    2    3\n                  and\n\n                     q = ( 0, -a , -a , -a  )\n                                1    2    3\n\n                 are possible outputs.\n\n");

/* SpiceBoolean matchi_c ( ConstSpiceChar * string,ConstSpiceChar * templ,
SpiceChar wstr,SpiceChar wchr ); */
static PyObject * spice_matchi(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * string;
  char * templ;
  char wstr;
  char wchr;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssss", &string, &templ, &wstr, &wchr));
  result = matchi_c(string, templ, wstr, wchr);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(matchi_doc, "-Abstract\n\n    Determine whether a string is matched by a template containing\n    wild cards.  The pattern comparison is case-insensitive.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    string     I   String to be tested.\n    templ      I   Template (with wild cards) to test against string.\n    wstr       I   Wild string token.\n    wchr       I   Wild character token.\n\n    The function returns the value SPICETRUE if string matches templ,\n    SPICEFALSE if not.\n\n-Detailed_Input\n\n    string      is the input character string to be tested for\n                a match against the input template. Leading and\n                trailing blanks are ignored.\n\n    templ       is the input template to be tested for a match\n                against the input string. TEMPL may contain wild\n                cards. Leading and trailing blanks are ignored.\n\n    wstr        is the wild string token used in the input template.\n                The wild string token may represent from zero to\n                any number of characters.\n\n    wchr        is the wild character token used in the input\n                template. The wild character token represents\n                exactly one character.\n\n-Detailed_Output\n\n    The function returns SPICETRUE when the input string matches the\n    input template, and SPICEFALSE otherwise. The string and template\n    match whenever the template can expand (through replacement of its\n    wild cards) to become the input string.\n\n");

/* SpiceBoolean matchw_c ( ConstSpiceChar * string,ConstSpiceChar * templ,
SpiceChar wstr,SpiceChar wchr ); */
static PyObject * spice_matchw(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * string;
  char * templ;
  char wstr;
  char wchr;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssss", &string, &templ, &wstr, &wchr));
  result = matchw_c(string, templ, wstr, wchr);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(matchw_doc, "-Abstract\n\n    Determine whether a string is matched by a template containing\n    wild cards.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    string     I   String to be tested.\n    templ      I   Template (with wild cards) to test against string.\n    wstr       I   Wild string token.\n    wchr       I   Wild character token.\n\n    The function returns the value SPICETRUE if string matches templ,\n    SPICEFALSE if not.\n\n-Detailed_Input\n\n    string      is the input character string to be tested for\n                a match against the input template. Leading and\n                trailing blanks are ignored.\n\n    templ       is the input template to be tested for a match\n                against the input string. TEMPL may contain wild\n                cards. Leading and trailing blanks are ignored.\n\n    wstr        is the wild string token used in the input template.\n                The wild string token may represent from zero to\n                any number of characters.\n\n    wchr        is the wild character token used in the input\n                template. The wild character token represents\n                exactly one character.\n\n-Detailed_Output\n\n    The function returns SPICETRUE when the input string matches the\n    input template, and SPICEFALSE otherwise. The string and template\n    match whenever the template can expand (through replacement of its\n    wild cards) to become the input string.\n\n");

/* void mequ_c ( ConstSpiceDouble m1 [3][3],SpiceDouble mout[3][3] ); */
static PyObject * spice_mequ(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[3][3];
  /* variables for inputs */
  double m1[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2]));
  mequ_c(m1, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[1][0], mout[1][1], mout[1][2], mout[2][0], mout[2][1], mout[2][2]);
  return returnVal;
}
PyDoc_STRVAR(mequ_doc, "-Abstract\n\n   Set one double precision 3x3 matrix equal to another.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    m1         I     Input matrix.\n    mout       O     Output matrix equal to m1.\n\n-Detailed_Input\n\n    m1      This is an arbitrary input 3x3 matrix.  There are no\n            restrictions on what it may contain.\n\n-Detailed_Output\n\n    mout    This 3x3 matrix is set to be equal to m1.\n\n");

/* void mtxm_c ( ConstSpiceDouble m1 [3][3],ConstSpiceDouble m2 [3][3],
SpiceDouble mout[3][3] ); */
static PyObject * spice_mtxm(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[3][3];
  /* variables for inputs */
  double m1[3][3];
  double m2[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))((ddd)(ddd)(ddd))", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2], &m2[0][0], &m2[0][1], &m2[0][2], &m2[1][0], &m2[1][1], &m2[1][2], &m2[2][0], &m2[2][1], &m2[2][2]));
  mtxm_c(m1, m2, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[1][0], mout[1][1], mout[1][2], mout[2][0], mout[2][1], mout[2][2]);
  return returnVal;
}
PyDoc_STRVAR(mtxm_doc, "-Abstract\n\n   Multiply the transpose of a 3x3 matrix and a 3x3 matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   m1         I   3x3 double precision matrix.\n   m2         I   3x3 double precision matrix.\n   mout       O   The produce m1 transpose times m2.\n\n-Detailed_Input\n\n   m1         is any 3x3 double precision matrix. Typically,\n              m1 will be a rotation matrix since then its\n              transpose is its inverse (but this is not a\n              requirement).\n\n   m2         is any 3x3 double precision matrix.\n\n-Detailed_Output\n\n   mout       is a 3x3 double precision matrix. mout is the\n              product\n\n                          t\n                 mout = m1  m2\n\n              mout may overwrite either m1 or m2.\n\n");

/* void mtxv_c ( ConstSpiceDouble m1 [3][3],ConstSpiceDouble vin [3],
SpiceDouble vout[3] ); */
static PyObject * spice_mtxv(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double m1[3][3];
  double vin[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))(ddd)", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2], &vin[0], &vin[1], &vin[2]));
  mtxv_c(m1, vin, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(mtxv_doc, "-Abstract\n\n   mtxv_c multiplies the transpose of a 3x3 matrix on the left with\n   a vector on the right.\n\n-Brief_I/O\n\n   VARIABLE  I/O              DESCRIPTION\n   --------  ---  --------------------------------------------------\n   m1         I   3x3 double precision matrix.\n   vin        I   3-dimensional double precision vector.\n   vout       O   3-dimensional double precision vector. vout is\n                  the product m1**t * vin.\n\n-Detailed_Input\n\n   m1         is an arbitrary 3x3 double precision matrix.\n              typically, m1 will be a rotation matrix since\n              then its transpose is its inverse (but this is NOT\n              a requirement).\n\n   vin        is an arbitrary 3-dimensional double precision\n              vector.\n\n-Detailed_Output\n\n   vout       is a 3-dimensional double precision vector. vout is\n              the product vout = (m1**t)  x (vin). vout can\n              overwrite vin.\n\n");

/* void mxm_c ( ConstSpiceDouble m1 [3][3],ConstSpiceDouble m2 [3][3],
SpiceDouble mout[3][3] ); */
static PyObject * spice_mxm(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[3][3];
  /* variables for inputs */
  double m1[3][3];
  double m2[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))((ddd)(ddd)(ddd))", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2], &m2[0][0], &m2[0][1], &m2[0][2], &m2[1][0], &m2[1][1], &m2[1][2], &m2[2][0], &m2[2][1], &m2[2][2]));
  mxm_c(m1, m2, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[1][0], mout[1][1], mout[1][2], mout[2][0], mout[2][1], mout[2][2]);
  return returnVal;
}
PyDoc_STRVAR(mxm_doc, "-Abstract\n\n   Multiply two 3x3 matrices.\n\n-Brief_I/O\n\n   VARIABLE  I/O              DESCRIPTION\n   --------  ---  --------------------------------------------------\n   m1        i   3x3 double precision matrix.\n   m2        i   3x3 double precision matrix.\n   mout      o   3x3 double precision matrix. mout is the product\n                 m1*m2.\n\n-Detailed_Input\n\n   m1         is an arbitrary 3x3 double precision matrix.\n\n   m2         is an arbitrary 3x3 double precision matrix.\n\n-Detailed_Output\n\n   mout       is a 3x3 double precision matrix. mout is the product\n              m1*m2. mout may overwrite either m1 or m2.\n\n");

/* void mxmt_c ( ConstSpiceDouble m1 [3][3],ConstSpiceDouble m2 [3][3],
SpiceDouble mout[3][3] ); */
static PyObject * spice_mxmt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[3][3];
  /* variables for inputs */
  double m1[3][3];
  double m2[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))((ddd)(ddd)(ddd))", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2], &m2[0][0], &m2[0][1], &m2[0][2], &m2[1][0], &m2[1][1], &m2[1][2], &m2[2][0], &m2[2][1], &m2[2][2]));
  mxmt_c(m1, m2, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[1][0], mout[1][1], mout[1][2], mout[2][0], mout[2][1], mout[2][2]);
  return returnVal;
}
PyDoc_STRVAR(mxmt_doc, "-Abstract\n\n    Multiply a 3x3 matrix and the transpose of another 3x3 matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   m1         I   3x3 double precision matrix.\n   m2         I   3x3 double precision matrix.\n   mout       O   The product m1 times m2 transpose .\n\n-Detailed_Input\n\n   m1         is an arbitrary 3x3 double precision matrix.\n\n   m2         is an arbitrary 3x3 double precision matrix.\n              Typically, m2 will be a rotation matrix since\n              then its transpose is its inverse (but this is\n              NOT a requirement).\n\n-Detailed_Output\n\n   mout       is a 3x3 double precision matrix. mout is the\n              product\n\n                              t\n                 mout = m1  m2\n\n              mout may overwrite either m1 or m2.\n\n");

/* void mxv_c ( ConstSpiceDouble m1[3][3],ConstSpiceDouble vin[3],
SpiceDouble vout[3] ); */
static PyObject * spice_mxv(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double m1[3][3];
  double vin[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))(ddd)", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2], &vin[0], &vin[1], &vin[2]));
  mxv_c(m1, vin, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(mxv_doc, "-Abstract\n\n   Multiply a 3x3 double precision matrix with a 3-dimensional\n   double precision vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O              DESCRIPTION\n   --------  ---  --------------------------------------------------\n   m1        I   3x3 double precision matrix.\n   vin       I   3-dimensional double precision vector.\n   vout      O   3-dimensinoal double precision vector. vout is\n                 the product m1*vin.\n\n-Detailed_Input\n\n   m1         is an arbitrary 3x3 double precision matrix.\n\n   vin        is an arbitrary 3-dimensional double precision vector.\n\n-Detailed_Output\n\n   vout       is a 3-dimensional double precision vector. vout is\n              the product m1 * v. vout may overwrite vin.\n\n");

/* void namfrm_c ( ConstSpiceChar * frname,SpiceInt * frcode ); */
static PyObject * spice_namfrm(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt frcode;
  /* variables for inputs */
  char * frname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &frname));
  namfrm_c(frname, &frcode);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, frcode);
  return returnVal;
}
PyDoc_STRVAR(namfrm_doc, "-Abstract\n\n   Look up the frame ID code associated with a string.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   frname     I   The name of some reference frame.\n   frcode     O   The SPICE ID code of the frame.\n\n-Detailed_Input\n\n   frname      is a character string that stands for some\n               reference frame (either inertial or non-inertial).\n\n               Leading blanks in frname are ignored.  The\n               case of the letters in frname are insignificant.\n\n               Note that all legitimate frame names contain\n               32 or fewer characters.\n\n-Detailed_Output\n\n   frcode      is the SPICE integer code used for internal\n               representation of the named reference frame.\n\n               If the name input through frname is not recognized,\n               frcode will be returned with a value of zero.\n\n");

/* SpiceInt ncpos_c ( ConstSpiceChar * str,ConstSpiceChar * chars,
SpiceInt start ); */
static PyObject * spice_ncpos(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * str;
  char * chars;
  int start;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &str, &chars, &start));
  result = ncpos_c(str, chars, start);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(ncpos_doc, "-Abstract\n\n   Find the first occurrence in a string of a character NOT belonging\n   to a collection of characters, starting at a specified location,\n   searching forward.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   str        I   Any character string.\n   chars      I   A collection of characters.\n   start      I   Position to begin looking for one not in chars.\n\n   The function returns the index of the first character of str\n   at or following index start that is not in the collection chars.\n\n-Detailed_Input\n\n   str        is any character string.\n\n   chars      is a character string containing a collection of\n              characters.  Spaces in chars are significant, including\n              trailing blanks.  The order in which characters are\n              listed is not significant.\n\n   start      is the position in str to begin looking for characters\n              not in chars.  start may range from 0 to n-1, where n is\n              the number of characters in str.\n\n-Detailed_Output\n\n   The function returns the index of the first character of str (at or\n   following index start) that is not one of the characters in the\n   string chars.  The returned value normally ranges from 0 to n-1,\n   where n is the number of characters in str. If no such character is\n   found, the function returns -1.\n\n");

/* SpiceInt ncposr_c ( ConstSpiceChar * str,ConstSpiceChar * chars,
SpiceInt start ); */
static PyObject * spice_ncposr(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * str;
  char * chars;
  int start;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &str, &chars, &start));
  result = ncposr_c(str, chars, start);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(ncposr_doc, "-Abstract\n\n   Find the first occurrence in a string of a character NOT belonging\n   to a collection of characters, starting at a specified location,\n   searching in reverse.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   str        I   Any character string.\n   chars      I   A collection of characters.\n   start      I   Position to begin looking for one of chars.\n\n   The function returns the index of the last character of str\n   at or before index start that is not in the collection chars.\n\n-Detailed_Input\n\n   str        is any character string.\n\n   chars      is a character string containing a collection\n              of characters.  Spaces in chars are significant,\n              including trailing blanks.  The order in which\n              characters are listed is not significant.\n\n   start      is the position in str to begin looking for one of\n              the characters in chars.  start may range from 0\n              to n-1, where n is the number of characters in str.\n\n-Detailed_Output\n\n   The function returns the index of the last character of str (at or\n   before index start) that is not one of the characters in the string\n   chars.  The returned value normally ranges from 0 to n-1, where n is\n   the number of characters in str. If none of the characters is found,\n   the function returns -1.\n\n");

/* void nearpt_c ( ConstSpiceDouble positn[3],SpiceDouble a,SpiceDouble b,
SpiceDouble c,SpiceDouble npoint[3],SpiceDouble * alt ); */
static PyObject * spice_nearpt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble npoint[3];
  SpiceDouble alt;
  /* variables for inputs */
  double positn[3];
  double a;
  double b;
  double c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)ddd", &positn[0], &positn[1], &positn[2], &a, &b, &c));
  nearpt_c(positn, a, b, c, npoint, &alt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, npoint[0], npoint[1], npoint[2], alt);
  return returnVal;
}
PyDoc_STRVAR(nearpt_doc, "-Abstract\n\n   This routine locates the point on the surface of an ellipsoid\n   that is nearest to a specified position. It also returns the\n   altitude of the position above the ellipsoid.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   positn     I   Position of a point in bodyfixed frame.\n   a          I   Length of semi-axis parallel to x-axis.\n   b          I   Length of semi-axis parallel to y-axis.\n   c          I   Length on semi-axis parallel to z-axis.\n   npoint     O   Point on the ellipsoid closest to positn.\n   alt        O   Altitude of positn above the ellipsoid.\n\n-Detailed_Input\n\n   positn     3-vector giving the position of a point with respect to\n              the center of an ellipsoid. The vector is expressed in a\n              body-fixed reference frame. The semi-axes of the\n              ellipsoid are aligned with the x, y, and z-axes of the\n              body-fixed frame.\n\n   a          is the length of the semi-axis of the ellipsoid that is\n              parallel to the x-axis of the bodyfixed coordinate\n              system.\n\n   b          is the length of the semi-axis of the ellipsoid that is\n              parallel to the y-axis of the bodyfixed coordinate\n              system.\n\n   c          is the length of the semi-axis of the ellipsoid that is\n              parallel to the z-axis of the bodyfixed coordinate\n              system.\n\n-Detailed_Output\n\n   npoint     is the nearest point on the ellipsoid to `positn'.\n              `npoint' is a 3-vector expressed in the body-fixed\n              reference frame.\n\n   alt        is the altitude of `positn' above the ellipsoid. If\n              `positn' is inside the ellipsoid, `alt' will be negative\n              and have magnitude equal to the distance between `npoint'\n              and `positn'.\n\n");

/* void npedln_c ( SpiceDouble a,SpiceDouble b,SpiceDouble c,
ConstSpiceDouble linept[3],ConstSpiceDouble linedr[3],SpiceDouble pnear[3],
SpiceDouble * dist ); */
static PyObject * spice_npedln(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble pnear[3];
  SpiceDouble dist;
  /* variables for inputs */
  double a;
  double b;
  double c;
  double linept[3];
  double linedr[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd(ddd)(ddd)", &a, &b, &c, &linept[0], &linept[1], &linept[2], &linedr[0], &linedr[1], &linedr[2]));
  npedln_c(a, b, c, linept, linedr, pnear, &dist);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, pnear[0], pnear[1], pnear[2], dist);
  return returnVal;
}
PyDoc_STRVAR(npedln_doc, "-Abstract\n\n   Find nearest point on a triaxial ellipsoid to a specified line,\n   and the distance from the ellipsoid to the line.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   a          I   Length of ellipsoid's semi-axis in the x direction\n   b          I   Length of ellipsoid's semi-axis in the y direction\n   c          I   Length of ellipsoid's semi-axis in the z direction\n   linept     I   Point on line\n   linedr     I   Direction vector of line\n   pnear      O   Nearest point on ellipsoid to line\n   dist       O   Distance of ellipsoid from line\n\n-Detailed_Input\n\n   a,\n   b,\n   c              are the lengths of the semi-axes of a triaxial\n                  ellipsoid which is centered at the origin and\n                  oriented so that its axes lie on the x-, y- and\n                  z- coordinate axes.  a, b, and c are the lengths of\n                  the semi-axes that point in the x, y, and z\n                  directions respectively.\n\n   linept\n   linedr         are, respectively, a point and a direction vector\n                  that define a line.  The line is the set of vectors\n\n                     linept   +   t * linedr\n\n                  where t is any real number.\n\n-Detailed_Output\n\n   pnear          is the point on the ellipsoid that is closest to\n                  the line, if the line doesn't intersect the\n                  ellipsoid.\n\n                  If the line intersects the ellipsoid, pnear will\n                  be a point of intersection.  If linept is outside\n                  of the ellipsoid, pnear will be the closest point\n                  of intersection.  If linept is inside the\n                  ellipsoid, pnear will not necessarily be the\n                  closest point of intersection.\n\n\n   dist           is the distance of the line from the ellipsoid.\n                  This is the minimum distance between any point on\n                  the line and any point on the ellipsoid.\n\n                  If the line intersects the ellipsoid, dist is zero.\n\n");

/* void npelpt_c ( ConstSpiceDouble point[3],ConstSpiceEllipse * ellips,
SpiceDouble pnear[3],SpiceDouble * dist ); */
static PyObject * spice_npelpt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble pnear[3];
  SpiceDouble dist;
  /* variables for inputs */
  double point[3];
  ConstSpiceEllipse * ellips;
  PyObject * py_ellips = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)O", &point[0], &point[1], &point[2], &py_ellips));
  ellips = get_spice_ellipse(py_ellips);

  npelpt_c(point, ellips, pnear, &dist);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, pnear[0], pnear[1], pnear[2], dist);
  return returnVal;
}
PyDoc_STRVAR(npelpt_doc, "-Abstract\n\n   Find the nearest point on an ellipse to a specified point, both\n   in three-dimensional space, and find the distance between the\n   ellipse and the point.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   point      I   Point whose distance to an ellipse is to be found.\n   ellips     I   A CSPICE ellipse.\n   pnear      O   Nearest point on ellipse to input point.\n   dist       O   Distance of input point to ellipse.\n\n-Detailed_Input\n\n   ellips         is a CSPICE ellipse that represents an ellipse\n                  in three-dimensional space.\n\n   point          is a point in 3-dimensional space.\n\n-Detailed_Output\n\n   pnear          is the nearest point on ellips to point.\n\n   dist           is the distance between point and pnear.  This is\n                  the distance between point and the ellipse.\n\n");

/* void nplnpt_c ( ConstSpiceDouble linpt [3],ConstSpiceDouble lindir [3],
ConstSpiceDouble point [3],SpiceDouble pnear [3],SpiceDouble * dist ); */
static PyObject * spice_nplnpt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble pnear[3];
  SpiceDouble dist;
  /* variables for inputs */
  double linpt[3];
  double lindir[3];
  double point[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)(ddd)", &linpt[0], &linpt[1], &linpt[2], &lindir[0], &lindir[1], &lindir[2], &point[0], &point[1], &point[2]));
  nplnpt_c(linpt, lindir, point, pnear, &dist);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, pnear[0], pnear[1], pnear[2], dist);
  return returnVal;
}
PyDoc_STRVAR(nplnpt_doc, "-Abstract\n\n   Find the nearest point on a line to a specified point, and find\n   the distance between the two points.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   linpt,\n   lindir     I   Point on a line and the line's direction vector.\n   point      I   A second point.\n   pnear      O   Nearest point on the line to point.\n   dist       O   Distance between point and pnear.\n\n-Detailed_Input\n\n   linpt\n   lindir         are, respectively, a point and a direction vector\n                  that define a line in 3-dimensional space.  The\n                  line is the set of points\n\n                     linpt   +   t * lindir\n\n                  where t is any real number.\n\n   point          is a point in 3-dimensional space.\n\n-Detailed_Output\n\n   pnear          is the nearest point on the input line to the input\n                  point.\n\n   dist           is the distance between the input line and input\n                  point.\n\n");

/* void nvc2pl_c ( ConstSpiceDouble normal[3],SpiceDouble constant,
SpicePlane * plane ); */
static PyObject * spice_nvc2pl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpicePlane plane;
  /* variables for inputs */
  double normal[3];
  double constant;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)d", &normal[0], &normal[1], &normal[2], &constant));
  nvc2pl_c(normal, constant, &plane);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_plane(&plane));
  return returnVal;
}
PyDoc_STRVAR(nvc2pl_doc, "-Abstract\n\n   Make a CSPICE plane from a normal vector and a constant.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   normal,\n   constant   I   A normal vector and constant defining a plane.\n   plane      O   A CSPICE plane structure representing the plane.\n\n-Detailed_Input\n\n   normal,\n   constant       are, respectively, a normal vector and constant\n                  defining a plane.  normal need not be a unit vector.\n                  Let the symbol < a, b > indicate the inner product of\n                  vectors a and b; then the geometric plane is the set\n                  of vectors x in three-dimensional space that satisfy\n\n                     < x,  normal >  =  constant.\n\n-Detailed_Output\n\n   plane          is a CSPICE plane structure that represents the\n                  geometric plane defined by normal and constant.\n\n");

/* void nvp2pl_c ( ConstSpiceDouble normal[3],ConstSpiceDouble point[3],
SpicePlane * plane ); */
static PyObject * spice_nvp2pl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpicePlane plane;
  /* variables for inputs */
  double normal[3];
  double point[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &normal[0], &normal[1], &normal[2], &point[0], &point[1], &point[2]));
  nvp2pl_c(normal, point, &plane);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_plane(&plane));
  return returnVal;
}
PyDoc_STRVAR(nvp2pl_doc, "-Abstract\n\n   Make a CSPICE plane from a normal vector and a point.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   normal,\n   point      I   A normal vector and a point defining a plane.\n   plane      O   A CSPICE plane structure representing the plane.\n\n-Detailed_Input\n\n   normal,\n   point\n                  are, respectively, a normal vector and point that\n                  define a plane in three-dimensional space.  normal\n                  need not be a unit vector. Let the symbol < a, b >\n                  indicate the inner product of vectors a and b;\n                  then the geometric plane is the set of vectors x\n                  in three-dimensional space that satisfy\n\n                     < x - point, normal >  =  0.\n\n-Detailed_Output\n\n   plane          is a CSPICE plane structure that represents the\n                  geometric plane defined by point and normal.\n\n");

/* SpiceInt ordc_c ( ConstSpiceChar * item,SpiceCell * set ); */
static PyObject * spice_ordc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  char * item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &item));
  result = ordc_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(ordc_doc, "-Abstract\n\n   The function returns the ordinal position of any given item in a\n   character set.  If the item does not appear in the set, the function\n   returns -1.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   An item to locate within a set.\n   set        I   A set to search for a given item.\n\n   The function returns the ordinal position of item within the set.\n\n-Detailed_Input\n\n   item      is a character string to be located within a set.\n             Trailing blanks are not significant in the comparison.\n\n\n   set       is an integer CSPICE set that is to be searched for the\n             occurrence of item.  Trailing blanks are not significant\n             in the comparison.\n\n             set must be declared as a character SpiceCell.\n\n-Detailed_Output\n\n   The function returns the ordinal position of item within set.\n   Ordinal positions range from 0 to N-1, where N is the cardinality\n   of the set.\n\n   If item is not an element of set, the function returns -1.\n\n");

/* SpiceInt ordd_c ( SpiceDouble item,SpiceCell * set ); */
static PyObject * spice_ordd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  double item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &item));
  result = ordd_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(ordd_doc, "-Abstract\n\n   The function returns the ordinal position of any given item in a\n   double precision set.  If the item does not appear in the set, the\n   function returns -1.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   An item to locate within a set.\n   set        I   A set to search for a given item.\n\n   The function returns the ordinal position of item within the set.\n\n-Detailed_Input\n\n   item      is a double precision number to be located within a set.\n\n   set       is a double precision CSPICE set that is to be searched\n             for the occurrence of item.\n\n             set must be declared as a double precision SpiceCell.\n\n-Detailed_Output\n\n   The function returns the ordinal position of item within set.\n   Ordinal positions range from 0 to N-1, where N is the cardinality\n   of the set.\n\n   If item is not an element of set, the function returns -1.\n\n");

/* SpiceInt ordi_c ( SpiceInt item,SpiceCell * set ); */
static PyObject * spice_ordi(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  int item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &item));
  result = ordi_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(ordi_doc, "-Abstract\n\n   The function returns the ordinal position of any given item in an\n   integer set.  If the item does not appear in the set, the function\n   returns -1.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   An item to locate within a set.\n   set        I   A set to search for a given item.\n\n   The function returns the ordinal position of item within the set.\n\n-Detailed_Input\n\n   item      is an integer to be located within a set.\n\n   set       is an integer CSPICE set that is to be searched for the\n             occurrence of item.\n\n             set must be declared as an integer SpiceCell.\n\n-Detailed_Output\n\n   The function returns the ordinal position of item within set.\n   Ordinal positions range from 0 to N-1, where N is the cardinality\n   of the set.\n\n   If item is not an element of set, the function returns -1.\n\n");

/* void orderd_c ( ConstSpiceDouble * array,SpiceInt ndim,
SpiceInt * iorder ); */
static PyObject * spice_orderd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt iorder;
  /* variables for inputs */
  double * array;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "di", &array, &ndim));
  orderd_c(array, ndim, &iorder);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, iorder);
  return returnVal;
}
PyDoc_STRVAR(orderd_doc, "-Abstract\n\n   Determine the order of elements in a double precision array.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   array      I   Input array.\n   ndim       I   Dimension of array.\n   iorder     O   Order vector for array.\n\n-Detailed_Input\n\n   array       is the input array.\n\n   ndim        is the number of elements in the input array.\n\n-Detailed_Output\n\n   iorder      is the order vector for the input array.\n               iorder[0] is the index of the smallest element\n               of array; iorder[1] is the index of the next\n               smallest; and so on.\n\n               The elements of iorder range from zero to ndim-1.\n");

/* void orderi_c ( ConstSpiceInt * array,SpiceInt ndim,SpiceInt * iorder ); */
static PyObject * spice_orderi(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt iorder;
  /* variables for inputs */
  int * array;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &array, &ndim));
  orderi_c(array, ndim, &iorder);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, iorder);
  return returnVal;
}
PyDoc_STRVAR(orderi_doc, "-Abstract\n\n   Determine the order of elements in an integer array.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   array      I    Input array.\n   ndim       I    Dimension of array.\n   iorder     O    Order vector for array.\n\n-Detailed_Input\n\n   array       is the input array.\n\n   ndim        is the number of elements in the input array.\n\n-Detailed_Output\n\n   iorder      is the order vector for the input array.\n               iorder[0] is the index of the smallest element\n               of array; iorder[1] is the index of the next\n               smallest; and so on.\n\n               The elements of iorder range from zero to ndim-1.\n\n");

/* void oscelt_c ( ConstSpiceDouble state[6],SpiceDouble et ,SpiceDouble mu ,
SpiceDouble elts[8] ); */
static PyObject * spice_oscelt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble elts[8];
  /* variables for inputs */
  double state[6];
  double et;
  double mu;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddd)dd", &state[0], &state[1], &state[2], &state[3], &state[4], &state[5], &et, &mu));
  oscelt_c(state, et, mu, elts);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, elts[0], elts[1], elts[2], elts[3], elts[4], elts[5], elts[6], elts[7]);
  return returnVal;
}
PyDoc_STRVAR(oscelt_doc, "-Abstract\n\n   Determine the set of osculating conic orbital elements that\n   corresponds to the state (position, velocity) of a body at\n   some epoch.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   state      I   State of body at epoch of elements.\n   et         I   Epoch of elements.\n   mu         I   Gravitational parameter (GM) of primary body.\n   elts       O   Equivalent conic elements\n\n\n-Detailed_Input\n\n   state      is the state (position and velocity) of the body\n              at some epoch. Components are x, y, z, dx/dt, dy/dt,\n              dz/dt. `state' must be expressed relative to an\n              inertial reference frame.  Units are km and km/sec.\n\n\n   et         is the epoch of the input state, in ephemeris seconds\n              past J2000.\n\n                                                    3    2\n   mu         is the gravitational parameter (GM, km /sec ) of\n              the primary body.\n\n-Detailed_Output\n\n   elts       are equivalent conic elements describing the orbit\n              of the body around its primary. The elements are,\n              in order:\n\n                    rp      Perifocal distance.\n                    ecc     Eccentricity.\n                    inc     Inclination.\n                    lnode   Longitude of the ascending node.\n                    argp    Argument of periapsis.\n                    m0      Mean anomaly at epoch.\n                    t0      Epoch.\n                    mu      Gravitational parameter.\n\n              The epoch of the elements is the epoch of the input\n              state. Units are km, rad, rad/sec. The same elements\n              are used to describe all three types (elliptic,\n              hyperbolic, and parabolic) of conic orbit.\n\n");

/* void pckcov_c ( ConstSpiceChar * pck,SpiceInt idcode,SpiceCell * cover ); */
static PyObject * spice_pckcov(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cover;
  /* variables for inputs */
  char * pck;
  int idcode;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &pck, &idcode));
  pckcov_c(pck, idcode, &cover);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cover));
  return returnVal;
}
PyDoc_STRVAR(pckcov_doc, "-Abstract\n\n   Find the coverage window for a specified reference frame in a\n   specified binary PCK file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   pck        I   Name of PCK file.\n   idcode     I   Class ID code of PCK reference frame.\n   cover     I/O  Window giving coverage in `pck' for `idcode'.\n\n-Detailed_Input\n\n   pck            is the name of a binary PCK file.\n\n   idcode         is the integer frame class ID code of a PCK reference\n                  frame for which data are expected to exist in the\n                  specified PCK file.\n\n   cover          is an initialized CSPICE window data structure.\n                  `cover' optionally may contain coverage data on\n                  input; on output, the data already present in `cover'\n                  will be combined with coverage found for the\n                  reference frame designated by `idcode' in the file\n                  `pck'.\n\n                  If `cover' contains no data on input, its size and\n                  cardinality still must be initialized.\n\n-Detailed_Output\n\n   cover          is a CSPICE window data structure which represents\n                  the merged coverage for the reference frame having\n                  frame class ID `idcode'. This is the set of time\n                  intervals for which data for `idcode' are present in\n                  the file `pck', merged with the set of time intervals\n                  present in `cover' on input.  The merged coverage is\n                  represented as the union of one or more disjoint time\n                  intervals. The window `cover' contains the pairs of\n                  endpoints of these intervals.\n\n                  The interval endpoints contained in `cover' are\n                  ephemeris times, expressed as seconds past J2000\n                  TDB.\n\n                  See the Examples section below for a complete\n                  example program showing how to retrieve the\n                  endpoints from `cover'.\n\n");

/* void pckfrm_c ( ConstSpiceChar * pck,SpiceCell * ids ); */
static PyObject * spice_pckfrm(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell ids;
  /* variables for inputs */
  char * pck;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &pck));
  pckfrm_c(pck, &ids);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&ids));
  return returnVal;
}
PyDoc_STRVAR(pckfrm_doc, "-Abstract\n\n   Find the set of reference frame class ID codes of all frames\n   in a specified binary PCK file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   pck        I   Name of PCK file.\n   ids       I/O  Set of frame class ID codes of frames in PCK file.\n\n-Detailed_Input\n\n   pck            is the name of a binary PCK file.\n\n   ids            is an initialized CSPICE set data structure. `ids'\n                  optionally may contain a set of ID codes on input; on\n                  output, the data already present in `ids' will be\n                  combined with ID code set found for the file PCK.\n\n                  If `ids' contains no data on input, its size and\n                  cardinality still must be initialized.\n\n-Detailed_Output\n\n   ids            is a CSPICE set data structure which contains the\n                  union of its contents upon input with the set of\n                  reference frame class ID codes of each frame for\n                  which data are present in the indicated PCK file. The\n                  elements of CSPICE sets are unique; hence each ID\n                  code in `ids' appears only once, even if the PCK file\n                  contains multiple segments for that ID code.\n\n                  See the Examples section below for a complete example\n                  program showing how to retrieve the ID codes from\n                  `ids'.\n\n");

/* void pcklof_c ( ConstSpiceChar * fname,SpiceInt * handle ); */
static PyObject * spice_pcklof(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * fname;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &fname));
  pcklof_c(fname, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(pcklof_doc, "-Abstract\n\n   Load a binary PCK file for use by the readers.  Return the\n   handle of the loaded file which is used by other PCK routines to\n   refer to the file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   filename   I   Name of the file to be loaded.\n   handle     O   Loaded file's handle.\n\n-Detailed_Input\n\n   filename   Character name of the file to be loaded.\n\n-Detailed_Output\n\n   handle     Integer handle assigned to the file upon loading.\n              Other PCK routine will subsequently use this number\n              to refer to the file.\n\n");

/* void pckuof_c ( SpiceInt handle ); */
static PyObject * spice_pckuof(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  pckuof_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(pckuof_doc, "-Abstract\n\n   Unload a binary PCK file so that it will no longer be searched by\n   the readers.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of PCK file to be unloaded\n\n-Detailed_Input\n\n   handle     Integer handle assigned to the PCK file when it was\n              loaded.\n\n-Detailed_Output\n\n   None.\n\n");

/* void pdpool_c ( ConstSpiceChar * name,SpiceInt n,
ConstSpiceDouble * dvals ); */
static PyObject * spice_pdpool(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * name;
  int n;
  double * dvals;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sid", &name, &n, &dvals));
  pdpool_c(name, n, dvals);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(pdpool_doc, "-Abstract\n\n   This entry point provides toolkit programmers a method for\n   programmatically inserting double precision data into the\n   kernel pool.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   The kernel pool name to associate with dvals.\n   n          I   The number of values to insert.\n   dvals      I   An array of values to insert into the kernel pool.\n\n-Detailed_Input\n\n   name       is the name of the kernel pool variable to associate\n              with the values supplied in the array dvals. 'name' is\n              restricted to a length of 32 characters or less.\n\n   n          is the number of values to insert into the kernel pool.\n\n   dvals      is an array of d.p. values to insert into the kernel\n              pool.\n\n-Detailed_Output\n\n   None.\n\n");

/* void pgrrec_c ( ConstSpiceChar * body,SpiceDouble lon,SpiceDouble lat,
SpiceDouble alt,SpiceDouble re,SpiceDouble f,SpiceDouble rectan[3] ); */
static PyObject * spice_pgrrec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rectan[3];
  /* variables for inputs */
  char * body;
  double lon;
  double lat;
  double alt;
  double re;
  double f;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sddddd", &body, &lon, &lat, &alt, &re, &f));
  pgrrec_c(body, lon, lat, alt, re, f, rectan);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rectan[0], rectan[1], rectan[2]);
  return returnVal;
}
PyDoc_STRVAR(pgrrec_doc, "-Abstract\n\n   Convert planetographic coordinates to rectangular coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   body       I   Body with which coordinate system is associated.\n   lon        I   Planetographic longitude of a point (radians).\n   lat        I   Planetographic latitude of a point (radians).\n   alt        I   Altitude of a point above reference spheroid.\n   re         I   Equatorial radius of the reference spheroid.\n   f          I   Flattening coefficient.\n   rectan     O   Rectangular coordinates of the point.\n\n-Detailed_Input\n\n   body       Name of the body with which the planetographic\n              coordinate system is associated.\n\n              `body' is used by this routine to look up from the\n              kernel pool the prime meridian rate coefficient giving\n              the body's spin sense.  See the Files and Particulars\n              header sections below for details.\n\n   lon        Planetographic longitude of the input point.  This is\n              the angle between the prime meridian and the meridian\n              containing the input point.  For bodies having\n              prograde (aka direct) rotation, the direction of\n              increasing longitude is positive west:  from the +X\n              axis of the rectangular coordinate system toward the\n              -Y axis.  For bodies having retrograde rotation, the\n              direction of increasing longitude is positive east:\n              from the +X axis toward the +Y axis.\n\n              The earth, moon, and sun are exceptions:\n              planetographic longitude is measured positive east for\n              these bodies.\n\n              The default interpretation of longitude by this\n              and the other planetographic coordinate conversion\n              routines can be overridden; see the discussion in\n              Particulars below for details.\n\n              Longitude is measured in radians. On input, the range\n              of longitude is unrestricted.\n\n   lat        Planetographic latitude of the input point.  For a\n              point P on the reference spheroid, this is the angle\n              between the XY plane and the outward normal vector at\n              P. For a point P not on the reference spheroid, the\n              planetographic latitude is that of the closest point\n              to P on the spheroid.\n\n              Latitude is measured in radians.  On input, the\n              range of latitude is unrestricted.\n\n   alt        Altitude of point above the reference spheroid.\n              Units of `alt' must match those of  `re'.\n\n   re         Equatorial radius of a reference spheroid.  This\n              spheroid is a volume of revolution:  its horizontal\n              cross sections are circular.  The shape of the\n              spheroid is defined by an equatorial radius  `re' and\n              a polar radius `rp'.  Units of  `re' must match those of\n              `alt'.\n\n   f          Flattening coefficient =\n\n                 (re-rp) / re\n\n              where `rp' is the polar radius of the spheroid, and the\n              units of `rp' match those of  `re'.\n\n-Detailed_Output\n\n   rectan     The rectangular coordinates of the input point.  See\n              the discussion below in the Particulars header section\n              for details.\n\n              The units associated with `rectan' are those associated\n              with the inputs `alt' and `re'.\n\n");

/* SpiceDouble pi_c ( void ); */
static PyObject * spice_pi(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = pi_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(pi_doc, "-Abstract\n\n   Return the value of pi (the ratio of the circumference of\n   a circle to its diameter).\n\n-Brief_I/O\n\n   The function returns the value of pi.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the value of pi (the ratio of a circle's\n   circumference to its diameter), determined by the ACOS function.\n   That is,\n\n         pi_c = acos ( -1.0 );\n\n");

/* void pipool_c ( ConstSpiceChar * name,SpiceInt n,ConstSpiceInt * ivals ); */
static PyObject * spice_pipool(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * name;
  int n;
  int * ivals;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sii", &name, &n, &ivals));
  pipool_c(name, n, ivals);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(pipool_doc, "-Abstract\n\n   This entry point provides toolkit programmers a method for\n   programmatically inserting integer data into the kernel pool.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   The kernel pool name to associate with values.\n   n          I   The number of values to insert.\n   ivals      I   An array of integers to insert into the pool.\n\n-Detailed_Input\n\n   name       is the name of the kernel pool variable to associate\n              with the values supplied in the array ivals. 'name' is\n              restricted to a length of 32 characters or less.\n\n   n          is the number of values to insert into the kernel pool.\n\n   ivals      is an array of integers to insert into the kernel pool.\n\n-Detailed_Output\n\n   None.\n\n");

/* void pjelpl_c ( ConstSpiceEllipse * elin,ConstSpicePlane * plane,
SpiceEllipse * elout ); */
static PyObject * spice_pjelpl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceEllipse elout;
  /* variables for inputs */
  ConstSpiceEllipse * elin;
  PyObject * py_elin = NULL;
  ConstSpicePlane * plane;
  PyObject * py_plane = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "OO", &py_elin, &py_plane));
  elin = get_spice_ellipse(py_elin);
plane = get_spice_plane(py_plane);

  pjelpl_c(elin, plane, &elout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_ellipse(&elout));
  return returnVal;
}
PyDoc_STRVAR(pjelpl_doc, "-Abstract\n\n   Project an ellipse onto a plane, orthogonally.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   elin       I   A CSPICE ellipse to be projected.\n   plane      I   A plane onto which elin is to be projected.\n   elout      O   A CSPICE ellipse resulting from the projection.\n\n-Detailed_Input\n\n   elin,\n   plane          are, respectively, a cspice ellipse and a\n                  cspice plane.  The geometric ellipse represented\n                  by elin is to be orthogonally projected onto the\n                  geometric plane represented by plane.\n\n-Detailed_Output\n\n   elout          is a cspice ellipse that represents the geometric\n                  ellipse resulting from orthogonally projecting the\n                  ellipse represented by inel onto the plane\n                  represented by plane.\n\n");

/* void pl2nvc_c ( ConstSpicePlane * plane,SpiceDouble normal[3],
SpiceDouble * constant ); */
static PyObject * spice_pl2nvc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble normal[3];
  SpiceDouble constant;
  /* variables for inputs */
  ConstSpicePlane * plane;
  PyObject * py_plane = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "O", &py_plane));
  plane = get_spice_plane(py_plane);

  pl2nvc_c(plane, normal, &constant);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, normal[0], normal[1], normal[2], constant);
  return returnVal;
}
PyDoc_STRVAR(pl2nvc_doc, "-Abstract\n\n   Return a unit normal vector and constant that define a specified\n   plane.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   plane      I   A CSPICE plane.\n   normal,\n   constant   O   A normal vector and constant defining the\n                  geometric plane represented by plane.\n\n-Detailed_Input\n\n   plane          is a CSPICE plane.\n\n-Detailed_Output\n\n   normal,\n   constant       are, respectively, a unit normal vector and\n                  constant that define the geometric plane\n                  represented by plane.  Let the symbol < a, b >\n                  indicate the inner product of vectors a and b;\n                  then the geometric plane is the set of vectors x\n                  in three-dimensional space that satisfy\n\n                     < x,  normal >  =  constant.\n\n                  normal is a unit vector.  constant is the distance of\n                  the plane from the origin;\n\n                     constant * normal\n\n                  is the closest point in the plane to the origin.\n\n");

/* void pl2nvp_c ( ConstSpicePlane * plane,SpiceDouble normal[3],
SpiceDouble point[3] ); */
static PyObject * spice_pl2nvp(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble normal[3];
  SpiceDouble point[3];
  /* variables for inputs */
  ConstSpicePlane * plane;
  PyObject * py_plane = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "O", &py_plane));
  plane = get_spice_plane(py_plane);

  pl2nvp_c(plane, normal, point);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, normal[0], normal[1], normal[2], point[0], point[1], point[2]);
  return returnVal;
}
PyDoc_STRVAR(pl2nvp_doc, "-Abstract\n\n   Return a unit normal vector and point that define a specified\n   plane.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   plane      I   A CSPICE plane.\n   normal,\n   point      O   A unit normal vector and point that define plane.\n\n-Detailed_Input\n\n   plane          is a CSPICE plane.\n\n-Detailed_Output\n\n   normal,\n   point          are, respectively, a unit normal vector and point\n                  that define the geometric plane represented by\n                  plane.  Let the symbol < a, b > indicate the inner\n                  product of vectors a and b; then the geometric\n                  plane is the set of vectors x in three-dimensional\n                  space that satisfy\n\n                     < x - point, normal >  =  0.\n\n                  point is always the closest point in the input\n                  plane to the origin.  point is always a\n                  non-negative scalar multiple of normal.\n\n");

/* void pl2psv_c ( ConstSpicePlane * plane,SpiceDouble point[3],
SpiceDouble span1[3],SpiceDouble span2[3] ); */
static PyObject * spice_pl2psv(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble point[3];
  SpiceDouble span1[3];
  SpiceDouble span2[3];
  /* variables for inputs */
  ConstSpicePlane * plane;
  PyObject * py_plane = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "O", &py_plane));
  plane = get_spice_plane(py_plane);

  pl2psv_c(plane, point, span1, span2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, point[0], point[1], point[2], span1[0], span1[1], span1[2], span2[0], span2[1], span2[2]);
  return returnVal;
}
PyDoc_STRVAR(pl2psv_doc, "-Abstract\n\n   Return a point and two orthogonal spanning vectors that generate\n   a specified plane.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   plane      I   A CSPICE plane.\n   point,\n   span1,\n   span2      O   A point in the input plane and two vectors\n                  spanning the input plane.\n\n-Detailed_Input\n\n   plane          is a CSPICE plane that represents the geometric\n                  plane defined by point, span1, and span2.\n\n-Detailed_Output\n\n   point,\n   span1,\n   span2          are, respectively, a point and two orthogonal\n                  spanning vectors that generate the geometric plane\n                  represented by plane.  The geometric plane is the\n                  set of vectors\n\n                     point   +   s * span1   +   t * span2\n\n                  where s and t are real numbers.  point is the\n                  closest point in the plane to the origin; this\n                  point is always a multiple of the plane's normal\n                  vector.  span1 and span2 are an orthonormal pair\n                  of vectors.  point, span1, and span2 are mutually\n                  orthogonal.\n\n");

/* SpiceInt pos_c ( ConstSpiceChar * str,ConstSpiceChar * substr,
SpiceInt start ); */
static PyObject * spice_pos(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * str;
  char * substr;
  int start;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &str, &substr, &start));
  result = pos_c(str, substr, start);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(pos_doc, "-Abstract\n\n   Find the first occurrence in a string of a substring, starting at\n   a specified location, searching forward.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   str        I   Any character string.\n   substr     I   Substring to locate in the character string.\n   start      I   Position to begin looking for substr in str.\n\n   The function returns the index of the first occurrence of substr in\n   str at or following index start.\n\n-Detailed_Input\n\n   str        is any character string.\n\n   substr     is a substring to look for in str.  Spaces in substr are\n              significant, including trailing blanks.\n\n   start      is the position in str to begin looking for substr. start\n              may range from 0 to n-1, where n is the number of\n              characters in str.\n\n-Detailed_Output\n\n   The function returns the index of the beginning of the first\n   substring of str that begins on or after index start and is equal\n   to substr. If the substring cannot be found after start, the\n   function is returns -1.\n\n");

/* SpiceInt posr_c ( ConstSpiceChar * str,ConstSpiceChar * substr,
SpiceInt start ); */
static PyObject * spice_posr(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * str;
  char * substr;
  int start;

  char failed = 0;

  /* variable for result */
  SpiceInt result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &str, &substr, &start));
  result = posr_c(str, substr, start);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("i", result);
}
PyDoc_STRVAR(posr_doc, "-Abstract\n\n   Find the first occurrence in a string of a substring, starting at\n   a specified location, searching backward.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   str        I   Any character string.\n   substr     I   Substring to locate in the character string.\n   start      I   Position to begin looking for substr in str.\n\n   The function returns the index of the last occurrence of substr in\n   str at or preceding index start.\n\n-Detailed_Input\n\n   str        is any character string.\n\n   substr     is a substring to look for in str.  Spaces in substr are\n              significant, including trailing blanks.\n\n   start      is the position in str to begin looking for substr. start\n              may range from 0 to n-1, where n is the number of\n              characters in str.\n\n-Detailed_Output\n\n   The function returns the index of the beginning of the last\n   substring of str that begins at or before index start and is equal\n   to substr. If the substring cannot be found after start, the\n   function is returns -1.\n\n");

/* void prop2b_c ( SpiceDouble gm,ConstSpiceDouble pvinit[6],SpiceDouble dt,
SpiceDouble pvprop[6] ); */
static PyObject * spice_prop2b(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble pvprop[6];
  /* variables for inputs */
  double gm;
  double pvinit[6];
  double dt;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d(dddddd)d", &gm, &pvinit[0], &pvinit[1], &pvinit[2], &pvinit[3], &pvinit[4], &pvinit[5], &dt));
  prop2b_c(gm, pvinit, dt, pvprop);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, pvprop[0], pvprop[1], pvprop[2], pvprop[3], pvprop[4], pvprop[5]);
  return returnVal;
}
PyDoc_STRVAR(prop2b_doc, "-Abstract\n\n   Given a central mass and the state of massless body at time t_0,\n   this routine determines the state as predicted by a two-body\n   force model at time t_0 + dt.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   gm         I   Gravity of the central mass.\n   pvinit     I   Initial state from which to propagate a state.\n   dt         I   Time offset from initial state to propagate to.\n   pvprop     O   The propagated state.\n\n-Detailed_Input\n\n   gm         is the gravitational constant G times the mass M of the\n              central body.\n\n   pvinit     is the state at some specified time relative to the\n              central mass.  The mass of the object is assumed to\n              be negligible when compared to the central mass.\n\n   dt         is a offset in time from the time of the initial\n              state to which the two-body state should be\n              propagated. (The units of time and distance must be\n              the same in gm, pvinit, and dt).\n\n-Detailed_Output\n\n   pvprop     is the two-body propagation of the initial state\n              dt units of time past the epoch of the initial state.\n\n");

/* void prsdp_c ( ConstSpiceChar * string,SpiceDouble * dpval ); */
static PyObject * spice_prsdp(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble dpval;
  /* variables for inputs */
  char * string;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &string));
  prsdp_c(string, &dpval);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, dpval);
  return returnVal;
}
PyDoc_STRVAR(prsdp_doc, "-Abstract\n\n   Parse a string as a double precision number, encapsulating error\n   handling.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   string     I   String representing a d.p. number.\n   dpval      O   D.p. value obtained by parsing string.\n\n-Detailed_Input\n\n   string         is a string representing a double precision\n                  number.  Any string acceptable to the CSPICE\n                  routine nparsd.c is allowed.\n\n-Detailed_Output\n\n   dpval          is the double precision number obtained by parsing\n                  string.\n\n");

/* void prsint_c ( ConstSpiceChar * string,SpiceInt * intval ); */
static PyObject * spice_prsint(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt intval;
  /* variables for inputs */
  char * string;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &string));
  prsint_c(string, &intval);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, intval);
  return returnVal;
}
PyDoc_STRVAR(prsint_doc, "-Abstract\n\n   Parse a string as an integer, encapsulating error handling.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   string     I   String representing an integer.\n   intval     O   Integer value obtained by parsing string.\n\n-Detailed_Input\n\n   string         is a string representing an integer.  Any string\n                  acceptable to the CSPICE routine nparsi_ is\n                  allowed.\n\n-Detailed_Output\n\n   intval         is the integer obtained by parsing string.\n\n");

/* void psv2pl_c ( ConstSpiceDouble point[3],ConstSpiceDouble span1[3],
ConstSpiceDouble span2[3],SpicePlane * plane ); */
static PyObject * spice_psv2pl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpicePlane plane;
  /* variables for inputs */
  double point[3];
  double span1[3];
  double span2[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)(ddd)", &point[0], &point[1], &point[2], &span1[0], &span1[1], &span1[2], &span2[0], &span2[1], &span2[2]));
  psv2pl_c(point, span1, span2, &plane);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_plane(&plane));
  return returnVal;
}
PyDoc_STRVAR(psv2pl_doc, "-Abstract\n\n   Make a CSPICE plane from a point and two spanning vectors.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   point,\n   span1,\n   span2      I   A point and two spanning vectors defining a plane.\n   plane      O   A CSPICE plane representing the plane.\n\n-Detailed_Input\n\n   point,\n   span1,\n   span2          are, respectively, a point and two spanning vectors\n                  that define a geometric plane in three-dimensional\n                  space. The plane is the set of vectors\n\n                     point   +   s * span1   +   t * span2\n\n                  where s and t are real numbers.  The spanning\n                  vectors span1 and span2 must be linearly\n                  independent, but they need not be orthogonal or\n                  unitized.\n\n-Detailed_Output\n\n   plane          is a CSPICE plane that represents the geometric\n                  plane defined by point, span1, and span2.\n\n");

/* void pxform_c ( ConstSpiceChar * from,ConstSpiceChar * to,SpiceDouble et,
SpiceDouble rotate[3][3] ); */
static PyObject * spice_pxform(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rotate[3][3];
  /* variables for inputs */
  char * from;
  char * to;
  double et;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssd", &from, &to, &et));
  pxform_c(from, to, et, rotate);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rotate[0][0], rotate[0][1], rotate[0][2], rotate[1][0], rotate[1][1], rotate[1][2], rotate[2][0], rotate[2][1], rotate[2][2]);
  return returnVal;
}
PyDoc_STRVAR(pxform_doc, "-Abstract\n\n   Return the matrix that transforms position vectors from one\n   specified frame to another at a specified epoch.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   from       I   Name of the frame to transform from.\n   to         I   Name of the frame to transform to.\n   et         I   Epoch of the rotation matrix.\n   rotate     O   A rotation matrix.\n\n-Detailed_Input\n\n   from        is the name of a reference frame in which a position\n               vector is known.\n\n   to          is the name of a reference frame in which it is desired\n               to represent a position vector.\n\n   et          is the epoch in ephemeris seconds past the epoch of\n               J2000 (TDB) at which the position transformation matrix\n               `rotate' should be evaluated.\n\n-Detailed_Output\n\n   rotate      is the matrix that transforms position vectors from the\n               reference frame `from' to the frame `to' at epoch `et'.\n               If (x, y, z) is a position relative to the frame `from'\n               then the vector ( x', y', z') is the same position\n               relative to the frame `to' at epoch `et'.  Here the\n               vector ( x', y', z' ) is defined by the equation:\n\n                   -   -       -        -     -  -\n                  | x'  |     |          |   | x  |\n                  | y'  |  =  |  rotate  |   | y  |\n                  | z'  |     |          |   | z  |\n                   -   -       -        -     -  -\n");

/* void q2m_c ( ConstSpiceDouble q[4],SpiceDouble r[3][3] ); */
static PyObject * spice_q2m(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble r[3][3];
  /* variables for inputs */
  double q[4];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddd)", &q[0], &q[1], &q[2], &q[3]));
  q2m_c(q, r);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, r[0][0], r[0][1], r[0][2], r[1][0], r[1][1], r[1][2], r[2][0], r[2][1], r[2][2]);
  return returnVal;
}
PyDoc_STRVAR(q2m_doc, "-Abstract\n\n   Find the rotation matrix corresponding to a specified unit\n   quaternion.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   q          I   A unit quaternion.\n   r          O   A rotation matrix corresponding to `q'.\n\n-Detailed_Input\n\n   q              is a unit-length SPICE-style quaternion representing\n                  a rotation. `q' has the property that\n\n                     || q ||  =  1\n\n                  See the discussion of quaternion styles in\n                  Particulars below.\n\n-Detailed_Output\n\n   r              is a 3 by 3 rotation matrix representing the same\n                  rotation as does `q'. See the discussion titled\n                  \"Associating SPICE Quaternions with Rotation\n                  Matrices\" in Particulars below.\n\n");

/* void qdq2av_c ( ConstSpiceDouble q[4],ConstSpiceDouble dq[4],
SpiceDouble av[3] ); */
static PyObject * spice_qdq2av(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble av[3];
  /* variables for inputs */
  double q[4];
  double dq[4];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddd)(dddd)", &q[0], &q[1], &q[2], &q[3], &dq[0], &dq[1], &dq[2], &dq[3]));
  qdq2av_c(q, dq, av);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, av[0], av[1], av[2]);
  return returnVal;
}
PyDoc_STRVAR(qdq2av_doc, "-Abstract\n\n   Derive angular velocity from a unit quaternion and its derivative\n   with respect to time.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   q          I   Unit SPICE quaternion.\n   dq         I   Derivative of `q' with respect to time.\n   av         O   Angular velocity defined by `q' and `dq'.\n\n-Detailed_Input\n\n   q              is a unit length 4-vector representing a SPICE-style\n                  quaternion. See the discussion of \"Quaternion Styles\"\n                  in the Particulars section below.\n\n                  Note that multiple styles of quaternions are in use.\n                  This routine will not work properly if the input\n                  quaternions do not conform to the SPICE convention.\n                  See the Particulars section for details.\n\n\n   dq             is a 4-vector representing the derivative of `q' with\n                  respect to time.\n\n-Detailed_Output\n\n   av             is 3-vector representing the angular velocity defined\n                  by `q' and `dq', that is, the angular velocity of the\n                  frame defined by the rotation matrix associated with\n                  `q'.  This rotation matrix can be obtained via the\n                  CSPICE routine q2m_c; see the Particulars section for\n                  the explicit matrix entries.\n\n                  `av' is the vector (imaginary) part of the quaternion\n                  product\n\n                           *\n                     -2 * q  * dq\n\n                  This angular velocity is the same vector that could\n                  be obtained (much less efficiently ) by mapping `q'\n                  and `dq' to the corresponding C-matrix `r' and its\n                  derivative `dr', then calling the CSPICE routine\n                  xf2rav_c.\n\n                  `av' has units of\n\n                     radians / T\n\n                  where\n\n                     1 / T\n\n                  is the unit associated with `dq'.\n\n");

/* void qxq_c ( ConstSpiceDouble q1[4],ConstSpiceDouble q2[4],
SpiceDouble qout[4] ); */
static PyObject * spice_qxq(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble qout[4];
  /* variables for inputs */
  double q1[4];
  double q2[4];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddd)(dddd)", &q1[0], &q1[1], &q1[2], &q1[3], &q2[0], &q2[1], &q2[2], &q2[3]));
  qxq_c(q1, q2, qout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, qout[0], qout[1], qout[2], qout[3]);
  return returnVal;
}
PyDoc_STRVAR(qxq_doc, "-Abstract\n\n   Multiply two quaternions.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   q1         I   First SPICE quaternion factor.\n   q2         I   Second SPICE quaternion factor.\n   qout       O   Product of `q1' and `q2'.\n\n-Detailed_Input\n\n   q1             is a 4-vector representing a SPICE-style quaternion.\n                  See the discussion of \"Quaternion Styles\" in the\n                  Particulars section below.\n\n                  Note that multiple styles of quaternions are in use.\n                  This routine will not work properly if the input\n                  quaternions do not conform to the SPICE convention.\n\n   q2             is a second SPICE-style quaternion.\n\n-Detailed_Output\n\n   qout           is 4-vector representing the quaternion product\n\n                     q1 * q2\n\n                  Representing q(i) as the sums of scalar (real)\n                  part s(i) and vector (imaginary) part v(i)\n                  respectively,\n\n                     q1 = s1 + v1\n                     q2 = s2 + v2\n\n                  qout has scalar part s3 defined by\n\n                     s3 = s1 * s2 - <v1, v2>\n\n                  and vector part v3 defined by\n\n                     v3 = s1 * v2  +  s2 * v1  +  v1 x v2\n\n                  where the notation < , > denotes the inner\n                  product operator and x indicates the cross\n                  product operator.\n\n");

/* void radrec_c ( SpiceDouble range,SpiceDouble ra,SpiceDouble dec,
SpiceDouble rectan[3] ); */
static PyObject * spice_radrec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rectan[3];
  /* variables for inputs */
  double range;
  double ra;
  double dec;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &range, &ra, &dec));
  radrec_c(range, ra, dec, rectan);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rectan[0], rectan[1], rectan[2]);
  return returnVal;
}
PyDoc_STRVAR(radrec_doc, "-Abstract\n\n   Convert from range, right ascension, and declination to rectangular\n   coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  ---------------------------------------------------\n   range      I   Distance of a point from the origin.\n   ra         I   Right ascension of point in radians.\n   dec        I   Declination of point in radians.\n   rectan     O   Rectangular coordinates of the point.\n\n-Detailed_Input\n\n   range      is the distance of the point from the origin.  Output\n              units are the same as the units associated with `range.'\n\n   ra         is the right ascension of the input point:  the angular\n              distance measured toward the east from the prime meridian\n              to the meridian containing the input point. The direction\n              of increasing right ascension is from the +X axis towards\n              the +Y axis.\n\n              The range (i.e., the set of allowed values) of\n              `ra' is unrestricted.  Units are radians.\n\n   dec        is the declination of the point.  This is the angular\n              distance from the XY plane to the point.\n\n              The range of `dec' is unrestricted.  Units are radians.\n\n-Detailed_Output\n\n   rectan     is the array containing the rectangular coordinates of\n              the point.  The output units associated with `rectan'\n              are those associated with the input `range.'\n\n");

/* void rav2xf_c ( ConstSpiceDouble rot [3][3],ConstSpiceDouble av [3],
SpiceDouble xform [6][6] ); */
static PyObject * spice_rav2xf(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble xform[6][6];
  /* variables for inputs */
  double rot[3][3];
  double av[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))(ddd)", &rot[0][0], &rot[0][1], &rot[0][2], &rot[1][0], &rot[1][1], &rot[1][2], &rot[2][0], &rot[2][1], &rot[2][2], &av[0], &av[1], &av[2]));
  rav2xf_c(rot, av, xform);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((dddddd)(dddddd)(dddddd)(dddddd)(dddddd)(dddddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, xform[0][0], xform[0][1], xform[0][2], xform[0][3], xform[0][4], xform[0][5], xform[1][0], xform[1][1], xform[1][2], xform[1][3], xform[1][4], xform[1][5], xform[2][0], xform[2][1], xform[2][2], xform[2][3], xform[2][4], xform[2][5], xform[3][0], xform[3][1], xform[3][2], xform[3][3], xform[3][4], xform[3][5], xform[4][0], xform[4][1], xform[4][2], xform[4][3], xform[4][4], xform[4][5], xform[5][0], xform[5][1], xform[5][2], xform[5][3], xform[5][4], xform[5][5]);
  return returnVal;
}
PyDoc_STRVAR(rav2xf_doc, "-Abstract\n\n   This routine determines a state transformation matrix\n   from a rotation matrix and the angular velocity of the\n   rotation.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   rot        I   Rotation matrix.\n   av         I   Angular velocity vector.\n   xform      O   State transformation associated with rot and av.\n\n-Detailed_Input\n\n   rot         is a rotation that gives the transformation from\n               some frame frame1 to another frame frame2.\n\n   av          is the angular velocity of the transformation.\n               In other words, if p is the position of a fixed\n               point in frame2, then from the point of view of\n               frame1,  p rotates (in a right handed sense) about\n               an axis parallel to av.  Moreover the rate of rotation\n               in radians per unit time is given by the length of\n               av.\n\n               More formally, the velocity v of p in frame1 is\n               given by\n                                  t\n                   v  = av x ( rot * p )\n\n-Detailed_Output\n\n   xform       is a state transformation matrix associated\n               with rot and av.  If s1 is the state of an object\n               with respect to frame1, then the state s2 of the\n               object with respect to frame2 is given by\n\n                   s2  =  xform * s1\n\n               where \"*\" denotes matrix-vector multiplication.\n\n\n");

/* void raxisa_c ( ConstSpiceDouble matrix[3][3],SpiceDouble axis [3],
SpiceDouble * angle ); */
static PyObject * spice_raxisa(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble axis[3];
  SpiceDouble angle;
  /* variables for inputs */
  double matrix[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))", &matrix[0][0], &matrix[0][1], &matrix[0][2], &matrix[1][0], &matrix[1][1], &matrix[1][2], &matrix[2][0], &matrix[2][1], &matrix[2][2]));
  raxisa_c(matrix, axis, &angle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, axis[0], axis[1], axis[2], angle);
  return returnVal;
}
PyDoc_STRVAR(raxisa_doc, "-Abstract\n\n   Compute the axis of the rotation given by an input matrix\n   and the angle of the rotation about that axis.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   matrix     I   3x3 rotation matrix in double precision.\n   axis       O   Axis of the rotation.\n   angle      O   Angle through which the rotation is performed.\n\n-Detailed_Input\n\n   matrix     is a 3x3 rotation matrix in double precision.\n\n-Detailed_Output\n\n   axis       is a unit vector pointing along the axis of the rotation.\n              In other words, `axis' is a unit eigenvector of the input\n              matrix, corresponding to the eigenvalue 1. If the input\n              matrix is the identity matrix, `axis' will be the vector\n              (0, 0, 1). If the input rotation is a rotation by pi\n              radians, both `axis' and -axis may be regarded as the\n              axis of the rotation.\n\n   angle      is the angle between `v' and matrix*v for any non-zero\n              vector `v' orthogonal to `axis'.  `angle' is given in\n              radians.  The angle returned will be in the range from 0\n              to pi radians.\n\n");

/* void rdtext_c ( ConstSpiceChar * file,SpiceInt lenout,SpiceChar * line,
SpiceBoolean * eof ); */
static PyObject * spice_rdtext(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar line[STRING_LEN];
  SpiceBoolean eof;
  /* variables for inputs */
  char * file;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &file));
  rdtext_c(file, lenout, line, &eof);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, line, get_py_boolean(&eof));
  return returnVal;
}
PyDoc_STRVAR(rdtext_doc, "-Abstract\n\n   Read the next line of text from a text file.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  ---------------------------------------------------\n   file       I   Name of text file.\n   lenout     I   Available room in output line.\n   line       O   Next line from the text file.\n   eof        O   End-of-file indicator.\n\n-Detailed_Input\n\n   file        is the name of the text file from which the next\n               line is to be read. If the file is not currently\n               open, it is opened with a logical unit determined\n               at run time, and the first line of the file is\n               returned. Otherwise, the next line not yet read\n               from the file is read and returned.\n\n   lenout      is the available room in the output line, including\n               the terminating null.  If the maximum expected length\n               of an output line is N, lenout should be at least N+1.\n\n-Detailed_Output\n\n   line        is next line of text in the specified file.\n               If the end of the file is reached, LINE is blank.\n\n   eof         is true when the end of the file is reached, and is\n               otherwise false.\n\n");

/* void reccyl_c ( ConstSpiceDouble rectan[3],SpiceDouble * r,
SpiceDouble * lon,SpiceDouble * z ); */
static PyObject * spice_reccyl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble r;
  SpiceDouble lon;
  SpiceDouble z;
  /* variables for inputs */
  double rectan[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &rectan[0], &rectan[1], &rectan[2]));
  reccyl_c(rectan, &r, &lon, &z);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, r, lon, z);
  return returnVal;
}
PyDoc_STRVAR(reccyl_doc, "-Abstract\n\n   Convert from rectangular to cylindrical coordinates.\n\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  -------------------------------------------------\n   rectan     I   Rectangular coordinates of a point.\n   r          O   Distance of the point from z axis.\n   lon        O   Angle (radians) of the point from xZ plane\n   z          O   Height of the point above xY plane.\n\n-Detailed_Input\n\n   rectan     Rectangular coordinates of the point of interest.\n\n-Detailed_Output\n\n   r          Distance of the point of interest from z axis.\n\n   lon        Cylindrical angle (in radians) of the point of\n              interest from xZ plane.\n\n   z          Height of the point above xY plane.\n\n");

/* void recgeo_c ( ConstSpiceDouble rectan[3],SpiceDouble re,SpiceDouble f,
SpiceDouble * lon,SpiceDouble * lat,SpiceDouble * alt ); */
static PyObject * spice_recgeo(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble lon;
  SpiceDouble lat;
  SpiceDouble alt;
  /* variables for inputs */
  double rectan[3];
  double re;
  double f;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)dd", &rectan[0], &rectan[1], &rectan[2], &re, &f));
  recgeo_c(rectan, re, f, &lon, &lat, &alt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, lon, lat, alt);
  return returnVal;
}
PyDoc_STRVAR(recgeo_doc, "-Abstract\n\n   Convert from rectangular coordinates to geodetic coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   rectan     I   Rectangular coordinates of a point.\n   re         I   Equatorial radius of the reference spheroid.\n   f          I   Flattening coefficient.\n   lon        O   Geodetic longitude of the point (radians).\n   lat        O   Geodetic latitude  of the point (radians).\n   alt        O   Altitude of the point above reference spheroid.\n\n-Detailed_Input\n\n   rectan    Rectangular coordinates of the input point.\n\n   re        Equatorial radius of a reference spheroid.  This spheroid\n             is a volume of revolution:  its horizontal cross sections\n             are circular.  The shape of the spheroid is defined by\n             an equatorial radius `re' and a polar radius `rp'.\n\n   f         Flattening coefficient = (re-rp) / re, where rp is\n             the polar radius of the spheroid.\n\n-Detailed_Output\n\n   lon       Geodetic longitude of the input point.  This is the\n             angle between the prime meridian and the meridian\n             containing `rectan'.  The direction of increasing\n             longitude is from the +X axis towards the +Y axis.\n\n             `lon' is output in radians.  The range of `lon' is\n             [-pi, pi].\n\n\n   lat       Geodetic latitude of the input point.  For a point P\n             on the reference spheroid, this is the angle between the\n             XY plane and the outward normal vector at P. For a point P\n             not on the reference spheroid, the geodetic latitude is\n             that of the closest point to P on the spheroid.\n\n             `lat' is output in radians. The range of `lat' is\n             [-pi/2, pi/2].\n\n\n   alt       Altitude of point above the reference spheroid.\n\n             The units associated with `alt' are those associated with\n             the input `rectan'.\n\n");

/* void reclat_c ( ConstSpiceDouble rectan[3],SpiceDouble * radius,
SpiceDouble * longitude,SpiceDouble * latitude ); */
static PyObject * spice_reclat(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble radius;
  SpiceDouble longitude;
  SpiceDouble latitude;
  /* variables for inputs */
  double rectan[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &rectan[0], &rectan[1], &rectan[2]));
  reclat_c(rectan, &radius, &longitude, &latitude);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, radius, longitude, latitude);
  return returnVal;
}
PyDoc_STRVAR(reclat_doc, "-Abstract\n\n   Convert from rectangular coordinates to latitudinal coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   rectan     I   Rectangular coordinates of a point.\n   radius     O   Distance of the point from the origin.\n   longitude  O   Longitude of the point in radians.\n   latitude   O   Latitude of the point in radians.\n\n-Detailed_Input\n\n   rectan     The rectangular coordinates of the input point.  `rectan'\n              is a 3-vector.\n\n-Detailed_Output\n\n   radius     Distance of the point from the origin.\n\n              The units associated with `radius' are those\n              associated with the input `rectan'.\n\n   longitude  Longitude of the input point.  This is angle between the\n              prime meridian and the meridian containing `rectan'.  The\n              direction of increasing longitude is from the +X axis\n              towards the +Y axis.\n\n              Longitude is output in radians. The range of `longitude'\n              is [-pi, pi].\n\n\n   latitude   Latitude of the input point.  This is the angle from\n              the XY plane of the ray from the origin through the\n              point.\n\n              Latitude is output in radians.  The range of `latitude'\n              is [-pi/2, pi/2].\n\n");

/* void recpgr_c ( ConstSpiceChar * body,SpiceDouble rectan[3],SpiceDouble re,
SpiceDouble f,SpiceDouble * lon,SpiceDouble * lat,SpiceDouble * alt ); */
static PyObject * spice_recpgr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble lon;
  SpiceDouble lat;
  SpiceDouble alt;
  /* variables for inputs */
  char * body;
  double rectan[3];
  double re;
  double f;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s(ddd)dd", &body, &rectan[0], &rectan[1], &rectan[2], &re, &f));
  recpgr_c(body, rectan, re, f, &lon, &lat, &alt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, lon, lat, alt);
  return returnVal;
}
PyDoc_STRVAR(recpgr_doc, "-Abstract\n\n   Convert rectangular coordinates to planetographic coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   body       I   Body with which coordinate system is associated.\n   rectan     I   Rectangular coordinates of a point.\n   re         I   Equatorial radius of the reference spheroid.\n   f          I   Flattening coefficient.\n   lon        O   Planetographic longitude of the point (radians).\n   lat        O   Planetographic latitude of the point (radians).\n   alt        O   Altitude of the point above reference spheroid.\n\n-Detailed_Input\n\n   body       Name of the body with which the planetographic\n              coordinate system is associated.\n\n              `body' is used by this routine to look up from the\n              kernel pool the prime meridian rate coefficient giving\n              the body's spin sense.  See the Files and Particulars\n              header sections below for details.\n\n\n   rectan     The rectangular coordinates of a point.  Units\n              are arbitrary, except that the input `re' must be\n              expressed in the same units.\n\n\n   re         Equatorial radius of a reference spheroid.  This\n              spheroid is a volume of revolution:  its horizontal\n              cross sections are circular.  The shape of the\n              spheroid is defined by an equatorial radius `re' and a\n              polar radius `rp'.  Units of `re' must match those of\n              `rectan'.\n\n\n   f          Flattening coefficient =\n\n                 (re-rp) / re\n\n              where `rp' is the polar radius of the spheroid, and the\n              units of `rp' match those of `re'.\n\n-Detailed_Output\n\n   lon        Planetographic longitude of the input point.  This is\n              the angle between the prime meridian and the meridian\n              containing `rectan'.  For bodies having prograde (aka\n              direct) rotation, the direction of increasing\n              longitude is positive west:  from the +X axis of the\n              rectangular coordinate system toward the -Y axis.\n              For bodies having retrograde rotation, the direction\n              of increasing longitude is positive east:  from the +X\n              axis toward the +Y axis.\n\n              The earth, moon, and sun are exceptions:\n              planetographic longitude is measured positive east for\n              these bodies.\n\n              The default interpretation of longitude by this\n              and the other planetographic coordinate conversion\n              routines can be overridden; see the discussion in\n              Particulars below for details.\n\n              `lon' is output in radians.  The nominal range of `lon' is\n              given by:\n\n                 0  <  lon  <  2*pi\n                    -\n\n              However, round-off error could cause `lon' to equal 2*pi.\n\n\n   lat        Planetographic latitude of the input point.  For a\n              point P on the reference spheroid, this is the angle\n              between the XY plane and the outward normal vector at\n              P. For a point P not on the reference spheroid, the\n              planetographic latitude is that of the closest point\n              to P on the spheroid.\n\n              `lat' is output in radians. The range of `lat' is given\n              by:\n\n                 -pi/2  <  lat  <  pi/2\n                        -       -\n\n\n   alt        Altitude of point above the reference spheroid.\n\n              The units associated with `alt' are those associated\n              with the input `rectan' and `re'.\n\n");

/* void recrad_c ( ConstSpiceDouble rectan[3],SpiceDouble * radius,
SpiceDouble * ra,SpiceDouble * dec ); */
static PyObject * spice_recrad(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble radius;
  SpiceDouble ra;
  SpiceDouble dec;
  /* variables for inputs */
  double rectan[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &rectan[0], &rectan[1], &rectan[2]));
  recrad_c(rectan, &radius, &ra, &dec);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, radius, ra, dec);
  return returnVal;
}
PyDoc_STRVAR(recrad_doc, "-Abstract\n\n   Convert rectangular coordinates to range, right ascension, and\n   declination.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   rectan     I   Rectangular coordinates of a point.\n   range      O   Distance of the point from the origin.\n   ra         O   Right ascension in radians.\n   dec        O   Declination in radians.\n\n-Detailed_Input\n\n   rectan     The rectangular coordinates of a point.\n\n-Detailed_Output\n\n   range      is the distance of the point `rectan' from the origin.\n\n              The units associated with `range' are those associated\n              with the input `rectan'.\n\n   ra         is the right ascension of `rectan'.  This is the angular\n              distance measured toward the east from the prime meridian\n              to the meridian containing the input point. The direction\n              of increasing right ascension is from the +X axis towards\n              the +Y axis.\n\n              `ra' is output in radians.  The range of `ra' is [0, 2*pi].\n\n\n   dec        is the declination of `rectan'.  This is the angle from\n              the XY plane of the ray from the origin through the\n              point.\n\n              `dec' is output in radians.  The range of `dec' is\n              [-pi/2, pi/2].\n\n");

/* void reordd_c ( ConstSpiceInt * iorder,SpiceInt ndim,
SpiceDouble * array ); */
static PyObject * spice_reordd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble array;
  /* variables for inputs */
  int * iorder;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &iorder, &ndim));
  reordd_c(iorder, ndim, &array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, array);
  return returnVal;
}
PyDoc_STRVAR(reordd_doc, "-Abstract\n\n   Re-order the elements of a double precision array according to\n   a given order vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   iorder     I   Order vector to be used to re-order array.\n   ndim       I   Dimension of array.\n   array     I/O  Array to be re-ordered.\n\n-Detailed_Input\n\n   iorder      is the order vector to be used to re-order the input\n               array. The first element of iorder is the index of\n               the first item of the re-ordered array, and so on.\n\n               Note that the order imposed by reordd_c is not the\n               same order that would be imposed by a sorting\n               routine. In general, the order vector will have\n               been created (by one of the order routines) for\n               a related array, as illustrated in the example below.\n\n   ndim        is the number of elements in the input array.\n\n   array       on input, is an array containing some number of\n               elements in unspecified order.\n\n-Detailed_Output\n\n   array       on output, is the same array, with the elements\n               in re-ordered as specified by iorder.\n\n");

/* void reordi_c ( ConstSpiceInt * iorder,SpiceInt ndim,SpiceInt * array ); */
static PyObject * spice_reordi(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt array;
  /* variables for inputs */
  int * iorder;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &iorder, &ndim));
  reordi_c(iorder, ndim, &array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, array);
  return returnVal;
}
PyDoc_STRVAR(reordi_doc, "-Abstract\n\n    Re-order the elements of an integer array according to\n    a given order vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   iorder     I   Order vector to be used to re-order array.\n   ndim       I   Dimension of array.\n   array     I/O  Array to be re-ordered.\n\n-Detailed_Input\n\n   iorder      is the order vector to be used to re-order the input\n               array. The first element of iorder is the index of\n               the first item of the re-ordered array, and so on.\n\n               Note that the order imposed by reordi_c is not the\n               same order that would be imposed by a sorting\n               routine. In general, the order vector will have\n               been created (by one of the order routines) for\n               a related array, as illustrated in the example below.\n\n               The elements of iorder range from zero to ndim-1.\n\n   ndim        is the number of elements in the input array.\n\n   array       on input, is an array containing some number of\n               elements in unspecified order.\n\n-Detailed_Output\n\n   array       on output, is the same array, with the elements\n               in re-ordered as specified by iorder.\n\n");

/* void reordl_c ( ConstSpiceInt * iorder,SpiceInt ndim,
SpiceBoolean * array ); */
static PyObject * spice_reordl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceBoolean array;
  /* variables for inputs */
  int * iorder;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &iorder, &ndim));
  reordl_c(iorder, ndim, &array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_boolean(&array));
  return returnVal;
}
PyDoc_STRVAR(reordl_doc, "-Abstract\n\n    Re-order the elements of a logical (Boolean) array according to\n    a given order vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   iorder     I   Order vector to be used to re-order array.\n   ndim       I   Dimension of array.\n   array     I/O  Array to be re-ordered.\n\n-Detailed_Input\n\n   iorder      is the order vector to be used to re-order the input\n               array. The first element of iorder is the index of\n               the first item of the re-ordered array, and so on.\n\n               Note that the order imposed by reordl_c is not the\n               same order that would be imposed by a sorting\n               routine. In general, the order vector will have\n               been created (by one of the order routines) for\n               a related array, as illustrated in the example below.\n\n               The elements of iorder range from zero to ndim-1.\n\n   ndim        is the number of elements in the input array.\n\n   array       on input, is an array containing some number of\n               elements in unspecified order.\n\n-Detailed_Output\n\n   array       on output, is the same array, with the elements\n               in re-ordered as specified by iorder.\n\n");

/* void removc_c ( ConstSpiceChar * item,SpiceCell * set ); */
static PyObject * spice_removc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  char * item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &item));
  removc_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(removc_doc, "-Abstract\n\n   Remove an item from a character set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be removed.\n   set       I/O  Removal set.\n\n-Detailed_Input\n\n   item        is an item which is to be removed from the specified\n               set. item may or may not already be an element of the\n               set.  Trailing blanks in item are not significant.\n\n\n   set         is a CSPICE set.  set must be declared as a character\n               SpiceCell.\n\n               On input, set may or may not contain the input item\n               as an element.\n\n-Detailed_Output\n\n   set          on output contains the difference of the input set and\n                the input item. If the item is not an element of the\n                set, the set is not changed.\n\n");

/* void removd_c ( SpiceDouble item,SpiceCell * set ); */
static PyObject * spice_removd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  double item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &item));
  removd_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(removd_doc, "-Abstract\n\n   Remove an item from a double precision set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be removed.\n   set       I/O  Removal set.\n\n-Detailed_Input\n\n   item        is an item which is to be removed from the specified\n               set. item may or may not already be an element of the\n               set.\n\n\n   set         is a CSPICE set.  set must be declared as a double\n               precision SpiceCell.\n\n               On input, set may or may not contain the input item\n               as an element.\n\n-Detailed_Output\n\n   set         on output contains the difference of the input set and\n               the input item. If the item is not an element of the\n               set, the set is not changed.\n\n");

/* void removi_c ( SpiceInt item,SpiceCell * set ); */
static PyObject * spice_removi(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell set;
  /* variables for inputs */
  int item;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &item));
  removi_c(item, &set);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&set));
  return returnVal;
}
PyDoc_STRVAR(removi_doc, "-Abstract\n\n   Remove an item from an integer set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Item to be removed.\n   set       I/O  Removal set.\n\n-Detailed_Input\n\n   item        is an item which is to be removed from the specified\n               set. item may or may not already be an element of the\n               set.\n\n\n   set         is a CSPICE set.  set must be declared as an integer\n               SpiceCell.\n\n               On input, set may or may not contain the input item\n               as an element.\n\n-Detailed_Output\n\n   set          on output contains the difference of the input set and\n                the input item. If the item is not an element of the\n                set, the set is not changed.\n\n");

/* void repmc_c ( ConstSpiceChar * in,ConstSpiceChar * marker,
ConstSpiceChar * value,SpiceInt lenout,SpiceChar * out ); */
static PyObject * spice_repmc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar out[STRING_LEN];
  /* variables for inputs */
  char * in;
  char * marker;
  char * value;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sss", &in, &marker, &value));
  repmc_c(in, marker, value, lenout, out);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, out);
  return returnVal;
}
PyDoc_STRVAR(repmc_doc, "-Abstract\n\n   Replace a marker with a character string.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   in         I   Input string.\n   marker     I   Marker to be replaced.\n   value      I   Replacement value.\n   lenout     I   Available space in output string.\n   out        O   Output string.\n\n-Detailed_Input\n\n   in             is a character string.\n\n   marker         is character string indicating where a substring\n                  replacement is to be made. The first occurrence of\n                  marker in the input string is to be replaced by\n                  value.\n\n                  Leading and trailing blanks in marker are NOT\n                  significant. In particular, no substitution is\n                  performed if marker is blank.\n\n   value          is a replacement character string.\n\n                  Leading and trailing blanks in value are NOT\n                  significant: the portion of value that is substituted\n                  for marker extends from its first non-blank character\n                  to its last non-blank character.\n\n                  However, if value is blank or empty, a single blank\n                  is substituted for the first occurrence of marker.\n\n  lenout          is the allowed length of the output string.  This\n                  length must large enough to hold the output string\n                  plus the terminator.  If the output string is\n                  expected to have x characters, lenout should be at\n                  least x + 1.\n\n-Detailed_Output\n\n   out            is the string obtained by substituting value\n                  (leading and trailing blanks excepted) for\n                  the first occurrence of marker in the input\n                  string.\n\n                  out and in must be identical or disjoint.\n\n");

/* void repmct_c ( ConstSpiceChar * in,ConstSpiceChar * marker,SpiceInt value,
SpiceChar strCase,SpiceInt lenout,SpiceChar * out ); */
static PyObject * spice_repmct(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar out[STRING_LEN];
  /* variables for inputs */
  char * in;
  char * marker;
  int value;
  char strCase;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssis", &in, &marker, &value, &strCase));
  repmct_c(in, marker, value, strCase, lenout, out);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, out);
  return returnVal;
}
PyDoc_STRVAR(repmct_doc, "-Abstract\n\n   Replace a marker with the text representation of a\n   cardinal number.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   in         I   Input string.\n   marker     I   Marker to be replaced.\n   value      I   Replacement value.\n   repcase    I   Case of replacement text.\n   lenout     I   Available space in output string.\n   out        O   Output string.\n   MAXLCN     P   is the maximum expected length of any cardinal text.\n\n-Detailed_Input\n\n   in             is an arbitrary character string.\n\n   marker         is an arbitrary character string. The first\n                  occurrence of marker in the input string is\n                  to be replaced by the text representation of\n                  the cardinal number value.\n\n                  Leading and trailing blanks in marker are not\n                  significant. In particular, no substitution is\n                  performed if marker is blank or empty.\n\n   value          is an arbitrary integer.\n\n   repcase        indicates the case of the replacement text.\n                  repcase may be any of the following:\n\n                     repcase   Meaning       Example\n                     -------   -----------   -----------------------\n                     U, u      Uppercase     ONE HUNDRED FIFTY-THREE\n\n                     L, l      Lowercase     one hundred fifty-three\n\n                     C, c      Capitalized   One hundred fifty-three\n\n   lenout         is the allowed length of the output string.  This\n                  length must large enough to hold the output string\n                  plus the terminator.  If the output string is\n                  expected to have x characters, lenout should be at\n                  least x + 1.\n\n-Detailed_Output\n\n   out            is the string obtained by substituting the text\n                  representation of the cardinal number value for\n                  the first occurrence of marker in the input string.\n\n                  out and in must be identical or disjoint.\n\n");

/* void repmd_c ( ConstSpiceChar * in,ConstSpiceChar * marker,
SpiceDouble value,SpiceInt sigdig,SpiceInt lenout,SpiceChar * out ); */
static PyObject * spice_repmd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar out[STRING_LEN];
  /* variables for inputs */
  char * in;
  char * marker;
  double value;
  int sigdig;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdi", &in, &marker, &value, &sigdig));
  repmd_c(in, marker, value, sigdig, lenout, out);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, out);
  return returnVal;
}
PyDoc_STRVAR(repmd_doc, "-Abstract\n\n   Replace a marker with a double precision number.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   in         I   Input string.\n   marker     I   Marker to be replaced.\n   value      I   Replacement value.\n   sigdig     I   Significant digits in replacement text.\n   lenout     I   Available space in output string.\n   out        O   Output string.\n   MAXLDP     P   Maximum length of a d.p. number.\n\n-Detailed_Input\n\n   in             is an arbitrary character string.\n\n   marker         is an arbitrary character string. The first occurrence\n                  of marker in the input string is to be replaced by value.\n\n                  Leading and trailing blanks in marker are NOT significant.\n                  In particular, no substitution is performed if marker\n                  is blank.\n\n   value          is an arbitrary double precision number.\n\n   sigdig         is the number of significant digits with which value\n                  is to be represented. sigdig must be greater than\n                  zero and less than 15.\n\n   lenout         is the allowed length of the output string.  This length\n                  must large enough to hold the output string plus the\n                  terminator.  If the output string is expected to have x\n                  characters, lenout should be at least x + 1.\n\n-Detailed_Output\n\n   out            is the string obtained by substituting the text\n                  representation of value for the first occurrence\n                  of marker in the input string.\n\n                  The text representation of value is in scientific\n                  notation, having the number of significant digits\n                  specified by sigdig. The representation of value is\n                  produced by the routine dpstr_; see that routine for\n                  details concerning the representation of double\n                  precision numbers.\n\n                  out and in must be identical or disjoint.\n\n");

/* void repmf_c ( ConstSpiceChar * in,ConstSpiceChar * marker,
SpiceDouble value,SpiceInt sigdig,SpiceChar format,SpiceInt lenout,
SpiceChar * out ); */
static PyObject * spice_repmf(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar out[STRING_LEN];
  /* variables for inputs */
  char * in;
  char * marker;
  double value;
  int sigdig;
  char format;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdis", &in, &marker, &value, &sigdig, &format));
  repmf_c(in, marker, value, sigdig, format, lenout, out);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, out);
  return returnVal;
}
PyDoc_STRVAR(repmf_doc, "-Abstract\n\n   Replace a marker in a string with a formatted double precision\n   value.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   in         I   Input string.\n   marker     I   Marker to be replaced.\n   value      I   Replacement value.\n   sigdig     I   Significant digits in replacement text.\n   format     I   Format: 'E' or 'F'.\n   lenout     I   Available space in output string.\n   out        O   Output string.\n   MAXLFD     P   Maximum length of a formatted DP number.\n\n-Detailed_Input\n\n   in             is an arbitrary character string.\n\n   marker         is an arbitrary character string. The first occurrence\n                  of marker in the input string is to be replaced by value.\n\n                  Leading and trailing blanks in marker are NOT significant.\n                  In particular, no substitution is performed if marker\n                  is blank.\n\n   value          is an arbitrary double precision number.\n\n   sigdig         is the number of significant digits with which value\n                  is to be represented. sigdig must be greater than\n                  zero and less than 15.\n\n   format         is the format in which value is to be represented.\n                  format may be any of the following:\n\n                     format  Meaning      Example\n                     ------  -----------  ----------------\n                     E, e    Scientific   3.14159E+03\n                             (exponent)\n                             notation\n\n                     F, f    Fixed-point  3141.59\n                             notation\n\n   lenout         is the allowed length of the output string.  This length\n                  must large enough to hold the output string plus the\n                  terminator.  If the output string is expected to have x\n                  characters, lenout should be at least x + 1.\n\n-Detailed_Output\n\n   out            is the string obtained by substituting the text\n                  representation of value for the first occurrence\n                  of marker in the input string.\n\n                  The text representation of value is in scientific\n                  (exponent) or fixed-point notation, depending on\n                  having the value of format, and having the number\n                  of significant digits specified by sigdig.\n                  The representation of value is produced by the\n                  routine dpstrf_; see that routine for details\n                  concerning the representation of double precision\n                  numbers.\n\n                  out and in must be identical or disjoint.\n\n");

/* void repmi_c ( ConstSpiceChar * in,ConstSpiceChar * marker,SpiceInt value,
SpiceInt lenout,SpiceChar * out ); */
static PyObject * spice_repmi(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar out[STRING_LEN];
  /* variables for inputs */
  char * in;
  char * marker;
  int value;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &in, &marker, &value));
  repmi_c(in, marker, value, lenout, out);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, out);
  return returnVal;
}
PyDoc_STRVAR(repmi_doc, "-Abstract\n\n   Replace a marker with an integer.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   in         I   Input string.\n   marker     I   Marker to be replaced.\n   value      I   Replacement value.\n   lenout     I   Available space in output string.\n   out        O   Output string.\n   MAXLI      P   Maximum length of an integer.\n\n-Detailed_Input\n\n   in             is an arbitrary character string.\n\n   marker         is an arbitrary character string. The first occurrence\n                  of marker in the input string is to be replaced by value.\n\n                  Leading and trailing blanks in marker are NOT significant.\n                  In particular, no substitution is performed if marker\n                  is blank.\n\n   value          is an arbitrary integer.\n\n\n   lenout         is the allowed length of the output string.  This length\n                  must large enough to hold the output string plus the\n                  terminator.  If the output string is expected to have x\n                  characters, lenout should be at least x + 1.\n\n-Detailed_Output\n\n   out            is the string obtained by substituting the text\n                  representation of value for the first occurrence\n                  of marker in the input string.\n\n                  out and in must be identical or disjoint.\n\n");

/* void repmot_c ( ConstSpiceChar * in,ConstSpiceChar * marker,SpiceInt value,
SpiceChar strCase,SpiceInt lenout,SpiceChar * out ); */
static PyObject * spice_repmot(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar out[STRING_LEN];
  /* variables for inputs */
  char * in;
  char * marker;
  int value;
  char strCase;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssis", &in, &marker, &value, &strCase));
  repmot_c(in, marker, value, strCase, lenout, out);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, out);
  return returnVal;
}
PyDoc_STRVAR(repmot_doc, "-Abstract\n\n   Replace a marker with the text representation of an ordinal number.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   in         I   Input string.\n   marker     I   Marker to be replaced.\n   value      I   Replacement value.\n   repcase    I   Case of replacement text.\n   lenout     I   Available space in output string.\n   out        O   Output string.\n   MAXLON     P   Maximum length of an ordinal number.\n\n-Detailed_Input\n\n   in             is an arbitrary character string.\n\n   marker         is an arbitrary character string. The first\n                  occurrence of marker in the input string is\n                  to be replaced by the text representation of\n                  the ordinal number value.\n\n                  Leading and trailing blanks in marker are not\n                  significant. In particular, no substitution is\n                  performed if marker is blank or empty.\n\n   value          is an arbitrary integer.\n\n   repcase        indicates the case of the replacement text.\n                  repcase may be any of the following:\n\n                     repcase   Meaning       Example\n                     -------   -----------   -----------------------\n                     U, u      Uppercase     ONE HUNDRED FIFTY-THREE\n\n                     L, l      Lowercase     one hundred fifty-three\n\n                     C, c      Capitalized   One hundred fifty-three\n\n   lenout         is the allowed length of the output string.  This\n                  length must large enough to hold the output string\n                  plus the terminator.  If the output string is\n                  expected to have x characters, lenout should be at\n                  least x + 1.\n-Detailed_Output\n\n   out            is the string obtained by substituting the text\n                  representation of the ordinal number value for\n                  the first occurrence of marker in the input string.\n\n                  out and in must be identical or disjoint.\n\n");

/* void reset_c ( void ); */
static PyObject * spice_reset(PyObject *self, PyObject *args)
{

  char failed = 0;

  reset_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(reset_doc, "-Abstract\n\n   Reset the CSPICE error status to a value of \"no error.\"\n   As a result, the status routine, failed_c, will return a value\n   of SPICEFALSE\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   None.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   None.\n\n");

/* SpiceBoolean return_c ( void ); */
static PyObject * spice_return(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  result = return_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(return_doc, "-Abstract\n\n   True if CSPICE routines should return immediately upon entry.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n\n    The function returns the value, SPICETRUE, if and only if CSPICE\n    routines should return immediately upon entry.\n\n-Detailed_Input\n\n    None.\n\n-Detailed_Output\n\n    The function returns the value, SPICETRUE, if and only if CSPICE\n    routines should return immediately upon entry.  The criterion\n    for this is that the error response action is set to\n    \"RETURN\", and an error condition exists.\n\n");

/* void recsph_c ( ConstSpiceDouble rectan[3],SpiceDouble * r,
SpiceDouble * colat,SpiceDouble * lon ); */
static PyObject * spice_recsph(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble r;
  SpiceDouble colat;
  SpiceDouble lon;
  /* variables for inputs */
  double rectan[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &rectan[0], &rectan[1], &rectan[2]));
  recsph_c(rectan, &r, &colat, &lon);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, r, colat, lon);
  return returnVal;
}
PyDoc_STRVAR(recsph_doc, "-Abstract\n\n   Convert from rectangular coordinates to spherical coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   rectan     I   Rectangular coordinates of a point.\n   r          O   Distance of the point from the origin.\n   colat      O   Angle of the point from the positive Z-axis.\n   lon        O   Longitude of the point in radians.\n\n-Detailed_Input\n\n   rectan     The rectangular coordinates of a point.\n\n-Detailed_Output\n\n   r          Distance of the point from the origin.\n\n   colat      Angle between the point and the positive z-axis.\n\n   lon        Longitude of the point in radians.  This is the angle\n              between the positive X-axis and the orthogonal\n              projection of the point onto the XY plane.  LONG\n              increases in the counterclockwise sense about the\n              positive Z-axis.  The range of LONG is:\n\n                 -pi < LONG <= pi\n\n");

/* void rotate_c ( SpiceDouble angle,SpiceInt iaxis,SpiceDouble mout[3][3] ); */
static PyObject * spice_rotate(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[3][3];
  /* variables for inputs */
  double angle;
  int iaxis;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "di", &angle, &iaxis));
  rotate_c(angle, iaxis, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[1][0], mout[1][1], mout[1][2], mout[2][0], mout[2][1], mout[2][2]);
  return returnVal;
}
PyDoc_STRVAR(rotate_doc, "-Abstract\n\n   Calculate the 3x3 rotation matrix generated by a rotation\n   of a specified angle about a specified axis. This rotation\n   is thought of as rotating the coordinate system.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   angle      I   Angle of rotation (radians).\n   iaxis      I   Axis of rotation (X=1, Y=2, Z=3).\n   mout       O   Resulting rotation matrix [angle]\n                                                   iaxis\n-Detailed_Input\n\n   angle   The angle given in radians, through which the rotation\n           is performed.\n\n   iaxis   The index of the axis of rotation.  The X, Y, and Z\n           axes have indices 1, 2 and 3 respectively.\n\n-Detailed_Output\n\n   mout    Rotation matrix which describes the rotation of the\n           COORDINATE system through angle radians about the\n           axis whose index is iaxis.\n\n");

/* void rotmat_c ( ConstSpiceDouble m1[3][3],SpiceDouble angle,SpiceInt iaxis,
SpiceDouble mout[3][3] ); */
static PyObject * spice_rotmat(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[3][3];
  /* variables for inputs */
  double m1[3][3];
  double angle;
  int iaxis;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))di", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2], &angle, &iaxis));
  rotmat_c(m1, angle, iaxis, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[1][0], mout[1][1], mout[1][2], mout[2][0], mout[2][1], mout[2][2]);
  return returnVal;
}
PyDoc_STRVAR(rotmat_doc, "-Abstract\n\n   rotmat_c applies a rotation of angle radians about axis iaxis to a\n   matrix.  This rotation is thought of as rotating the coordinate\n   system.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   m1        I     Matrix to be rotated.\n   angle     I     Angle of rotation (radians).\n   iaxis     I     Axis of rotation (X=1, Y=2, Z=3).\n   mout      O     Resulting rotated matrix.\n\n-Detailed_Input\n\n   m1      This is a matrix to which a rotation is to be applied.\n           In matrix algebra, the components of the matrix are\n           relative to one particular coordinate system. Applying\n           rotmat_c changes the components of m1 so that they are\n           relative to a rotated coordinate system.\n\n   angle   The angle in radians through which the original\n           coordinate system is to be rotated.\n\n   iaxis   An index for the axis of the original coordinate system\n           about which the rotation by angle is to be performed.\n           iaxis = 1,2 or 3 designates the x-, y- or z-axis,\n           respectively.\n\n-Detailed_Output\n\n   mout    The matrix resulting from the application of the\n           specified rotation to the input matrix m1.  If\n\n              [angle]\n                    iaxis\n\n           denotes the rotation matrix by angle radians about iaxis,\n           (see the Rotations Required Reading document) then mout is\n           given by the following matrix equation:\n\n              mout = [angle]      * m1\n                            iaxis\n\n           mout can overwrite m1.\n\n");

/* void rotvec_c ( ConstSpiceDouble v1[3],SpiceDouble angle,SpiceInt iaxis,
SpiceDouble vout[3] ); */
static PyObject * spice_rotvec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double v1[3];
  double angle;
  int iaxis;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)di", &v1[0], &v1[1], &v1[2], &angle, &iaxis));
  rotvec_c(v1, angle, iaxis, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(rotvec_doc, "-Abstract\n\n   Transform a vector to a new coordinate system rotated by angle\n   radians about axis iaxis.  This transformation rotates v1 by\n   -angle radians about the specified axis.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1        I    Vector whose coordinate system is to be rotated.\n   angle     I    Angle of rotation in radians.\n   iaxis     I    Axis of rotation (X=1, Y=2, Z=3).\n   vout      O    Resulting vector [angle]      * v1 expressed in\n                                          iaxis\n                  the new coordinate system. vout can overwrite v1.\n\n-Detailed_Input\n\n   v1      This is a vector (typically representing a vector fixed\n           in inertial space) which is to be expressed in another\n           coordinate system.  The vector remains fixed but the\n           coordinate system changes.\n\n   angle   The angle given in radians, through which the rotation\n           is performed.\n\n   iaxis   The index of the axis of rotation.  The X, Y, and Z\n           axes have indices 1, 2 and 3 respectively.\n\n-Detailed_Output\n\n   vout    This is the vector expressed in the new coordinate system\n           specified by the angle of rotation and axis. If\n           [angle]       represents the rotation matrix described by\n                  iaxis\n           the angle and axis, (refer to the routine ROTATE)\n           then vout = [angle]      * v1\n                              iaxis\n\n");

/* SpiceDouble rpd_c ( void ); */
static PyObject * spice_rpd(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = rpd_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(rpd_doc, "-Abstract\n\n   Return the number of radians per degree.\n\n-Brief_I/O\n\n   The function returns the number of radians per degree.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the number of radians per degree: pi/180.\n   The value of pi is determined by the ACOS function. That is,\n\n      rpd = acos ( -1. ) / 180.\n\n");

/* void rquad_c ( SpiceDouble a,SpiceDouble b,SpiceDouble c,
SpiceDouble root1[2],SpiceDouble root2[2] ); */
static PyObject * spice_rquad(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble root1[2];
  SpiceDouble root2[2];
  /* variables for inputs */
  double a;
  double b;
  double c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &a, &b, &c));
  rquad_c(a, b, c, root1, root2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dd)");
  strcat(buildvalue_string, "(dd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, root1[0], root1[1], root2[0], root2[1]);
  return returnVal;
}
PyDoc_STRVAR(rquad_doc, "-Abstract\n\n   Find the roots of a quadratic equation.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n\n   a          I   Coefficient of quadratic term.\n   b          I   Coefficient of linear term.\n   c          I   Constant.\n   root1      O   Root built from positive discriminant term.\n   root2      O   Root built from negative discriminant term.\n\n-Detailed_Input\n\n   a,\n   b,\n   c              are the coefficients of a quadratic polynomial\n\n                       2\n                     ax   +   bx   +   c.\n\n-Detailed_Output\n\n   root1,\n   root2         are the roots of the equation,\n\n                       2\n                     ax   +   bx   +   c   =  0.\n\n\n                 root1 and root2 are both arrays of length 2.  The\n                 first element of each array is the real part of a\n                 root; the second element contains the complex part\n                 of the same root.\n\n                 When a is non-zero, root1 represents the root\n\n                                  _____________\n                                 /  2\n                    - b   +    \\/  b    -   4ac\n                    ---------------------------\n                                  2a\n\n\n                 and root2 represents the root\n\n                                  _____________\n                                 /  2\n                    - b   -    \\/  b    -   4ac\n                    --------------------------- .\n                                  2a\n\n\n                 When a is zero and b is non-zero, root1 and root2\n                 both represent the root\n\n                    - c / b.\n\n");

/* void saelgv_c ( ConstSpiceDouble vec1 [3],ConstSpiceDouble vec2 [3],
SpiceDouble smajor[3],SpiceDouble sminor[3] ); */
static PyObject * spice_saelgv(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble smajor[3];
  SpiceDouble sminor[3];
  /* variables for inputs */
  double vec1[3];
  double vec2[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &vec1[0], &vec1[1], &vec1[2], &vec2[0], &vec2[1], &vec2[2]));
  saelgv_c(vec1, vec2, smajor, sminor);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, smajor[0], smajor[1], smajor[2], sminor[0], sminor[1], sminor[2]);
  return returnVal;
}
PyDoc_STRVAR(saelgv_doc, "-Abstract\n\n   Find semi-axis vectors of an ellipse generated by two arbitrary\n   three-dimensional vectors.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   vec1,\n   vec2       I   Two vectors used to generate an ellipse.\n   smajor     O   Semi-major axis of ellipse.\n   sminor     O   Semi-minor axis of ellipse.\n\n-Detailed_Input\n\n   vec1,\n   vec2           are two vectors that define an ellipse.\n                  The ellipse is the set of points in 3-space\n\n                     center  +  cos(theta) vec1  +  sin(theta) vec2\n\n                  where theta is in the interval ( -pi, pi ] and\n                  center is an arbitrary point at which the ellipse\n                  is centered.  An ellipse's semi-axes are\n                  independent of its center, so the vector center\n                  shown above is not an input to this routine.\n\n                  vec2 and vec1 need not be linearly independent;\n                  degenerate input ellipses are allowed.\n\n-Detailed_Output\n\n   smajor\n   sminor         are semi-major and semi-minor axes of the ellipse,\n                  respectively.  smajor and sminor may overwrite\n                  either of vec1 or vec2.\n\n");

/* void scard_c ( SpiceInt card,SpiceCell * cell ); */
static PyObject * spice_scard(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cell;
  /* variables for inputs */
  int card;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &card));
  scard_c(card, &cell);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cell));
  return returnVal;
}
PyDoc_STRVAR(scard_doc, "-Abstract\n\n   Set the cardinality of a SPICE cell of any data type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   card       I   Cardinality of (number of elements in) the cell.\n   cell       O   The cell.\n\n-Detailed_Input\n\n   card         is the cardinality of (number of elements in) the\n                cell.\n\n-Detailed_Output\n\n   cell         is a SpiceCell of any data type. On output, the\n                cardinality of the cell is card.  The data portion of\n                the cell is left unchanged.\n\n                If the cardinality is set to zero, the cell becomes a\n                CSPICE set:  the cell's \"is a set?\" attribute becomes\n                true.  The cell then can be used as an input to the\n                CSPICE set routines such as insrt*_c.\n\n");

/* void scdecd_c ( SpiceInt sc,SpiceDouble sclkdp,SpiceInt sclklen,
SpiceChar * sclkch ); */
static PyObject * spice_scdecd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar sclkch[STRING_LEN];
  /* variables for inputs */
  int sc;
  double sclkdp;
  int sclklen = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "id", &sc, &sclkdp));
  scdecd_c(sc, sclkdp, sclklen, sclkch);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sclkch);
  return returnVal;
}
PyDoc_STRVAR(scdecd_doc, "-Abstract\n\n   Convert double precision encoding of spacecraft clock time into\n   a character representation.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft identification code.\n   sclkdp     I   Encoded representation of a spacecraft clock count.\n   lenout     I   Maximum allowed length of output SCLK string.\n   sclkch     O   Character representation of a clock count.\n   MXPART     P   Maximum number of spacecraft clock partitions.\n\n-Detailed_Input\n\n   sc         is the NAIF integer code of the spacecraft whose\n              clock's time is being decoded.\n\n   sclkdp     is the double precision encoding of a clock time in\n              units of ticks since the spacecraft clock start time.\n              This value does reflect partition information.\n\n              An analogy may be drawn between a spacecraft clock\n              and a standard wall clock. The number of ticks\n              corresponding to the wall clock string\n\n                              hh:mm:ss\n\n              would be the number of seconds represented by that\n              time.\n\n              For example:\n\n                    Clock string      Number of ticks\n                    ------------      ---------------\n                      00:00:10              10\n                      00:01:00              60\n                      00:10:00             600\n                      01:00:00            3600\n\n              If sclkdp contains a fractional part the result\n              is the same as if sclkdp had been rounded to the\n              nearest whole number.\n\n\n   lenout     is the maximum number of characters that can be\n              accommodated in the output string.  This count\n              includes room for the terminating null character.\n              For example, if the maximum allowed length of the\n              output string, including the terminating null, is 25\n              characters, then lenout should be set to 25.\n\n-Detailed_Output\n\n   sclkch     is the character representation of the clock count.\n              The exact form that sclkch takes depends on the\n              spacecraft.\n\n              Nevertheless, sclkch will have the following general\n              format:\n\n                           \"pp/sclk_string\"\n\n              \"pp\" is an integer greater than or equal to one and\n              represents a \"partition number\".\n\n              Each mission is divided into some number of partitions.\n              A new partition starts when the spacecraft clock\n              resets, either to zero, or to some other\n              value. Thus, the first partition for any mission\n              starts with launch, and ends with the first clock\n              reset. The second partition starts immediately when\n              the first stopped, and so on.\n\n              In order to be completely unambiguous about a\n              particular time, you need to specify a partition number\n              along with the standard clock string.\n\n              Information about when partitions occur for different\n              missions is contained in a spacecraft clock kernel\n              file which needs to be loaded into the kernel pool\n              before calling scdecd_c.\n\n              The routine scpart_c may be used to read the partition\n              start and stop times, in encoded units of ticks, from\n              the kernel file.\n\n              Since the end time of one partition is coincident with\n              the begin time of the next, two different time strings\n              with different partition numbers can encode into the\n              same value.\n\n              For example, if partition 1 ends at time t1, and\n              partition 2 starts at time t2, then\n\n                 \"1/t1\" and \"2/t2\"\n\n              will be encoded into the same value, say X. scdecd_c\n              always decodes such values into the latter of the\n              two partitions. In this example,\n\n                 scdecd_c ( x, sc, MAXLEN, clkstr )\n\n              will result in\n\n                 clkstr = \"2/t2\".\n\n\n              \"sclk_string\" is a spacecraft specific clock string,\n              typically consisting of a number of components\n              separated by delimiters.\n\n              Using Galileo as an example, the full format is\n\n                 wwwwwwww:xx:y:z\n\n              where z is a mod-8 counter (values 0-7) which\n              increments approximately once every 8 1/3 ms., y is a\n              mod-10 counter (values 0-9) which increments once\n              every time z turns over, i.e., approximately once every\n              66 2/3 ms., xx is a mod-91 (values 0-90) counter\n              which increments once every time y turns over, i.e.,\n              once every 2/3 seconds. wwwwwwww is the Real-Time Image\n              Count (RIM), which increments once every time xx turns\n              over, i.e., once every 60 2/3 seconds. The roll-over\n              expression for the RIM is 16777215, which corresponds\n              to approximately 32 years.\n\n              wwwwwwww, xx, y, and z are referred to interchangeably\n              as the fields or components of the spacecraft clock.\n              SCLK components may be separated by any of these five\n              characters: \" \"  \":\"  \",\"  \"-\"  \".\"\n              The delimiter used is determined by a kernel pool\n              variable and can be adjusted by the user.\n\n              Some spacecraft clock components have offset, or\n              starting, values different from zero.  For example,\n              with an offset value of 1, a mod 20 counter would\n              cycle from 1 to 20 instead of from 0 to 19.\n\n              See the SCLK required reading for a detailed\n              description of the Voyager and Mars Observer clock\n              formats.\n\n\n");

/* void sce2s_c ( SpiceInt sc,SpiceDouble et,SpiceInt sclklen,
SpiceChar * sclkch ); */
static PyObject * spice_sce2s(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar sclkch[STRING_LEN];
  /* variables for inputs */
  int sc;
  double et;
  int sclklen = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "id", &sc, &et));
  sce2s_c(sc, et, sclklen, sclkch);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sclkch);
  return returnVal;
}
PyDoc_STRVAR(sce2s_doc, "-Abstract\n\n   Convert an epoch specified as ephemeris seconds past J2000 (ET) to a\n   character string representation of a spacecraft clock value (SCLK).\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft clock ID code.\n   et         I   Ephemeris time, specified as seconds past J2000.\n   lenout     I   Maximum length of output string.\n   sclkch     O   An SCLK string.\n\n-Detailed_Input\n\n   sc             is a NAIF ID code for a spacecraft clock whose\n                  reading at the epoch specified by `et' is desired.\n\n   et             is an epoch, specified as ephemeris seconds past\n                  J2000 TDB.\n\n   lenout         is the maximum number of characters that can be\n                  accommodated in the output string.  This count\n                  includes room for the terminating null character. For\n                  example, if the maximum allowed length of the output\n                  string, including the terminating null, is 25\n                  characters, then `lenout' should be set to 25.\n\n                  In order to choose an appropriate value of `lenout',\n                  you can examine an SCLK kernel for the clock specified\n                  by `sc'.  The format of string representations of\n                  the clock's values is specified by kernel variables\n                  associated with the clock.  See Examples below for\n                  further information.\n\n-Detailed_Output\n\n   sclkch         is a character string representation of the\n                  spacecraft clock value that corresponds to `et', for\n                  the spacecraft clock specified by the input argument\n                  `sc'. `sclkch' is an absolute spacecraft clock value,\n                  so a partition number is included in the string. The\n                  format of `sclkch' is specified in the SCLK kernel\n                  for the clock `sc'.  A general discussion of\n                  spacecraft clock string formats is available in the\n                  SCLK Required Reading.\n\n");

/* void sce2c_c ( SpiceInt sc,SpiceDouble et,SpiceDouble * sclkdp ); */
static PyObject * spice_sce2c(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sclkdp;
  /* variables for inputs */
  int sc;
  double et;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "id", &sc, &et));
  sce2c_c(sc, et, &sclkdp);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sclkdp);
  return returnVal;
}
PyDoc_STRVAR(sce2c_doc, "-Abstract\n\n   Convert ephemeris seconds past J2000 (ET) to continuous encoded\n   spacecraft clock (`ticks').  Non-integral tick values may be\n   returned.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft ID code.\n   et         I   Ephemeris time, seconds past J2000.\n   sclkdp     O   SCLK, encoded as ticks since spacecraft clock\n                  start.  sclkdp need not be integral.\n\n-Detailed_Input\n\n   sc             is a NAIF integer code for a spacecraft whose\n                  encoded SCLK value at the epoch specified by et is\n                  desired.\n\n   et             is an epoch, specified as ephemeris seconds past\n                  J2000.\n\n-Detailed_Output\n\n   sclkdp         is an encoded spacecraft clock value.  sclkdp is\n                  an encoded representation of the total number\n                  of spacecraft clock ticks measured from the time\n                  the spacecraft clock started to the epoch et:\n                  partition information IS reflected in the encoded\n                  value.\n\n                  sclkdp may be non-integral:  sclkdp is NOT\n                  rounded to the nearest whole tick.\n\n");

/* void sce2t_c ( SpiceInt sc,SpiceDouble et,SpiceDouble * sclkdp ); */
static PyObject * spice_sce2t(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sclkdp;
  /* variables for inputs */
  int sc;
  double et;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "id", &sc, &et));
  sce2t_c(sc, et, &sclkdp);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sclkdp);
  return returnVal;
}
PyDoc_STRVAR(sce2t_doc, "-Abstract\n\n   Convert ephemeris seconds past J2000 (ET) to integral\n   encoded spacecraft clock (`ticks'). For conversion to\n   fractional ticks, (required for C-kernel production), see\n   the routine sce2c_c..\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft ID code.\n   et         I   Ephemeris time, seconds past J2000.\n   sclkdp     O   SCLK, encoded as ticks since spacecraft clock\n                  start.\n\n-Detailed_Input\n\n   sc             is a NAIF integer code for a spacecraft whose encoded\n                  SCLK value at the epoch specified by `et' is desired.\n\n   et             is an epoch, specified as ephemeris seconds past\n                  J2000.\n\n-Detailed_Output\n\n   sclkdp         is an encoded integral spacecraft clock value.\n                  `sclkdp' is an encoded representation of the total\n                  count of spacecraft clock ticks measured from the\n                  time the spacecraft clock started to the epoch `et':\n                  partition information IS reflected in the encoded\n                  value. `sclkdp' is rounded to the nearest integral\n                  double precision number.\n\n");

/* void scencd_c ( SpiceInt sc,ConstSpiceChar * sclkch,
SpiceDouble * sclkdp ); */
static PyObject * spice_scencd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sclkdp;
  /* variables for inputs */
  int sc;
  char * sclkch;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "is", &sc, &sclkch));
  scencd_c(sc, sclkch, &sclkdp);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sclkdp);
  return returnVal;
}
PyDoc_STRVAR(scencd_doc, "-Abstract\n\n   Encode character representation of spacecraft clock time into a\n   double precision number.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft identification code.\n   sclkch     I   Character representation of a spacecraft clock.\n   sclkdp     O   Encoded representation of the clock count.\n   MXPART     P   Maximum number of spacecraft clock partitions.\n\n-Detailed_Input\n\n   sc         is the standard NAIF ID of the spacecraft whose clock's\n              time is being encoded.\n\n   sclkch     is the character representation of some spacecraft's\n              clock count.\n\n              sclkch will have the following general format:\n\n                           \"pp/sclk_string\", or just\n                              \"sclk_string\"\n\n              \"pp\" is an integer greater than or equal to one\n              and is called the partition number.\n\n              Each mission is divided into some number of partitions.\n              A new partition starts when the spacecraft clock\n              resets, either to zero, or to some other\n              value. Thus, the first partition for any mission\n              starts with launch, and ends with the first clock\n              reset. The second partition starts immediately when\n              the first stopped, and so on.\n\n              In order to be completely unambiguous about a\n              particular time, you need to specify a partition number\n              along with the standard clock string.\n\n              Information about when partitions occur for different\n              missions is contained in a spacecraft clock kernel\n              file, which needs to be loaded into the kernel pool,\n              using the routine furnsh_c.\n\n              The routine scpart_c is used to read the partition\n              start and stop times, in encoded units of SCLK (called\n              \"ticks\" -- see sclkdp below) from the kernel file.\n\n              If the partition number is included, it must be\n              separated from the rest of the string by a \"/\".\n              Any number of spaces may separate the partition number,\n              the \"/\", and the rest of the clock string.\n\n\n              If the partition number is omitted, a default partition\n              will be assumed. The default partition is the lowest-\n              numbered partition that contains the given clock time.\n              If the clock time does not fall in any of the\n              partition boundaries then an error is signalled.\n\n\n              \"sclk_string\" is a spacecraft specific clock string.\n              Using Galileo as an example, the full format is\n\n                             wwwwwwww:xx:y:z\n\n              where z is a mod-8 counter (values 0-7) which\n              increments approximately once every 8 1/3 ms., y is a\n              mod-10 counter (values 0-9) which increments once\n              every time z turns over, i.e., approximately once every\n              66 2/3 ms., xx is a mod-91 (values 0-90) counter\n              which increments once every time y turns over, i.e.,\n              once every 2/3 seconds. wwwwwwww is the Real-Time Image\n              Count (RIM), which increments once every time xx turns\n              over, i.e., once every 60 2/3 seconds. The roll-over\n              expression for the RIM is 16777215, which corresponds\n              to approximately 32 years.\n\n              wwwwwwww, xx, y, and z are referred to interchangeably\n              as the fields or components of the spacecraft clock.\n              SCLK components may be separated by any of these\n              five characters: \" \"  \":\"  \",\"  \"-\"  \".\"\n              Any number of spaces can separate the components and\n              the delimiters. The presence of the RIM component\n              is required. Successive components may be omitted, and\n              in such cases are assumed to represent zero values.\n\n              Values for the individual components may exceed the\n              maximum expected values. For instance, \"0:0:0:9\" is\n              an acceptable Galileo clock string, and will convert\n              to the same number of ticks as \"0:0:1:1\".\n\n              Consecutive delimiters containing no intervening digits\n              are treated as if they delimit zero components.\n\n              Trailing zeros should always be included to match the\n              length of the counter.  For example, a Galileo clock\n              count of \"25684.90\" should not be represented as\n              \"25684.9\".\n\n              Some spacecraft clock components have offset, or\n              starting, values different from zero.  For example,\n              with an offset value of 1, a mod 20 counter would\n              cycle from 1 to 20 instead of from 0 to 19.\n\n              See the SCLK required reading for a detailed\n              description of the Voyager and Mars Observer clock\n              formats.\n\n\n-Detailed_Output\n\n   sclkdp     is the double precision encoding of sclkch.\n\n              The encoding is such that order and proximity will be\n              preserved. That is, if t1, t2, and t3 are spacecraft\n              clock times, and t1*, t2*, and t3* are their encodings,\n              then if\n\n                            t1 < t2 < t3, and\n\n              t2 is closer to t1 than to t3, you will have the result\n              that\n\n                           t1* < t2* < t3*, and\n\n              t2* is closer to t1* than to t3*.\n\n              The units of encoded SCLK are \"ticks since the start of\n              the mission\", where a \"tick\" is defined to be the\n              shortest time increment expressible by a particular\n              spacecraft's clock.\n\n              Each clock string without partition number represents\n              a certain number of ticks, but you need to include\n              partition information to determine the relative\n              position of that time in relation to the start of the\n              mission.\n\n              Since the end time of one partition is coincident\n              with the begin time of the next, there are two\n              different representations for this instant, and they\n              will both yield the same encoding.\n\n              For example, if partition 1 has an end time of t1, and\n              partition 2 has a begin time of t2, then if we executed\n              the code fragment\n\n                 scencd_c ( \"1/t1\", sc, &x );\n                 scencd_c ( \"2/t2\", sc, &y );\n\n              The we would obtain x = y.\n\n              The individual routines tiksNN_c, where NN is the\n              clock type code, contain more detailed information\n              on the conversion process.\n\n");

/* void scfmt_c ( SpiceInt sc,SpiceDouble ticks,SpiceInt clkstrlen,
SpiceChar * clkstr ); */
static PyObject * spice_scfmt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar clkstr[STRING_LEN];
  /* variables for inputs */
  int sc;
  double ticks;
  int clkstrlen = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "id", &sc, &ticks));
  scfmt_c(sc, ticks, clkstrlen, clkstr);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, clkstr);
  return returnVal;
}
PyDoc_STRVAR(scfmt_doc, "-Abstract\n\n   Convert encoded spacecraft clock ticks to character clock format.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft identification code.\n   ticks      I   Encoded representation of a spacecraft clock count.\n   lenout     I   Maximum allowed length of output string.\n   clkstr     O   Character representation of a clock count.\n\n-Detailed_Input\n\n   sc         is the NAIF ID number for the spacecraft whose clock's\n              time is being decoded.\n\n   ticks      is the double precision encoding of a clock time in\n              units of ticks.  Partition information is not reflected\n              in this value.\n\n              An analogy may be drawn between a spacecraft clock and\n              a standard wall clock.  The number of ticks\n              corresponding to the wall clock string\n\n                 hh:mm:ss\n\n              would be the number of seconds represented by that\n              time.\n\n              For example,\n\n                 Clock string    Number of ticks\n                 ------------    ---------------\n                   00:00:10             10\n                   00:01:00             60\n                   00:10:00            600\n                   01:00:00           3600\n                   01:01:00           3660\n\n              If ticks contains a fractional part the result is the\n              same as if ticks had been rounded to the nearest whole\n              number.\n\n              See the Examples section below for examples of\n              actual spacecraft clock conversions.\n\n   lenout     The allowed length of the output string.  This length\n              must large enough to hold the 'clkstr' string plus the\n              null terminator.  If the output string is expected to\n              have x characters, 'lenout' must be x + 1.\n\n-Detailed_Output\n\n   clkstr     is the spacecraft clock character string\n              corresponding to ticks.  Partition information is\n              not included in clkstr.\n\n              Using Galileo as an example, the full format clock\n              string is\n\n                 wwwwwwww:xx:y:z\n\n              where z is a mod-8 counter (values 0-7) which\n              increments approximately once every 8 1/3 ms., y is a\n              mod-10 counter (values 0-9) which increments once\n              every time z turns over, i.e., approximately once every\n              66 2/3 ms., xx is a mod-91 (values 0-90) counter\n              which increments once every time y turns over, i.e.,\n              once every 2/3 seconds. wwwwwwww is the Real-Time Image\n              Count (RIM), which increments once every time xx turns\n              over, i.e., once every 60 2/3 seconds. The roll-over\n              expression for the RIM is 16777215, which corresponds\n              to approximately 32 years.\n\n              wwwwwwww, xx, y, and z are referred to interchangeably\n              as the fields or components of the spacecraft clock.\n              SCLK components may be separated by any of these five\n              characters: \" \"  \":\"  \",\"  \"-\"  \".\"\n              The delimiter used is determined by a kernel pool\n              variable and can be adjusted by the user.\n\n              Some spacecraft clock components have offset, or\n              starting, values different from zero.  For example,\n              with an offset value of 1, a mod 20 counter would\n              cycle from 1 to 20 instead of from 0 to 19.\n\n              See the SCLK required reading for a detailed\n              description of the Voyager and Mars Observer clock\n              formats.\n\n");

/* void scpart_c ( SpiceInt sc,SpiceInt * nparts,SpiceDouble * pstart,
SpiceDouble * pstop ); */
static PyObject * spice_scpart(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt nparts;
  SpiceDouble pstart;
  SpiceDouble pstop;
  /* variables for inputs */
  int sc;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &sc));
  scpart_c(sc, &nparts, &pstart, &pstop);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, nparts, pstart, pstop);
  return returnVal;
}
PyDoc_STRVAR(scpart_doc, "-Abstract\n\n   Get spacecraft clock partition information from a spacecraft\n   clock kernel file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft identification code.\n   nparts     O   The number of spacecraft clock partitions.\n   pstart     O   Array of partition start times.\n   pstop      O   Array of partition stop times.\n   MXPART     P   Maximum number of partitions.\n\n-Detailed_Input\n\n   sc         is the NAIF ID for the spacecraft whose clock partition\n              information is being requested.\n\n-Detailed_Output\n\n   nparts     is the number of spacecraft clock time partitions\n              described in the kernel file for spacecraft SC.\n\n   pstart     is an array containing nparts partition start times\n              represented as encoded ticks.  The values contained\n              in pstart are whole numbers.\n\n   pstop      is an array containing nparts partition end times\n              represented as encoded ticks. The values contained\n              in pstop are whole numbers.\n\n");

/* void scs2e_c ( SpiceInt sc,ConstSpiceChar * sclkch,SpiceDouble * et ); */
static PyObject * spice_scs2e(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble et;
  /* variables for inputs */
  int sc;
  char * sclkch;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "is", &sc, &sclkch));
  scs2e_c(sc, sclkch, &et);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, et);
  return returnVal;
}
PyDoc_STRVAR(scs2e_doc, "-Abstract\n\n   Convert a spacecraft clock string to ephemeris seconds past\n   J2000 (ET).\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF integer code for a spacecraft.\n   sclkch     I   An SCLK string.\n   et         O   Ephemeris time, seconds past J2000.\n\n-Detailed_Input\n\n   sc             is a NAIF ID code for a spacecraft, one of whose\n                  clock values is represented by sclkch.  The set of\n                  supported spacecraft clocks is listed in the SCLK\n                  Required Reading.\n\n   sclkch         is a character string representation of the\n                  spacecraft clock value that corresponds to ET, for\n                  the spacecraft specified by the input argument sc.\n                  sclkch is an absolute spacecraft clock time, so\n                  partition information should be included in this\n                  string.  The precise format of sclkch is specified\n                  in the SCLK Required Reading.\n\n-Detailed_Output\n\n   et             is the epoch, specified as ephemeris seconds past\n                  J2000, that corresponds to sclkch.\n\n");

/* void sct2e_c ( SpiceInt sc,SpiceDouble sclkdp,SpiceDouble * et ); */
static PyObject * spice_sct2e(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble et;
  /* variables for inputs */
  int sc;
  double sclkdp;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "id", &sc, &sclkdp));
  sct2e_c(sc, sclkdp, &et);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, et);
  return returnVal;
}
PyDoc_STRVAR(sct2e_doc, "-Abstract\n\n   Convert encoded spacecraft clock (`ticks') to ephemeris\n   seconds past J2000 (ET).\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft ID code.\n   sclkdp     I   SCLK, encoded as ticks since spacecraft clock\n                  start.\n   et         O   Ephemeris time, seconds past J2000.\n\n-Detailed_Input\n\n   sc             is a NAIF integer code for a spacecraft, one of\n                  whose encoded clock values is represented by\n                  sclkdp.\n\n   sclkdp         is an encoded spacecraft clock value.  sclkdp\n                  represents time measured from spacecraft clock\n                  start:  partition information IS reflected in the\n                  encoded value.\n\n-Detailed_Output\n\n   et             is the epoch, specified as ephemeris seconds past\n                  J2000, that corresponds to sclkdp.\n\n");

/* void sctiks_c ( SpiceInt sc,ConstSpiceChar * clkstr,SpiceDouble * ticks ); */
static PyObject * spice_sctiks(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble ticks;
  /* variables for inputs */
  int sc;
  char * clkstr;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "is", &sc, &clkstr));
  sctiks_c(sc, clkstr, &ticks);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, ticks);
  return returnVal;
}
PyDoc_STRVAR(sctiks_doc, "-Abstract\n\n   Convert a spacecraft clock format string to number of \"ticks\".\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   sc         I   NAIF spacecraft identification code.\n   clkstr     I   Character representation of a spacecraft clock.\n   ticks      O   Number of ticks represented by the clock string.\n\n-Detailed_Input\n\n   sc         is the NAIF ID number for the spacecraft whose clock\n              string is being converted.\n\n   clkstr     is a character string representing a spacecraft clock\n              time, WITHOUT PARTITION NUMBER.\n\n              Using Galileo as an example, the full format is\n\n                 wwwwwwww:xx:y:z\n\n              where z is a mod-8 counter (values 0-7) which\n              increments approximately once every 8 1/3 ms., y is a\n              mod-10 counter (values 0-9) which increments once\n              every time z turns over, i.e., approximately once every\n              66 2/3 ms., xx is a mod-91 (values 0-90) counter\n              which increments once every time y turns over, i.e.,\n              once every 2/3 seconds. wwwwwwww is the Real-Time Image\n              Count (RIM), which increments once every time xx turns\n              over, i.e., once every 60 2/3 seconds. The roll-over\n              expression for the RIM is 16777215, which corresponds\n              to approximately 32 years.\n\n              wwwwwwww, xx, y, and z are referred to interchangeably\n              as the fields or components of the spacecraft clock.\n              SCLK components may be separated by any of the\n              following characters: \" \"  \".\"  \":\"  \",\"  \"-\"\n              Any number of spaces may separate the components and\n              the delimiters. The presence of the RIM component\n              is required. Successive components may be omitted, and\n              in such cases are assumed to represent zero values.\n\n              Values for the individual components may exceed the\n              maximum expected values. For instance, \"0:0:0:9\" is\n              an acceptable Galileo clock string, and will convert\n              to the same number of ticks as \"0:0:1:1\".\n\n              Consecutive delimiters containing no intervening digits\n              are treated as if they delimit zero components.\n\n              Trailing zeros should always be included to match the\n              length of the counter.  For example, a Galileo clock\n              count of \"25684.90\" should not be represented as\n              \"25684.9\".\n\n              Some spacecraft clock components have offset, or\n              starting, values different from zero.  For example,\n              with an offset value of 1, a mod 20 counter would\n              cycle from 1 to 20 instead of from 0 to 19.\n\n              See the SCLK required reading for a detailed\n              description of the Voyager and Mars Observer clock\n              formats.\n\n\n-Detailed_Output\n\n   ticks      is the number of ticks represented by the spacecraft\n              clock string. A tick is defined to be the smallest\n              time increment expressible by the spacecraft clock.\n\n              An analogy may be drawn between a spacecraft clock\n              and a standard wall clock, measuring hours, minutes\n              and seconds. The number of ticks represented by the\n              wall clock string\n\n                 hh:mm:ss\n\n              would be the number of seconds represented by that\n              time.\n\n              For example:\n\n                 00:00:10  would convert to 10\n                 00:01:00  would convert to 60\n                 00:10:00  would convert to 600\n                 01:00:00  would convert to 3600\n                 01:01:00  would convert to 3660\n\n              See the Examples section below for examples for\n              actual spacecraft clocks.\n\n");

/* void sdiff_c ( SpiceCell * a,SpiceCell * b,SpiceCell * c ); */
static PyObject * spice_sdiff(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  SpiceCell b;
  SpiceCell c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  sdiff_c(&a, &b, &c);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a), get_py_cell(&b), get_py_cell(&c));
  return returnVal;
}
PyDoc_STRVAR(sdiff_doc, "-Abstract\n\n   Take the symmetric difference of two sets of any data type to form a\n   third set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   First input set.\n   b          I   Second input set.\n   c          O   Symmetric difference of a and b.\n\n-Detailed_Input\n\n   a           is a CSPICE set.  a must be declared as a SpiceCell\n               of data type character, double precision, or integer.\n\n   b           is a CSPICE set, distinct from a.  b must have the\n               same data type as a.\n\n-Detailed_Output\n\n   c           is a CSPICE set, distinct from sets a and b, which\n               contains the symmetric difference of a and b (that is,\n               all of the elements which are in a or in b but not in\n               both). c must have the same data type as a and b.\n\n               When comparing elements of character sets, this routine\n               ignores trailing blanks.  Trailing blanks will be\n               trimmed from the members of the output set c.\n\n");

/* SpiceBoolean set_c ( SpiceCell * a,ConstSpiceChar * op,SpiceCell * b ); */
static PyObject * spice_set(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell b;
  /* variables for inputs */
  SpiceCell * a;
  PyObject * py_a = NULL;
  char * op;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "Os", &py_a, &op));
  a = get_spice_cell(py_a);

  result = set_c(a, op, &b);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&b));
  return returnVal;
}
PyDoc_STRVAR(set_doc, "-Abstract\n\n   Given a relational operator, compare two sets of any data type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   First set.\n   op         I   Comparison operator.\n   b          I   Second set.\n\n   The function returns the result of the comparison: a (op) b.\n\n-Detailed_Input\n\n\n   a           is a CSPICE set.  a must be declared as a character,\n               double precision, or integer SpiceCell.\n\n\n   op          is a comparison operator, indicating the way in\n               which the input sets are to be compared. op may\n               be any of the following:\n\n                  Operator             Meaning\n                  --------  -------------------------------------\n                    \"=\"     a = b is true if a and b are equal\n                            (contain the same elements).\n\n                    \"<>\"    a <> b is true if a and b are not\n                            equal.\n\n                    \"<=\"    a <= b is true if a is a subset of b.\n\n                    \"<\"     a < b is true if a is a proper subset\n                            of b.\n\n                    \">=\"    a >= b is true if b is a subset of a.\n\n                    \">\"     a > b is true if b is a proper subset\n                            of a.\n\n                    \"&\"     a & b is true if a and b have one or more\n                            elements in common (the intersection of\n                            the two sets in non-empty.)\n\n                    \"~\"     a ~ b is true if a and b are disjoint\n                            sets.\n\n               When comparing elements of character sets, this routine\n               ignores trailing blanks.\n\n   b           is a CSPICE set of the same data type as a.\n\n-Detailed_Output\n\n   The function returns the result of the comparison: a (op) b.\n\n");

/* void setmsg_c ( ConstSpiceChar * msg ); */
static PyObject * spice_setmsg(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * msg;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &msg));
  setmsg_c(msg);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(setmsg_doc, "-Abstract\n\n   Set the value of the current long error message.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   message    I   A long error message.\n\n-Detailed_Input\n\n   message        A ``long'' error message.\n                  message is a detailed description of the error.\n                  message is supposed to start with the name of the\n                  module which detected the error, followed by a\n                  colon.  Example:\n\n                     \"rdtext_c:  There are no more free logical units\"\n\n                  Only the first LMSGLN (see setmsg.c) characters of\n                  message are stored; any further characters are\n                  truncated.\n\n                  Generally, message will be stored internally by the\n                  CSPICE error handling mechanism.  The only exception\n                  is the case in which the user has commanded the\n                  toolkit to ``ignore'' the error indicated by message.\n\n                  As a default, message will be output to the screen.\n                  See the required reading file for a discussion of how\n                  to customize toolkit error handling behavior, and\n                  in particular, the disposition of message.\n\n-Detailed_Output\n\n   None.\n\n");

/* void shelld_c ( SpiceInt ndim,SpiceDouble * array ); */
static PyObject * spice_shelld(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble array;
  /* variables for inputs */
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &ndim));
  shelld_c(ndim, &array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, array);
  return returnVal;
}
PyDoc_STRVAR(shelld_doc, "-Abstract\n\n   Sort a double precision array using the Shell Sort algorithm.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   ndim       I   Dimension of the array.\n   array     I/O  The array to be sorted.\n\n-Detailed_Input\n\n   ndim        is the number of elements in the array to be sorted.\n\n   array       on input, is the array to be sorted.\n\n-Detailed_Output\n\n   array       on output, contains the same elements, sorted\n               in increasing order. The actual sorting is done\n               in place in array.\n\n");

/* void shelli_c ( SpiceInt ndim,SpiceInt * array ); */
static PyObject * spice_shelli(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt array;
  /* variables for inputs */
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &ndim));
  shelli_c(ndim, &array);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, array);
  return returnVal;
}
PyDoc_STRVAR(shelli_doc, "-Abstract\n\n   Sort an integer array using the Shell Sort algorithm.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   ndim       I   Dimension of the array.\n   array     I/O  The array.\n\n-Detailed_Input\n\n   ndim        is the number of elements in the array to be sorted.\n\n   array       on input, is the array to be sorted.\n\n-Detailed_Output\n\n   array       on output, contains the same elements, sorted\n               in increasing order. The actual sorting is done\n               in place in array.\n\n");

/* void sigerr_c ( ConstSpiceChar * message ); */
static PyObject * spice_sigerr(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * message;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &message));
  sigerr_c(message);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(sigerr_doc, "-Abstract\n\n   Inform the CSPICE error processing mechanism that an error has\n   occurred, and specify the type of error.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   msg        I   A short error message.\n\n-Detailed_Input\n\n   msg     A ``short'' error message.\n           msg indicates the type of error that has occurred.\n\n           Only the first 25 characters of msg will be stored;\n           additional characters will be truncated.\n\n           Generally, msg will be stored internally by the CSPICE\n           error handling mechanism.  The only exception\n           is the case in which the user has commanded the error\n           handling mechanism to ``ignore'' the error indicated by\n           msg.\n\n           As a default, msg will be output to the standard output.\n           See the required reading file for a discussion of how\n           to customize CSPICE error handling behavior, and\n           in particular, the disposition of msg.\n\n-Detailed_Output\n\n   None.\n\n");

/* void sincpt_c ( ConstSpiceChar * method,ConstSpiceChar * target,
SpiceDouble et,ConstSpiceChar * fixref,ConstSpiceChar * abcorr,
ConstSpiceChar * obsrvr,ConstSpiceChar * dref,ConstSpiceDouble dvec [3],
SpiceDouble spoint [3],SpiceDouble * trgepc,SpiceDouble srfvec [3],
SpiceBoolean * found ); */
static PyObject * spice_sincpt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble spoint[3];
  SpiceDouble trgepc;
  SpiceDouble srfvec[3];
  SpiceBoolean found;
  /* variables for inputs */
  char * method;
  char * target;
  double et;
  char * fixref;
  char * abcorr;
  char * obsrvr;
  char * dref;
  double dvec[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdssss(ddd)", &method, &target, &et, &fixref, &abcorr, &obsrvr, &dref, &dvec[0], &dvec[1], &dvec[2]));
  sincpt_c(method, target, et, fixref, abcorr, obsrvr, dref, dvec, spoint, &trgepc, srfvec, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "(ddd)");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, spoint[0], spoint[1], spoint[2], trgepc, srfvec[0], srfvec[1], srfvec[2]);
  return returnVal;
  }

}
PyDoc_STRVAR(sincpt_doc, "-Abstract\n\n   Given an observer and a direction vector defining a ray, compute\n   the surface intercept of the ray on a target body at a specified\n   epoch, optionally corrected for light time and stellar\n   aberration.\n\n   This routine supersedes srfxpt_c.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   method     I   Computation method.\n   target     I   Name of target body.\n   et         I   Epoch in ephemeris seconds past J2000 TDB.\n   fixref     I   Body-fixed, body-centered target body frame.\n   abcorr     I   Aberration correction.\n   obsrvr     I   Name of observing body.\n   dref       I   Reference frame of ray's direction vector.\n   dvec       I   Ray's direction vector.\n   spoint     O   Surface intercept point on the target body.\n   trgepc     O   Intercept epoch.\n   srfvec     O   Vector from observer to intercept point.\n   found      O   Flag indicating whether intercept was found.\n\n-Detailed_Input\n\n   method      is a short string providing parameters defining\n               the computation method to be used.\n\n               The only choice currently supported is\n\n                  \"Ellipsoid\"        The intercept computation uses\n                                     a triaxial ellipsoid to model\n                                     the surface of the target body.\n                                     The ellipsoid's radii must be\n                                     available in the kernel pool.\n\n               Neither case nor white space are significant in\n               `method'. For example, the string ' eLLipsoid ' is\n               valid.\n\n\n   target      is the name of the target body. `target' is\n               case-insensitive, and leading and trailing blanks in\n               `target' are not significant. Optionally, you may\n               supply a string containing the integer ID code\n               for the object. For example both \"MOON\" and \"301\"\n               are legitimate strings that indicate the Moon is the\n               target body.\n\n               When the target body's surface is represented by a\n               tri-axial ellipsoid, this routine assumes that a\n               kernel variable representing the ellipsoid's radii is\n               present in the kernel pool. Normally the kernel\n               variable would be defined by loading a PCK file.\n\n\n   et          is the epoch of participation of the observer,\n               expressed as ephemeris seconds past J2000 TDB: `et' is\n               the epoch at which the observer's state is computed.\n\n               When aberration corrections are not used, `et' is also\n               the epoch at which the position and orientation of the\n               target body are computed.\n\n               When aberration corrections are used, the position and\n               orientation of the target body are computed at et-lt or\n               et+lt, where `lt' is the one-way light time between the\n               intercept point and the observer, and the sign applied\n               to `lt' depends on the selected correction. See the\n               description of `abcorr' below for details.\n\n\n   fixref      is the name of the body-fixed, body-centered\n               reference frame associated with the target body. The\n               output intercept point `spoint' and the observer to\n               intercept vector `srfvec' will be expressed relative to\n               this reference frame.\n\n\n   abcorr      indicates the aberration corrections to be applied when\n               computing the target's position and orientation.\n\n               For remote sensing applications, where the apparent\n               target surface intercept point seen by the observer is\n               desired, normally the correction\n\n                  \"CN+S\"\n\n               should be used. This and the other supported options\n               are described below. `abcorr' may be any of the\n               following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric surface intercept point on the\n                             target body.\n\n               Let `lt' represent the one-way light time between the\n               observer and the surface intercept point (note: NOT\n               between the observer and the target body's center).\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               intercept point's location at the light-time\n               corrected epoch et-lt and *arrive* at the observer's\n               location at `et':\n\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the location of the surface\n                             intercept point at the moment it\n                             emitted photons arriving at the\n                             observer at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation. The solution invoked by the\n                             \"LT\" option uses one iteration.\n\n                             Both the target position as seen by the\n                             observer, and rotation of the target\n                             body, are corrected for light time.\n\n                  \"LT+S\"     Correct for one-way light time and stellar\n                             aberration using a Newtonian formulation.\n                             This option modifies the surface intercept\n                             obtained with the \"LT\" option to account\n                             for the observer's velocity relative to\n                             the solar system barycenter. These\n                             computations yield the apparent surface\n                             intercept point.\n\n                  \"CN\"       Converged Newtonian light time correction.\n                             In solving the light time equation, the\n                             \"CN\" correction iterates until the\n                             solution converges. Both the position and\n                             rotation of the target body are corrected\n                             for light time.\n\n                  \"CN+S\"     Converged Newtonian light time and stellar\n                             aberration corrections. This option\n                             produces a solution that is at least as\n                             accurate at that obtainable with the \"LT+S\"\n                             option. Whether the \"CN+S\" solution is\n                             substantially more accurate depends on the\n                             geometry of the participating objects and\n                             on the accuracy of the input data. In all\n                             cases this routine will execute more\n                             slowly when a converged solution is\n                             computed.\n\n                             For reception-case applications involving\n                             intercepts near the target body limb, this\n                             option should be used\n\n               The following values of `abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               intercept point at the light-time corrected epoch\n               et+lt:\n\n\n                  \"XLT\"      \"Transmission\" case: correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             intercept location at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation. The solution invoked by the\n                             \"XLT\" option uses one iteration.\n\n                             Both the target position as seen by the\n                             observer, and rotation of the target\n                             body, are corrected for light time.\n\n                  \"XLT+S\"    \"Transmission\" case: correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation  This option modifies the\n                             intercept obtained with the \"XLT\"\n                             option to account for the observer's\n                             velocity relative to the solar system\n                             barycenter.\n\n                  \"XCN\"      Converged Newtonian light time\n                             correction. This is the same as XLT\n                             correction but with further iterations\n                             to a converged Newtonian light time\n                             solution.\n\n                  \"XCN+S\"    \"Transmission\" case: converged Newtonian\n                             light time and stellar aberration\n                             corrections. This option produces a\n                             solution that is at least as accurate at\n                             that obtainable with the \"XLT+S\" option.\n                             Whether the \"XCN+S\" solution is\n                             substantially more accurate depends on the\n                             geometry of the participating objects and\n                             on the accuracy of the input data. In all\n                             cases this routine will execute more\n                             slowly when a converged solution is\n                             computed.\n\n                             For transmission-case applications\n                             involving intercepts near the target body\n                             limb, this option should be used.\n\n               Case and embedded blanks are not significant in `abcorr'.\n               For example, the string\n\n                  \"Cn + s\"\n\n               is valid.\n\n\n   obsrvr      is the name of the observing body. This is typically\n               a spacecraft, the earth, or a surface point on the\n               earth. `obsrvr' is case-insensitive, and leading and\n               trailing blanks in `obsrvr' are not significant.\n               Optionally, you may supply a string containing the\n               integer ID code for the object. For example both\n               \"MOON\" and \"301\" are legitimate strings that indicate\n               the Moon is the observer.\n\n\n   dref        is the name of the reference frame relative to which the\n               ray's direction vector is expressed. This may be any\n               frame supported by the SPICE system, including built-in\n               frames (documented in the Frames Required Reading) and\n               frames defined by a loaded frame kernel (FK). The string\n               `dref' is case-insensitive, and leading and trailing\n               blanks in `dref' are not significant.\n\n               When `dref' designates a non-inertial frame, the\n               orientation of the frame is evaluated at an epoch\n               dependent on the frame's center and, if the center is\n               not the observer, on the selected aberration\n               correction. See the description of the direction\n               vector `dvec' for details.\n\n\n   dvec        Ray direction vector emanating from the observer. The\n               intercept with the target body's surface of the ray\n               defined by the observer and `dvec' is sought.\n\n               `dvec' is specified relative to the reference frame\n               designated by `dref'.\n\n               Non-inertial reference frames are treated as follows:\n               if the center of the frame is at the observer's\n               location, the frame is evaluated at `et'. If the\n               frame's center is located elsewhere, then letting\n               `ltcent' be the one-way light time between the observer\n               and the central body associated with the frame, the\n               orientation of the frame is evaluated at et-ltcent,\n               et+ltcent, or `et' depending on whether the requested\n               aberration correction is, respectively, for received\n               radiation, transmitted radiation, or is omitted.\n               `ltcent' is computed using the method indicated by\n               `abcorr'.\n\n\n-Detailed_Output\n\n\n   spoint      is the surface intercept point on the target body of\n               the ray defined by the observer and the direction\n               vector. If the ray intersects the target body in\n               multiple points, the selected intersection point is\n               the one closest to the observer. The output argument\n               `found' (see below) indicates whether an intercept was\n               found.\n\n               `spoint' is expressed in Cartesian coordinates,\n               relative to the target body-fixed frame designated by\n               `fixref'. The body-fixed target frame is evaluated at\n               the intercept epoch `trgepc' (see description below).\n\n               When light time correction is used, the duration of\n               light travel between `spoint' to the observer is\n               considered to be the one way light time. When both light\n               time and stellar aberration corrections are used,\n               `spoint' is selected such that, when `spoint' is\n               corrected for light time an stellar aberration, `spoint'\n               lies on the ray defined by the observer's location and\n               `dvec'.\n\n               The components of `spoint' are given in units of km.\n\n\n   trgepc      is the \"intercept epoch.\" `trgepc' is defined as\n               follows: letting `lt' be the one-way light time between\n               the observer and the intercept point, `trgepc' is the\n               epoch et-lt, et+lt, or `et' depending on whether the\n               requested aberration correction is, respectively, for\n               received radiation, transmitted radiation, or omitted.\n               `lt' is computed using the method indicated by `abcorr'.\n\n               `trgepc' is expressed as seconds past J2000 TDB.\n\n\n   srfvec      is the vector from the observer's position at `et' to\n               the aberration-corrected (or optionally, geometric)\n               position of `spoint', where the aberration corrections\n               are specified by `abcorr'. `srfvec' is expressed in the\n               target body-fixed reference frame designated by\n               `fixref', evaluated at `trgepc'.\n\n               The components of `srfvec' are given in units of km.\n\n               One can use the CSPICE function vnorm_c to obtain the\n               distance between the observer and `spoint':\n\n                  dist = vnorm_c ( srfvec );\n\n               The observer's position `obspos', relative to the\n               target body's center, where the center's position is\n               corrected for aberration effects as indicated by\n               `abcorr', can be computed via the call:\n\n                  vsub_c ( spoint, srfvec, obspos );\n\n               To transform the vector `srfvec' to a time-dependent\n               reference frame `ref' at `et', a sequence of two frame\n               transformations is required. For example, let `mfix'\n               and `mref' be 3x3 matrices respectively describing the\n               target body-fixed to J2000 frame transformation at\n               `trgepc' and the J2000 to (time-dependent frame) `ref'\n               transformation at `et', and let `xform' be the 3x3 matrix\n               representing the composition of `mref' with `mfix'. Then\n               `srfvec' can be transformed to the result `refvec' as\n               follows:\n\n                   pxform_c ( fixref,  \"j2000\", trgepc, mfix   );\n                   pxform_c ( \"j2000\", ref,     et,     mref   );\n                   mxm_c    ( mref,    mfix,            xform  );\n                   mxv_c    ( xform,   srfvec,          refvec );\n\n               The second example in the Examples header section\n               below presents a complete program that demonstrates\n               this procedure.\n\n\n   found       A logical flag indicating whether or not the ray\n               intersects the target. If an intersection exists\n               `found' will be returned as SPICETRUE If the ray misses\n               the target, `found' will be returned as SPICEFALSE.\n\n");

/* SpiceInt size_c ( SpiceCell * size ); */
static PyObject * spice_size(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell size;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceInt result;

  result = size_c(&size);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&size));
  return returnVal;
}
PyDoc_STRVAR(size_doc, "-Abstract\n\n   Return the size (maximum cardinality) of a SPICE cell of any\n   data type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   cell       I   Input cell.\n\n   The function returns the size of the input cell.\n\n-Detailed_Input\n\n\n    cell        is a CSPICE cell of any data type.  Cell must be\n                declared as a character, double precision, or\n                integer SpiceCell.\n\n-Detailed_Output\n\n   The function returns the size of (maximum number of elements in)\n   the input cell.\n\n");

/* SpiceDouble spd_c ( void ); */
static PyObject * spice_spd(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = spd_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(spd_doc, "-Abstract\n\n   Return the number of seconds in a day.\n\n-Brief_I/O\n\n   The function returns the number of seconds in a day.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the number of seconds in a day: 86400.\n\n");

/* void sphcyl_c ( SpiceDouble radius,SpiceDouble colat,SpiceDouble slon,
SpiceDouble * r,SpiceDouble * lon,SpiceDouble * z ); */
static PyObject * spice_sphcyl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble r;
  SpiceDouble lon;
  SpiceDouble z;
  /* variables for inputs */
  double radius;
  double colat;
  double slon;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &radius, &colat, &slon));
  sphcyl_c(radius, colat, slon, &r, &lon, &z);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, r, lon, z);
  return returnVal;
}
PyDoc_STRVAR(sphcyl_doc, "-Abstract\n\n    This routine converts from spherical coordinates to cylindrical\n    coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  -------------------------------------------------\n   radius     I   Distance of point from origin.\n   colat      I   Polar angle (co-latitude in radians) of point.\n   slon       I   Azimuthal angle (longitude) of point (radians).\n   r          O   Distance of point from z axis.\n   lon        O   angle (radians) of point from XZ plane.\n   z          O   Height of point above XY plane.\n\n-Detailed_Input\n\n   radius     Distance of the point from origin.\n\n   colat      Polar angle (co-latitude in radians) of the point.\n\n   slon       Azimuthal angle (longitude) of the point (radians).\n\n-Detailed_Output\n\n   r          Distance of the point of interest from z axis.\n\n   lon        cylindrical angle (radians) of the point from the\n               XZ plane.\n\n   z          Height of the point above XY plane.\n\n");

/* void sphlat_c ( SpiceDouble r,SpiceDouble colat,SpiceDouble lons,
SpiceDouble * radius,SpiceDouble * lon,SpiceDouble * lat ); */
static PyObject * spice_sphlat(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble radius;
  SpiceDouble lon;
  SpiceDouble lat;
  /* variables for inputs */
  double r;
  double colat;
  double lons;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &r, &colat, &lons));
  sphlat_c(r, colat, lons, &radius, &lon, &lat);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, radius, lon, lat);
  return returnVal;
}
PyDoc_STRVAR(sphlat_doc, "-Abstract\n\n   Convert from spherical coordinates to latitudinal coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   r          I   Distance of the point from the origin.\n   colat      I   Angle of the point from positive z axis (radians).\n   lons       I   Angle of the point from the XZ plane (radians).\n   radius     O   Distance of a point from the origin\n   lon        O   Angle of the point from the XZ plane in radians\n   lat        O   Angle of the point from the XY plane in radians\n\n-Detailed_Input\n\n   r          Distance of the point from the origin.\n\n   colat      Angle between the vector from the origin to the point\n              and the positive z axis in radians.\n\n   lons       Angle of the point from the XZ plane (radians).\n\n-Detailed_Output\n\n   radius     Distance of a point from the origin\n\n   lon        Angle of the point from the XZ plane in radians\n\n   lat        Angle of the point from the XY plane in radians\n\n");

/* void sphrec_c ( SpiceDouble r,SpiceDouble colat,SpiceDouble lon,
SpiceDouble rectan[3] ); */
static PyObject * spice_sphrec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rectan[3];
  /* variables for inputs */
  double r;
  double colat;
  double lon;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &r, &colat, &lon));
  sphrec_c(r, colat, lon, rectan);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rectan[0], rectan[1], rectan[2]);
  return returnVal;
}
PyDoc_STRVAR(sphrec_doc, "-Abstract\n\n   Convert from spherical coordinates to rectangular coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   r          I   Distance of a point from the origin.\n   colat      I   Angle of the point from the positive Z-axis.\n   lon        I   Angle of the point from the XZ plane in radians.\n   rectan     O   Rectangular coordinates of the point.\n\n-Detailed_Input\n\n   r          Distance of the point from the origin.\n\n   colat      Angle between the point and the positive z-axis.\n\n   lon        Angle of the projection of the point to the XY\n              plane from the positive X-axis.  The positive\n              Y-axis is at longitude PI/2 radians.\n\n-Detailed_Output\n\n   rectan     The rectangular coordinates of a point.\n\n");

/* void spk14b_c ( SpiceInt handle,ConstSpiceChar * segid,SpiceInt body,
SpiceInt center,ConstSpiceChar * frame,SpiceDouble first,SpiceDouble last,
SpiceInt chbdeg ); */
static PyObject * spice_spk14b(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  char * segid;
  int body;
  int center;
  char * frame;
  double first;
  double last;
  int chbdeg;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "isiisddi", &handle, &segid, &body, &center, &frame, &first, &last, &chbdeg));
  spk14b_c(handle, segid, body, center, frame, first, last, chbdeg);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(spk14b_doc, "-Abstract\n\n   Begin a type 14 SPK segment in the SPK file associated with\n   handle. See also spk14a_c and spk14e_c.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   handle     I   The handle of an SPK file open for writing.\n   segid      I   The string to use for segment identifier.\n   body       I   The NAIF ID code for the body of the segment.\n   center     I   The center of motion for body.\n   frame      I   The reference frame for this segment.\n   first      I   The first epoch for which the segment is valid.\n   last       I   The last epoch for which the segment is valid.\n   chbdeg     I   The degree of the Chebyshev Polynomial used.\n\n-Detailed_Input\n\n   handle         is the file handle of an SPK file that has been\n                  opened for writing.\n\n   segid          is the segment identifier. An SPK segment identifier\n                  may contain up to 40 printing ASCII characters.\n\n   body           is the NAIF ID for the body whose states are\n                  to be recorded in an SPK file.\n\n   center         is the NAIF ID for the center of motion associated\n                  with body.\n\n   frame          is the reference frame that states are referenced to,\n                  for example \"J2000\".\n\n   first          is the starting epoch, in TDB seconds past J2000, for\n                  the ephemeris data to be placed into the segment.\n\n   last           is the ending epoch, in TDB seconds past J2000, for\n                  the ephemeris data to be placed into the segment.\n\n   chbdeg         is the degree of the Chebyshev Polynomials used to\n                  represent the ephemeris information stored in the\n                  segment.\n\n-Detailed_Output\n\n   None.          The input data is used to create the segment summary\n                  for the segment being started in the SPK file\n                  associated with handle.\n\n                  See the Particulars section for details about the\n                  structure of a type 14 SPK segment.\n\n");

/* void spk14e_c ( SpiceInt handle ); */
static PyObject * spice_spk14e(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  spk14e_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(spk14e_doc, "-Abstract\n\n   End the type 14 SPK segment currently being written to the SPK\n   file associated with handle. See also spk14a_c and spk14b_c.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   handle     I   The handle of an SPK file open for writing.\n\n-Detailed_Input\n\n   handle   is the file handle of an SPK file that has been\n            opened for writing, and to which a type 14 segment is\n            being written.\n\n-Detailed_Output\n\n   None.    The type 14 segment in the SPK file associated with\n            handle will be ended, making the addition of the data\n            to the file permanent.\n\n            See the Particulars section for details about the\n            structure of a type 14 SPK segment.\n\n");

/* void spkapo_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
ConstSpiceDouble sobs[6],ConstSpiceChar * abcorr,SpiceDouble ptarg[3],
SpiceDouble * lt ); */
static PyObject * spice_spkapo(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble ptarg[3];
  SpiceDouble lt;
  /* variables for inputs */
  int targ;
  double et;
  char * ref;
  double sobs[6];
  char * abcorr;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ids(dddddd)s", &targ, &et, &ref, &sobs[0], &sobs[1], &sobs[2], &sobs[3], &sobs[4], &sobs[5], &abcorr));
  spkapo_c(targ, et, ref, sobs, abcorr, ptarg, &lt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, ptarg[0], ptarg[1], ptarg[2], lt);
  return returnVal;
}
PyDoc_STRVAR(spkapo_doc, "-Abstract\n\n   Return the position of a target body relative to an observer,\n   optionally corrected for light time and stellar aberration.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Observer epoch.\n   ref        I   Inertial reference frame of observer's state.\n   sobs       I   State of observer wrt. solar system barycenter.\n   abcorr     I   Aberration correction flag.\n   ptarg      O   Position of target.\n   lt         O   One way light time between observer and target.\n\n-Detailed_Input\n\n   targ        is the NAIF ID code for a target body.  The target\n               and observer define a position vector which points\n               from the observer to the target.\n\n   et          is the ephemeris time, expressed as seconds past\n               J2000 TDB, at which the position of the target body\n               relative to the observer is to be computed.  'et'\n               refers to time at the observer's location.\n\n   ref         is the inertial reference frame with respect to which\n               the observer's state 'sobs' is expressed. 'ref' must be\n               recognized by the SPICE Toolkit.  The acceptable\n               frames are listed in the Frames Required Reading, as\n               well as in the CSPICE routine chgirf_.\n\n               Case and blanks are not significant in the string\n               'ref'.\n\n   sobs        is the geometric (uncorrected) state of the observer\n               relative to the solar system barycenter at epoch et.\n               'sobs' is a 6-vector:  the first three components of\n               'sobs' represent a Cartesian position vector; the last\n               three components represent the corresponding velocity\n               vector. 'sobs' is expressed relative to the inertial\n               reference frame designated by 'ref'.\n\n               Units are always km and km/sec.\n\n\n   abcorr      indicates the aberration corrections to be applied to\n               the position of the target body to account for\n               one-way light time and stellar aberration.  See the\n               discussion in the Particulars section for\n               recommendations on how to choose aberration\n               corrections.\n\n               'abcorr' may be any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric position of the target body\n                             relative to the observer.\n\n               The following values of 'abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at et:\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the position of the target at the\n                             moment it emitted photons arriving at\n                             the observer at et.\n\n                             The light time correction involves\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"LT+S\"     Correct for one-way light time and\n                             stellar aberration using a Newtonian\n                             formulation. This option modifies the\n                             position obtained with the \"LT\" option\n                             to account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The result is the apparent\n                             position of the target---the position\n                             of the target as seen by the observer.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction.  In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             and stellar aberration corrections.\n\n\n               The following values of 'abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at 'et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             position of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at et.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation  This option modifies the\n                             position obtained with the \"XLT\" option\n                             to account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The target position\n                             indicates the direction that photons\n                             emitted from the observer's location\n                             must be \"aimed\" to hit the target.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n               Neither special nor general relativistic effects are\n               accounted for in the aberration corrections applied\n               by this routine.\n\n               Case and blanks are not significant in the string\n               'abcorr'.\n\n-Detailed_Output\n\n   ptarg       is a Cartesian 3-vector representing the position of\n               the target body relative to the specified observer.\n               'ptarg' is corrected for the specified aberrations, and\n               is expressed with respect to the specified inertial\n               reference frame.  The components of 'ptarg' represent\n               the x-, y- and z-components of the target's position.\n\n               Units are always km.\n\n               The vector 'ptarg' points from the observer's position\n               at 'et' to the aberration-corrected location of the\n               target. Note that the sense of the position vector is\n               independent of the direction of radiation travel\n               implied by the aberration correction.\n\n   lt          is the one-way light time between the observer and\n               target in seconds.  If the target position is\n               corrected for aberrations, then 'lt' is the one-way\n               light time between the observer and the light time\n               corrected target location.\n\n");

/* void spkapp_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
ConstSpiceDouble sobs [6],ConstSpiceChar * abcorr,SpiceDouble starg [6],
SpiceDouble * lt ); */
static PyObject * spice_spkapp(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble starg[6];
  SpiceDouble lt;
  /* variables for inputs */
  int targ;
  double et;
  char * ref;
  double sobs[6];
  char * abcorr;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ids(dddddd)s", &targ, &et, &ref, &sobs[0], &sobs[1], &sobs[2], &sobs[3], &sobs[4], &sobs[5], &abcorr));
  spkapp_c(targ, et, ref, sobs, abcorr, starg, &lt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, starg[0], starg[1], starg[2], starg[3], starg[4], starg[5], lt);
  return returnVal;
}
PyDoc_STRVAR(spkapp_doc, "-Abstract\n\n   Deprecated: This routine has been superseded by spkaps_c. This\n   routine is supported for purposes of backward compatibility only.\n\n   Return the state (position and velocity) of a target body\n   relative to an observer, optionally corrected for light time and\n   stellar aberration.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Observer epoch.\n   ref        I   Inertial reference frame of observer's state.\n   sobs       I   State of observer wrt. solar system barycenter.\n   abcorr     I   Aberration correction flag.\n   starg      O   State of target.\n   lt         O   One way light time between observer and target.\n\n-Detailed_Input\n\n   targ        is the NAIF ID code for a target body.  The target\n               and observer define a state vector whose position\n               component points from the observer to the target.\n\n   et          is the ephemeris time, expressed as seconds past J2000\n               TDB, at which the state of the target body relative to\n               the observer is to be computed. 'et' refers to time at\n               the observer's location.\n\n   ref         is the inertial reference frame with respect to which\n               the observer's state 'sobs' is expressed. 'ref' must be\n               recognized by the SPICE Toolkit.  The acceptable\n               frames are listed in the Frames Required Reading, as\n               well as in the CSPICE routine chgirf_.\n\n               Case and blanks are not significant in the string 'ref'.\n\n   sobs        is the geometric (uncorrected) state of the observer\n               relative to the solar system barycenter at epoch 'et'.\n               'sobs' is a 6-vector:  the first three components of\n               'sobs' represent a Cartesian position vector; the last\n               three components represent the corresponding velocity\n               vector. 'sobs' is expressed relative to the inertial\n               reference frame designated by 'ref'.\n\n               Units are always km and km/sec.\n\n   abcorr      indicates the aberration corrections to be applied\n               to the state of the target body to account for one-way\n               light time and stellar aberration.  See the discussion\n               in the Particulars section for recommendations on\n               how to choose aberration corrections.\n\n               abcorr may be any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric state of the target body\n                             relative to the observer.\n\n               The following values of abcorr apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at 'et':\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the state of the target at the\n                             moment it emitted photons arriving at\n                             the observer at 'et'.\n\n                             The light time correction involves\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"LT+S\"     Correct for one-way light time and\n                             stellar aberration using a Newtonian\n                             formulation. This option modifies the\n                             state obtained with the \"LT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The result is the apparent\n                             state of the target---the position and\n                             velocity of the target as seen by the\n                             observer.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction.  In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             and stellar aberration corrections.\n\n\n               The following values of abcorr apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at 'et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             state of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at 'et'.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation  This option modifies the\n                             state obtained with the \"XLT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The position component of\n                             the computed target state indicates the\n                             direction that photons emitted from the\n                             observer's location must be \"aimed\" to\n                             hit the target.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n               Neither special nor general relativistic effects are\n               accounted for in the aberration corrections applied\n               by this routine.\n\n               Case and blanks are not significant in the string\n               abcorr.\n\n-Detailed_Output\n\n   starg       is a Cartesian state vector representing the position\n               and velocity of the target body relative to the\n               specified observer. 'starg' is corrected for the\n               specified aberrations, and is expressed with respect\n               to the specified inertial reference frame.  The first\n               three components of 'starg' represent the x-, y- and\n               z-components of the target's position; last three\n               components form the corresponding velocity vector.\n\n               Units are always km and km/sec.\n\n               The position component of 'starg' points from the\n               observer's location at 'et' to the aberration-corrected\n               location of the target. Note that the sense of the\n               position vector is independent of the direction of\n               radiation travel implied by the aberration\n               correction.\n\n               The velocity component of 'starg' is obtained by\n               evaluating the target's geometric state at the light\n               time corrected epoch, so for aberration-corrected\n               states, the velocity is not precisely equal to the\n               time derivative of the position.\n\n   lt          is the one-way light time between the observer and\n               target in seconds.  If the target state is corrected\n               for aberrations, then 'lt' is the one-way light time\n               between the observer and the light time corrected\n               target location.\n\n");

/* void spkcls_c ( SpiceInt handle ); */
static PyObject * spice_spkcls(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  spkcls_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(spkcls_doc, "-Abstract\n\n   Close an open SPK file.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of the SPK file to be closed.\n\n-Detailed_Input\n\n   handle     The handle of the SPK file that is to be closed.\n\n-Detailed_Output\n\n   None.\n\n");

/* void spkcov_c ( ConstSpiceChar * spk,SpiceInt idcode,SpiceCell * cover ); */
static PyObject * spice_spkcov(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cover;
  /* variables for inputs */
  char * spk;
  int idcode;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "si", &spk, &idcode));
  spkcov_c(spk, idcode, &cover);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cover));
  return returnVal;
}
PyDoc_STRVAR(spkcov_doc, "-Abstract\n\n   Find the coverage window for a specified ephemeris object in a\n   specified SPK file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   spk        I   Name of SPK file.\n   idcode     I   ID code of ephemeris object.\n   cover      O   Window giving coverage in `spk' for `idcode'.\n\n-Detailed_Input\n\n   spk            is the name of an SPK file.\n\n   idcode         is the integer ID code of an object for which\n                  ephemeris data are expected to exist in the\n                  specified SPK file.\n\n   cover          is an initialized CSPICE window data structure.\n                  `cover' optionally may contain coverage data on\n                  input; on output, the data already present in\n                  `cover' will be combined with coverage found for the\n                  object designated by `idcode' in the file `spk'.\n\n                  If `cover' contains no data on input, its size and\n                  cardinality still must be initialized.\n\n-Detailed_Output\n\n   cover          is a CSPICE window data structure which\n                  represents the merged coverage for `idcode'. This is\n                  the set of time intervals for which data for\n                  `idcode' are present in the file `spk', merged with\n                  the set of time intervals present in `cover' on\n                  input.  The merged coverage is represented as the\n                  union of one or more disjoint time intervals. The\n                  window `cover' contains the pairs of endpoints of\n                  these intervals.\n\n                  The interval endpoints contained in `cover' are\n                  ephemeris times, expressed as seconds past J2000\n                  TDB.\n\n                  See the Examples section below for a complete\n                  example program showing how to retrieve the\n                  endpoints from `cover'.\n\n");

/* void spkacs_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
ConstSpiceChar * abcorr,SpiceInt obs,SpiceDouble starg[6],SpiceDouble * lt,
SpiceDouble * dlt ); */
static PyObject * spice_spkacs(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble starg[6];
  SpiceDouble lt;
  SpiceDouble dlt;
  /* variables for inputs */
  int targ;
  double et;
  char * ref;
  char * abcorr;
  int obs;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idssi", &targ, &et, &ref, &abcorr, &obs));
  spkacs_c(targ, et, ref, abcorr, obs, starg, &lt, &dlt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, starg[0], starg[1], starg[2], starg[3], starg[4], starg[5], lt, dlt);
  return returnVal;
}
PyDoc_STRVAR(spkacs_doc, "-Abstract\n\n   Return the state (position and velocity) of a target body\n   relative to an observer, optionally corrected for light time\n   and stellar aberration, expressed relative to an inertial\n   reference frame.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Observer epoch.\n   ref        I   Inertial reference frame of output state.\n   abcorr     I   Aberration correction flag.\n   obs        I   Observer.\n   starg      O   State of target.\n   lt         O   One way light time between observer and target.\n   dlt        O   Derivative of light time with respect to time.\n\n-Detailed_Input\n\n   targ        is the NAIF ID code for a target body. The target\n               and observer define a state vector whose position\n               component points from the observer to the target.\n\n   et          is the ephemeris time, expressed as seconds past\n               J2000 TDB, at which the state of the target body\n               relative to the observer is to be computed. `et'\n               refers to time at the observer's location.\n\n   ref         is the inertial reference frame with respect to which\n               the output state `starg' is expressed. `ref' must be\n               recognized by the CSPICE Toolkit. The acceptable\n               frames are listed in the Frames Required Reading, as\n               well as in the CSPICE routine chgirf_.\n\n               Case and blanks are not significant in the string\n               `ref'.\n\n   abcorr      indicates the aberration corrections to be applied\n               to the state of the target body to account for one-way\n               light time and stellar aberration. See the discussion\n               in the Particulars section for recommendations on\n               how to choose aberration corrections.\n\n               `abcorr' may be any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric state of the target body\n                             relative to the observer.\n\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at `et':\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the state of the target at the\n                             moment it emitted photons arriving at\n                             the observer at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"LT+S\"     Correct for one-way light time and\n                             stellar aberration using a Newtonian\n                             formulation. This option modifies the\n                             state obtained with the \"LT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The result is the apparent\n                             state of the target---the position and\n                             velocity of the target as seen by the\n                             observer.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction. In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             and stellar aberration corrections.\n\n\n               The following values of `abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             state of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation  This option modifies the\n                             state obtained with the \"XLT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The position component of\n                             the computed target state indicates the\n                             direction that photons emitted from the\n                             observer's location must be \"aimed\" to\n                             hit the target.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n\n   obs         is the NAIF ID code for the observer body. The\n               target and observer define a state vector whose\n               position component points from the observer to the\n               target.\n\n-Detailed_Output\n\n   starg       is a Cartesian state vector representing the position\n               and velocity of the target body relative to the\n               specified observer. `starg' is corrected for the\n               specified aberrations, and is expressed with respect\n               to the specified inertial reference frame. The first\n               three components of `starg' represent the x-, y- and\n               z-components of the target's position; last three\n               components form the corresponding velocity vector.\n\n               The position component of `starg' points from the\n               observer's location at `et' to the aberration-corrected\n               location of the target. Note that the sense of the\n               position vector is independent of the direction of\n               radiation travel implied by the aberration\n               correction.\n\n               Units are always km and km/sec.\n\n   lt          is the one-way light time between the observer and\n               target in seconds. If the target state is corrected\n               for aberrations, then `lt' is the one-way light time\n               between the observer and the light time corrected\n               target location.\n\n   dlt         is the derivative with respect to barycentric\n               dynamical time of the one way light time between\n               target and observer:\n\n                  dlt = d(lt)/d(et)\n\n               `dlt' can also be described as the rate of change of\n               one way light time. `dlt' is unitless, since `lt' and\n               `et' both have units of TDB seconds.\n\n               If the observer and target are at the same position,\n               then `dlt' is set to zero.\n\n");

/* void spkaps_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
ConstSpiceChar * abcorr,ConstSpiceDouble stobs[6],ConstSpiceDouble accobs[6],
SpiceDouble starg[6],SpiceDouble * lt,SpiceDouble * dlt ); */
static PyObject * spice_spkaps(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble starg[6];
  SpiceDouble lt;
  SpiceDouble dlt;
  /* variables for inputs */
  int targ;
  double et;
  char * ref;
  char * abcorr;
  double stobs[6];
  double accobs[6];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idss(dddddd)(dddddd)", &targ, &et, &ref, &abcorr, &stobs[0], &stobs[1], &stobs[2], &stobs[3], &stobs[4], &stobs[5], &accobs[0], &accobs[1], &accobs[2], &accobs[3], &accobs[4], &accobs[5]));
  spkaps_c(targ, et, ref, abcorr, stobs, accobs, starg, &lt, &dlt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, starg[0], starg[1], starg[2], starg[3], starg[4], starg[5], lt, dlt);
  return returnVal;
}
PyDoc_STRVAR(spkaps_doc, "-Abstract\n\n   Given the state and acceleration of an observer relative to the\n   solar system barycenter, return the state (position and velocity)\n   of a target body relative to the observer, optionally corrected\n   for light time and stellar aberration. All input and output\n   vectors are expressed relative to an inertial reference frame.\n\n   This routine supersedes spkapp_c.\n\n   SPICE users normally should call the high-level API routines\n   spkezr_c or spkez_c rather than this routine.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Observer epoch.\n   ref        I   Inertial reference frame of output state.\n   abcorr     I   Aberration correction flag.\n   stobs      I   State of the observer relative to the SSB.\n   accobs     I   Acceleration of the observer relative to the SSB.\n   starg      O   State of target.\n   lt         O   One way light time between observer and target.\n   dlt        O   Derivative of light time with respect to time.\n\n-Detailed_Input\n\n   targ        is the NAIF ID code for a target body. The target\n               and observer define a state vector whose position\n               component points from the observer to the target.\n\n   et          is the ephemeris time, expressed as seconds past\n               J2000 TDB, at which the state of the target body\n               relative to the observer is to be computed. `et'\n               refers to time at the observer's location.\n\n   ref         is the inertial reference frame with respect to which\n               the input state `stobs', the input acceleration `accobs',\n               and the output state `starg' are expressed. `ref' must be\n               recognized by the CSPICE Toolkit.  The acceptable\n               frames are listed in the Frames Required Reading, as\n               well as in the CSPICE routine chgirf_.\n\n               Case and blanks are not significant in the string\n               `ref'.\n\n   abcorr      indicates the aberration corrections to be applied to\n               the state of the target body to account for one-way\n               light time. See the discussion in the Particulars\n               section for recommendations on how to choose\n               aberration corrections.\n\n               If `abcorr' includes the stellar aberration correction\n               symbol \"+S\", this flag is simply ignored. Aside from\n               the possible presence of this symbol, `abcorr' may be\n               any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric state of the target body\n                             relative to the observer.\n\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at `et':\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the state of the target at the\n                             moment it emitted photons arriving at\n                             the observer at `et'.\n\n                             The light time correction involves\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction. In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n               The following values of `abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             state of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n\n               Neither special nor general relativistic effects are\n               accounted for in the aberration corrections applied\n               by this routine.\n\n               Case and blanks are not significant in the string\n               `abcorr'.\n\n\n   stobs       is the geometric state of the observer relative\n               to the solar system barycenter at `et'. The\n               target and observer define a state vector whose\n               position component points from the observer to the\n               target. `stobs' is expressed relative to the reference\n               frame designated by `ref'.\n\n   accobs      is the geometric acceleration of the observer\n               relative to the solar system barycenter at `et'. This\n               is the derivative with respect to time of the\n               velocity portion of STOBS. `accobs' is expressed\n               relative to the reference frame designated by `ref'.\n\n               `accobs' is used for computing stellar aberration\n               corrected velocity. If stellar aberration corrections\n               are not specified by `abcorr', `accobs' is ignored; the\n               caller need not provide a valid input value in this\n               case.\n\n-Detailed_Output\n\n   starg       is a Cartesian state vector representing the position\n               and velocity of the target body relative to the\n               specified observer. `starg' is corrected for the\n               specified aberration, and is expressed with respect\n               to the specified inertial reference frame. The first\n               three components of `starg' represent the x-, y- and\n               z-components of the target's position; last three\n               components form the corresponding velocity vector.\n\n               The position component of `starg' points from the\n               observer's location at `et' to the aberration-corrected\n               location of the target. Note that the sense of the\n               position vector is independent of the direction of\n               radiation travel implied by the aberration\n               correction.\n\n               Units are always km and km/sec.\n\n   lt          is the one-way light time between the observer and\n               target in seconds. If the target state is corrected\n               for light time, then `lt' is the one-way light time\n               between the observer and the light time-corrected\n               target location.\n\n   dlt         is the derivative with respect to barycentric\n               dynamical time of the one way light time between\n               target and observer:\n\n                  dlt = d(lt)/d(et)\n\n               `dlt' can also be described as the rate of change of\n               one way light time. `dlt' is unitless, since `lt' and\n               `et' both have units of TDB seconds.\n\n               If the observer and target are at the same position,\n               then `dlt' is set to zero.\n\n");

/* void spkez_c ( SpiceInt target,SpiceDouble epoch,ConstSpiceChar * frame,
ConstSpiceChar * abcorr,SpiceInt observer,SpiceDouble state[6],
SpiceDouble * lt ); */
static PyObject * spice_spkez(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble state[6];
  SpiceDouble lt;
  /* variables for inputs */
  int target;
  double epoch;
  char * frame;
  char * abcorr;
  int observer;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idssi", &target, &epoch, &frame, &abcorr, &observer));
  spkez_c(target, epoch, frame, abcorr, observer, state, &lt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, state[0], state[1], state[2], state[3], state[4], state[5], lt);
  return returnVal;
}
PyDoc_STRVAR(spkez_doc, "-Abstract\n\n   Return the state (position and velocity) of a target body\n   relative to an observing body, optionally corrected for light\n   time (planetary aberration) and stellar aberration.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Observer epoch.\n   ref        I   Reference frame of output state vector.\n   abcorr     I   Aberration correction flag.\n   obs        I   Observing body.\n   starg      O   State of target.\n   lt         O   One way light time between observer and target.\n\n-Detailed_Input\n\n   targ        is the NAIF ID code for a target body. The target\n               and observer define a state vector whose position\n               component points from the observer to the target.\n\n   et          is the ephemeris time, expressed as seconds past J2000\n               TDB, at which the state of the target body relative to\n               the observer is to be computed. `et' refers to time at\n               the observer's location.\n\n   ref         is the name of the reference frame relative to which\n               the output state vector should be expressed. This may\n               be any frame supported by the SPICE system, including\n               built-in frames (documented in the Frames Required\n               Reading) and frames defined by a loaded frame kernel\n               (FK).\n\n               When `ref' designates a non-inertial frame, the\n               orientation of the frame is evaluated at an epoch\n               dependent on the selected aberration correction.\n               See the description of the output state vector `starg'\n               for details.\n\n   abcorr      indicates the aberration corrections to be applied\n               to the state of the target body to account for one-way\n               light time and stellar aberration. See the discussion\n               in the Particulars section for recommendations on\n               how to choose aberration corrections.\n\n               `abcorr' may be any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric state of the target body\n                             relative to the observer.\n\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at\n               `et':\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the state of the target at the\n                             moment it emitted photons arriving at\n                             the observer at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"LT+S\"     Correct for one-way light time and\n                             stellar aberration using a Newtonian\n                             formulation. This option modifies the\n                             state obtained with the \"LT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The result is the apparent\n                             state of the target---the position and\n                             velocity of the target as seen by the\n                             observer.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction. In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             and stellar aberration corrections.\n\n\n               The following values of `abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             state of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation  This option modifies the\n                             state obtained with the \"XLT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The position component of\n                             the computed target state indicates the\n                             direction that photons emitted from the\n                             observer's location must be \"aimed\" to\n                             hit the target.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n\n               Neither special nor general relativistic effects are\n               accounted for in the aberration corrections applied\n               by this routine.\n\n               Case and blanks are not significant in the string\n               `abcorr'.\n\n   obs         is the NAIF ID code for an observing body.\n\n\n-Detailed_Output\n\n   starg       is a Cartesian state vector representing the position\n               and velocity of the target body relative to the\n               specified observer. `starg' is corrected for the\n               specified aberrations, and is expressed with respect\n               to the reference frame specified by `ref'. The first\n               three components of `starg' represent the x-, y- and\n               z-components of the target's position; the last three\n               components form the corresponding velocity vector.\n\n               Units are always km and km/sec.\n\n               The position component of `starg' points from the\n               observer's location at `et' to the aberration-corrected\n               location of the target. Note that the sense of the\n               position vector is independent of the direction of\n               radiation travel implied by the aberration\n               correction.\n\n               The velocity component of `starg' is the derivative\n               with respect to time of the position component of\n               `starg.'\n\n               Non-inertial frames are treated as follows: letting\n               `ltcent' be the one-way light time between the observer\n               and the central body associated with the frame, the\n               orientation of the frame is evaluated at et-ltcent,\n               et+ltcent, or `et' depending on whether the requested\n               aberration correction is, respectively, for received\n               radiation, transmitted radiation, or is omitted. `ltcent'\n               is computed using the method indicated by `abcorr'.\n\n   lt          is the one-way light time between the observer and\n               target in seconds. If the target state is corrected\n               for aberrations, then 'lt' is the one-way light time\n               between the observer and the light time corrected\n               target location.\n\n");

/* void spkezp_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
ConstSpiceChar * abcorr,SpiceInt obs,SpiceDouble ptarg[3],SpiceDouble * lt ); */
static PyObject * spice_spkezp(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble ptarg[3];
  SpiceDouble lt;
  /* variables for inputs */
  int targ;
  double et;
  char * ref;
  char * abcorr;
  int obs;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idssi", &targ, &et, &ref, &abcorr, &obs));
  spkezp_c(targ, et, ref, abcorr, obs, ptarg, &lt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, ptarg[0], ptarg[1], ptarg[2], lt);
  return returnVal;
}
PyDoc_STRVAR(spkezp_doc, "-Abstract\n\n   Return the position of a target body relative to an observing\n   body, optionally corrected for light time (planetary aberration)\n   and stellar aberration.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body NAIF ID code.\n   et         I   Observer epoch.\n   ref        I   Reference frame of output position vector.\n   abcorr     I   Aberration correction flag.\n   obs        I   Observing body NAIF ID code.\n   ptarg      O   Position of target.\n   lt         O   One way light time between observer and target.\n\n-Detailed_Input\n\n   targ        is the NAIF ID code for a target body.  The target\n               and observer define a position vector which points\n               from the observer to the target.\n\n   et          is the ephemeris time, expressed as seconds past\n               J2000 TDB, at which the position of the target body\n               relative to the observer is to be computed. 'et'\n               refers to time at the observer's location.\n\n   ref         is the name of the reference frame relative to which\n               the output position vector should be expressed. This\n               may be any frame supported by the SPICE system,\n               including built-in frames (documented in the Frames\n               Required Reading) and frames defined by a loaded\n               frame kernel (FK).\n\n               When 'ref' designates a non-inertial frame, the\n               orientation of the frame is evaluated at an epoch\n               dependent on the selected aberration correction. See\n               the description of the output position vector 'ptarg'\n               for details.\n\n   abcorr      indicates the aberration corrections to be applied to\n               the position of the target body to account for\n               one-way light time and stellar aberration.  See the\n               discussion in the Particulars section for\n               recommendations on how to choose aberration\n               corrections.\n\n               abcorr may be any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric position of the target body\n                             relative to the observer.\n\n               The following values of abcorr apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at 'et':\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the position of the target at\n                             the moment it emitted photons arriving\n                             at the observer at 'et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"LT+S\"     Correct for one-way light time and\n                             stellar aberration using a Newtonian\n                             formulation. This option modifies the\n                             position obtained with the \"LT\" option\n                             to account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The result is the apparent\n                             position of the target---the position\n                             as seen by the observer.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction.  In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             and stellar aberration corrections.\n\n\n               The following values of abcorr apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at 'et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             position of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at 'et'.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for one-way\n                             light time and stellar aberration using a\n                             Newtonian formulation.  This option\n                             modifies the position obtained with the\n                             \"XLT\" option to account for the observer's\n                             velocity relative to the solar system\n                             barycenter. The computed target position\n                             indicates the direction that photons\n                             emitted from the observer's location must\n                             be \"aimed\" to hit the target.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n\n               Neither special nor general relativistic effects are\n               accounted for in the aberration corrections applied\n               by this routine.\n\n               Case and blanks are not significant in the string\n               abcorr.\n\n   obs         is the NAIF ID code for an observing body.\n\n-Detailed_Output\n\n   ptarg       is a Cartesian 3-vector representing the position of\n               the target body relative to the specified observer.\n               'ptarg' is corrected for the specified aberrations, and\n               is expressed with respect to the reference frame\n               specified by 'ref'.  The three components of 'ptarg'\n               represent the x-, y- and z-components of the target's\n               position.\n\n               Units are always km.\n\n               'ptarg' points from the observer's location at 'et' to\n               the aberration-corrected location of the target.\n               Note that the sense of this position vector is\n               independent of the direction of radiation travel\n               implied by the aberration correction.\n\n               Non-inertial frames are treated as follows: letting\n               ltcent be the one-way light time between the observer\n               and the central body associated with the frame, the\n               orientation of the frame is evaluated at et-ltcent,\n               et+ltcent, or 'et' depending on whether the requested\n               aberration correction is, respectively, for received\n               radiation, transmitted radiation, or is omitted. ltcent\n               is computed using the method indicated by abcorr.\n\n   lt          is the one-way light time between the observer and\n               target in seconds. If the target position is corrected\n               for aberrations, then 'lt' is the one-way light time\n               between the observer and the light time corrected\n               target location.\n\n");

/* void spkezr_c ( ConstSpiceChar * target,SpiceDouble epoch,
ConstSpiceChar * frame,ConstSpiceChar * abcorr,ConstSpiceChar * observer,
SpiceDouble state[6],SpiceDouble * lt ); */
static PyObject * spice_spkezr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble state[6];
  SpiceDouble lt;
  /* variables for inputs */
  char * target;
  double epoch;
  char * frame;
  char * abcorr;
  char * observer;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sdsss", &target, &epoch, &frame, &abcorr, &observer));
  spkezr_c(target, epoch, frame, abcorr, observer, state, &lt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, state[0], state[1], state[2], state[3], state[4], state[5], lt);
  return returnVal;
}
PyDoc_STRVAR(spkezr_doc, "-Abstract\n\n   Return the state (position and velocity) of a target body\n   relative to an observing body, optionally corrected for light\n   time (planetary aberration) and stellar aberration.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body name.\n   et         I   Observer epoch.\n   ref        I   Reference frame of output state vector.\n   abcorr     I   Aberration correction flag.\n   obs        I   Observing body name.\n   starg      O   State of target.\n   lt         O   One way light time between observer and target.\n\n-Detailed_Input\n\n   targ        is the name of a target body. Optionally, you may\n               supply the integer ID code for the object as\n               an integer string. For example both \"MOON\" and\n               \"301\" are legitimate strings that indicate the\n               moon is the target body.\n\n               The target and observer define a state vector whose\n               position component points from the observer to the\n               target.\n\n   et          is the ephemeris time, expressed as seconds past J2000\n               TDB, at which the state of the target body relative to\n               the observer is to be computed. `et' refers to time at\n               the observer's location.\n\n   ref         is the name of the reference frame relative to which\n               the output state vector should be expressed. This may\n               be any frame supported by the SPICE system, including\n               built-in frames (documented in the Frames Required\n               Reading) and frames defined by a loaded frame kernel\n               (FK).\n\n               When `ref' designates a non-inertial frame, the\n               orientation of the frame is evaluated at an epoch\n               dependent on the selected aberration correction.\n               See the description of the output state vector `starg'\n               for details.\n\n   abcorr      indicates the aberration corrections to be applied\n               to the state of the target body to account for one-way\n               light time and stellar aberration. See the discussion\n               in the Particulars section for recommendations on\n               how to choose aberration corrections.\n\n               `abcorr' may be any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric state of the target body\n                             relative to the observer.\n\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at\n               `et':\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the state of the target at the\n                             moment it emitted photons arriving at\n                             the observer at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"LT+S\"     Correct for one-way light time and\n                             stellar aberration using a Newtonian\n                             formulation. This option modifies the\n                             state obtained with the \"LT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The result is the apparent\n                             state of the target---the position and\n                             velocity of the target as seen by the\n                             observer.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction. In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             and stellar aberration corrections.\n\n\n               The following values of `abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             state of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation  This option modifies the\n                             state obtained with the \"XLT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The position component of\n                             the computed target state indicates the\n                             direction that photons emitted from the\n                             observer's location must be \"aimed\" to\n                             hit the target.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n\n               Neither special nor general relativistic effects are\n               accounted for in the aberration corrections applied\n               by this routine.\n\n               Case and blanks are not significant in the string\n               `abcorr'.\n\n   obs         is the name of an observing body. Optionally, you may\n               supply the ID code of the object as an integer string.\n               For example, both \"EARTH\" and \"399\" are legitimate\n               strings to supply to indicate the observer is\n               Earth.\n\n-Detailed_Output\n\n   starg       is a Cartesian state vector representing the position\n               and velocity of the target body relative to the\n               specified observer. `starg' is corrected for the\n               specified aberrations, and is expressed with respect\n               to the reference frame specified by `ref'. The first\n               three components of `starg' represent the x-, y- and\n               z-components of the target's position; the last three\n               components form the corresponding velocity vector.\n\n               The position component of `starg' points from the\n               observer's location at `et' to the aberration-corrected\n               location of the target. Note that the sense of the\n               position vector is independent of the direction of\n               radiation travel implied by the aberration\n               correction.\n\n               The velocity component of `starg' is the derivative\n               with respect to time of the position component of\n               `starg.'\n\n               Units are always km and km/sec.\n\n               Non-inertial frames are treated as follows: letting\n               `ltcent' be the one-way light time between the observer\n               and the central body associated with the frame, the\n               orientation of the frame is evaluated at et-ltcent,\n               et+ltcent, or `et' depending on whether the requested\n               aberration correction is, respectively, for received\n               radiation, transmitted radiation, or is omitted. `ltcent'\n               is computed using the method indicated by `abcorr'.\n\n   lt          is the one-way light time between the observer and\n               target in seconds. If the target state is corrected\n               for aberrations, then `lt' is the one-way light time\n               between the observer and the light time corrected\n               target location.\n\n");

/* void spkgeo_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
SpiceInt obs,SpiceDouble state[6],SpiceDouble * lt ); */
static PyObject * spice_spkgeo(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble state[6];
  SpiceDouble lt;
  /* variables for inputs */
  int targ;
  double et;
  char * ref;
  int obs;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idsi", &targ, &et, &ref, &obs));
  spkgeo_c(targ, et, ref, obs, state, &lt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, state[0], state[1], state[2], state[3], state[4], state[5], lt);
  return returnVal;
}
PyDoc_STRVAR(spkgeo_doc, "-Abstract\n\n   Compute the geometric state (position and velocity) of a target\n   body relative to an observing body.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Target epoch.\n   ref        I   Target reference frame.\n   obs        I   Observing body.\n   state      O   State of target.\n   lt         O   Light time.\n\n-Detailed_Input\n\n   targ        is the standard NAIF ID code for a target body.\n\n   et          is the epoch (ephemeris time) at which the state\n               of the target body is to be computed.\n\n   ref         is the name of the reference frame to which the state\n               vector returned by the routine should be rotated. This\n               may be any frame supported by the SPICELIB subroutine\n               FRMCHG.  See also the Frames Required Reading for a list\n               of supported frames.\n\n   obs         is the standard NAIF ID code for an observing body.\n\n-Detailed_Output\n\n   state       contains the position and velocity of the target\n               body, relative to the observing body, corrected\n               for the specified aberrations, at epoch 'et'. 'state'\n               has six elements:  the first three contain the\n               target's position; the last three contain the target's\n               velocity.  These vectors are rotated into the\n               specified reference frame.\n\n               Units are always km and km/sec.\n\n   lt          is the one-way light time from the observing body\n               to the geometric position of the target body\n               in seconds at the specified epoch.\n\n");

/* void spkgps_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
SpiceInt obs,SpiceDouble pos[3],SpiceDouble * lt ); */
static PyObject * spice_spkgps(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble pos[3];
  SpiceDouble lt;
  /* variables for inputs */
  int targ;
  double et;
  char * ref;
  int obs;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idsi", &targ, &et, &ref, &obs));
  spkgps_c(targ, et, ref, obs, pos, &lt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, pos[0], pos[1], pos[2], lt);
  return returnVal;
}
PyDoc_STRVAR(spkgps_doc, "-Abstract\n\n   Compute the geometric position of a target body relative to an\n   observing body.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Target epoch.\n   ref        I   Target reference frame.\n   obs        I   Observing body.\n   pos        O   Position of target.\n   lt         O   Light time.\n\n-Detailed_Input\n\n   targ        is the standard NAIF ID code for a target body.\n\n   et          is the epoch (ephemeris time) at which the position\n               of the target body is to be computed.\n\n   ref         is the name of the reference frame to\n               which the vectors returned by the routine should\n               be rotated. This may be any frame supported by\n               the CSPICE subroutine sxform_c.\n\n   obs         is the standard NAIF ID code for an observing body.\n\n-Detailed_Output\n\n   pos         contains the position of the target\n               body, relative to the observing body. This vector is\n               rotated into the specified reference frame. Units\n               are always km.\n\n   lt          is the one-way light time from the observing body\n               to the geometric position of the target body at the\n               specified epoch.\n\n");

/* void spklef_c ( ConstSpiceChar * filename,SpiceInt * handle ); */
static PyObject * spice_spklef(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * filename;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &filename));
  spklef_c(filename, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(spklef_doc, "-Abstract\n\n   Load an ephemeris file for use by the readers.  Return that file's\n   handle, to be used by other SPK routines to refer to the file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   fname      I   Name of the file to be loaded.\n   handle     O   Loaded file's handle.\n\n-Detailed_Input\n\n   fname          is a string containing the name of the file to be\n                  loaded.\n\n-Detailed_Output\n\n   handle         is an integer handle assigned to the file upon\n                  loading.   Almost every other SPK routine will\n                  subsequently use this number to refer to the file.\n\n");

/* void spkltc_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
ConstSpiceChar * abcorr,ConstSpiceDouble stobs[6],SpiceDouble starg[6],
SpiceDouble * lt,SpiceDouble * dlt ); */
static PyObject * spice_spkltc(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble starg[6];
  SpiceDouble lt;
  SpiceDouble dlt;
  /* variables for inputs */
  int targ;
  double et;
  char * ref;
  char * abcorr;
  double stobs[6];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idss(dddddd)", &targ, &et, &ref, &abcorr, &stobs[0], &stobs[1], &stobs[2], &stobs[3], &stobs[4], &stobs[5]));
  spkltc_c(targ, et, ref, abcorr, stobs, starg, &lt, &dlt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, starg[0], starg[1], starg[2], starg[3], starg[4], starg[5], lt, dlt);
  return returnVal;
}
PyDoc_STRVAR(spkltc_doc, "-Abstract\n\n   Return the state (position and velocity) of a target body\n   relative to an observer, optionally corrected for light time,\n   expressed relative to an inertial reference frame.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Observer epoch.\n   ref        I   Inertial reference frame of output state.\n   abcorr     I   Aberration correction flag.\n   stobs      I   State of the observer relative to the SSB.\n   starg      O   State of target.\n   lt         O   One way light time between observer and target.\n   dlt        O   Derivative of light time with respect to time.\n\n-Detailed_Input\n\n   targ        is the NAIF ID code for a target body. The target\n               and observer define a state vector whose position\n               component points from the observer to the target.\n\n   et          is the ephemeris time, expressed as seconds past\n               J2000 TDB, at which the state of the target body\n               relative to the observer is to be computed. `et'\n               refers to time at the observer's location.\n\n   ref         is the inertial reference frame with respect to which\n               the input state `stobs' and the output state `starg' are\n               expressed. `ref' must be recognized by the CSPICE\n               Toolkit. The acceptable frames are listed in the Frames\n               Required Reading, as well as in the CSPICE routine\n               chgirf_.\n\n               Case and blanks are not significant in the string\n               `ref'.\n\n   abcorr      indicates the aberration corrections to be applied to\n               the state of the target body to account for one-way\n               light time. See the discussion in the Particulars\n               section for recommendations on how to choose\n               aberration corrections.\n\n               If `abcorr' includes the stellar aberration correction\n               symbol \"+S\", this flag is simply ignored. Aside from\n               the possible presence of this symbol, `abcorr' may be\n               any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric state of the target body\n                             relative to the observer.\n\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at `et':\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the state of the target at the\n                             moment it emitted photons arriving at\n                             the observer at `et'.\n\n                             The light time correction involves\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction. In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n               The following values of `abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             state of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n\n               Neither special nor general relativistic effects are\n               accounted for in the aberration corrections applied\n               by this routine.\n\n               Case and blanks are not significant in the string\n               `abcorr'.\n\n   stobs       is the geometric state of the observer relative\n               to the solar system barycenter at `et'. The\n               target and observer define a state vector whose\n               position component points from the observer to the\n               target. `stobs' is expressed relative to the reference\n               frame designated by `ref'.\n\n-Detailed_Output\n\n   starg       is a Cartesian state vector representing the position\n               and velocity of the target body relative to the\n               specified observer. `starg' is corrected for the\n               specified aberration, and is expressed with respect\n               to the specified inertial reference frame. The first\n               three components of `starg' represent the x-, y- and\n               z-components of the target's position; last three\n               components form the corresponding velocity vector.\n\n               The position component of `starg' points from the\n               observer's location at `et' to the aberration-corrected\n               location of the target. Note that the sense of the\n               position vector is independent of the direction of\n               radiation travel implied by the aberration\n               correction.\n\n               Units are always km and km/sec.\n\n   lt          is the one-way light time between the observer and\n               target in seconds. If the target state is corrected\n               for light time, then `lt' is the one-way light time\n               between the observer and the light time-corrected\n               target location.\n\n   dlt         is the derivative with respect to barycentric\n               dynamical time of the one way light time between\n               target and observer:\n\n                  dlt = d(lt)/d(et)\n\n               `dlt' can also be described as the rate of change of\n               one way light time. `dlt' is unitless, since `lt' and\n               `et' both have units of TDB seconds.\n\n               If the observer and target are at the same position,\n               then `dlt' is set to zero.\n\n");

/* void spkobj_c ( ConstSpiceChar * spk,SpiceCell * ids ); */
static PyObject * spice_spkobj(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell ids;
  /* variables for inputs */
  char * spk;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &spk));
  spkobj_c(spk, &ids);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&ids));
  return returnVal;
}
PyDoc_STRVAR(spkobj_doc, "-Abstract\n\n   Find the set of ID codes of all objects in a specified SPK file.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   spk        I   Name of SPK file.\n   ids       I/O  Set of ID codes of objects in SPK file.\n\n-Detailed_Input\n\n   spk            is the name of an SPK file.\n\n   ids            is an initialized CSPICE set data structure.\n                  `ids' optionally may contain a set of ID codes on\n                  input; on output, the data already present in\n                  `ids' will be combined with ID code set found for the\n                  file `spk'.\n\n                  If `ids' contains no data on input, its size and\n                  cardinality still must be initialized.\n\n-Detailed_Output\n\n   ids            is a CSPICE set data structure which contains\n                  the union of its contents upon input with the set\n                  of ID codes of each object for which ephemeris\n                  data are present in the indicated SPK file. The\n                  elements of CSPICE sets are unique; hence each\n                  ID code in `ids' appears only once, even if the SPK\n                  file contains multiple segments for that ID code.\n\n                  See the Examples section below for a complete\n                  example program showing how to retrieve the ID\n                  codes from `ids'.\n\n");

/* void spkopa_c ( ConstSpiceChar * file,SpiceInt * handle ); */
static PyObject * spice_spkopa(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * file;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &file));
  spkopa_c(file, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(spkopa_doc, "-Abstract\n\n  Open an existing SPK file for subsequent write.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   file       I   The name of an existing SPK file.\n   handle     O   A handle attached to the SPK file opened to append.\n\n-Detailed_Input\n\n   file       is the name of an existing SPK file to which\n              you wish to append additional SPK segments.\n\n-Detailed_Output\n\n   handle     is the DAF integer handle that refers to the SPK file\n              opened for appending.\n\n");

/* void spkopn_c ( ConstSpiceChar * name,ConstSpiceChar * ifname,
SpiceInt ncomch,SpiceInt * handle ); */
static PyObject * spice_spkopn(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt handle;
  /* variables for inputs */
  char * name;
  char * ifname;
  int ncomch;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssi", &name, &ifname, &ncomch));
  spkopn_c(name, ifname, ncomch, &handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, handle);
  return returnVal;
}
PyDoc_STRVAR(spkopn_doc, "-Abstract\n\n   Create a new SPK file, returning the handle of the opened file.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   The name of the new SPK file to be created.\n   ifname     I   The internal filename for the SPK file.\n   ncomch     I   The number of characters to reserve for comments.\n   handle     O   The handle of the opened SPK file.\n\n-Detailed_Input\n\n   name     The name of the new SPK file to be created.\n\n   ifname   The internal filename for the SPK file that is being\n            created. The internal filename may be up to 60 characters\n            long. If you do not have any conventions for tagging your\n            files, an internal filename of \"SPK_file\" is perfectly\n            acceptable. You may also leave it blank if you like.\n\n   ncomch   This is the space, measured in characters, to be\n            initially set aside for the comment area when a new SPK\n            file is opened. The amount of space actually set aside\n            may be greater than the amount requested, due to the\n            manner in which comment records are allocated in an SPK\n            file. However, the amount of space set aside for comments\n            will always be at least the amount that was requested.\n\n            The value of ncomch should be greater than or equal to\n            zero, i.e., 0 <= ncomch. A negative value, should one\n            occur, will be assumed to be zero.\n\n-Detailed_Output\n\n   handle   The handle of the opened SPK file. If an error occurs\n            when opening the file, the value of this variable should\n            not be used, as it will not represent a valid handle.\n\n");

/* void spkpds_c ( SpiceInt body,SpiceInt center,ConstSpiceChar * frame,
SpiceInt type,SpiceDouble first,SpiceDouble last,SpiceDouble descr[5] ); */
static PyObject * spice_spkpds(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble descr[5];
  /* variables for inputs */
  int body;
  int center;
  char * frame;
  int type;
  double first;
  double last;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iisidd", &body, &center, &frame, &type, &first, &last));
  spkpds_c(body, center, frame, type, first, last, descr);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, descr[0], descr[1], descr[2], descr[3], descr[4]);
  return returnVal;
}
PyDoc_STRVAR(spkpds_doc, "-Abstract\n\n   Perform routine error checks and if all check pass, pack the\n   descriptor for an SPK segment\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   body       I   The NAIF ID code for the body of the segment.\n   center     I   The center of motion for body.\n   frame      I   The frame for this segment.\n   type       I   The type of SPK segment to create.\n   first      I   The first epoch for which the segment is valid.\n   last       I   The last  epoch for which the segment is valid.\n   descr      O   An SPK segment descriptor.\n\n-Detailed_Input\n\n   body       is the NAIF ID code for the body of the segment.\n\n   center     is the center of motion for BODY.\n\n   frame      is a string that names the frame to which states for\n              the body shall be referenced.\n\n   type       is the type of SPK segment to create.\n\n   first      is the first epoch for which the segment will have\n              ephemeris data.\n\n   last       is the last epoch for which the segment will have\n              ephemeris data.\n\n-Detailed_Output\n\n   descr       is a valid SPK segment descriptor to use\n               when creating a DAF segment for this body.\n\n");

/* void spkpos_c ( ConstSpiceChar * targ,SpiceDouble et,ConstSpiceChar * ref,
ConstSpiceChar * abcorr,ConstSpiceChar * obs,SpiceDouble ptarg[3],
SpiceDouble * lt ); */
static PyObject * spice_spkpos(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble ptarg[3];
  SpiceDouble lt;
  /* variables for inputs */
  char * targ;
  double et;
  char * ref;
  char * abcorr;
  char * obs;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sdsss", &targ, &et, &ref, &abcorr, &obs));
  spkpos_c(targ, et, ref, abcorr, obs, ptarg, &lt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, ptarg[0], ptarg[1], ptarg[2], lt);
  return returnVal;
}
PyDoc_STRVAR(spkpos_doc, "-Abstract\n\n   Return the position of a target body relative to an observing\n   body, optionally corrected for light time (planetary aberration)\n   and stellar aberration.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body name.\n   et         I   Observer epoch.\n   ref        I   Reference frame of output position vector.\n   abcorr     I   Aberration correction flag.\n   obs        I   Observing body name.\n   ptarg      O   Position of target.\n   lt         O   One way light time between observer and target.\n\n-Detailed_Input\n\n   targ        is the name of a target body.  Optionally, you may\n               supply the integer ID code for the object as\n               an integer string.  For example both \"MOON\" and\n               \"301\" are legitimate strings that indicate the\n               moon is the target body.\n\n               The target and observer define a position vector\n               which points from the observer to the target.\n\n   et          is the ephemeris time, expressed as seconds past\n               J2000 TDB, at which the position of the target body\n               relative to the observer is to be computed.  `et'\n               refers to time at the observer's location.\n\n   ref         is the name of the reference frame relative to which\n               the output position vector should be expressed. This\n               may be any frame supported by the SPICE system,\n               including built-in frames (documented in the Frames\n               Required Reading) and frames defined by a loaded\n               frame kernel (FK).\n\n               When `ref' designates a non-inertial frame, the\n               orientation of the frame is evaluated at an epoch\n               dependent on the selected aberration correction. See\n               the description of the output position vector `ptarg'\n               for details.\n\n   abcorr      indicates the aberration corrections to be applied to\n               the position of the target body to account for\n               one-way light time and stellar aberration.  See the\n               discussion in the Particulars section for\n               recommendations on how to choose aberration\n               corrections.\n\n               'abcorr' may be any of the following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric position of the target body\n                             relative to the observer.\n\n               The following values of 'abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               target's location at the light-time corrected epoch\n               et-lt and *arrive* at the observer's location at `et':\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the position of the target at\n                             the moment it emitted photons arriving\n                             at the observer at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation (see Particulars for details).\n                             The solution invoked by the \"LT\" option\n                             uses one iteration.\n\n                  \"LT+S\"     Correct for one-way light time and\n                             stellar aberration using a Newtonian\n                             formulation. This option modifies the\n                             position obtained with the \"LT\" option\n                             to account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The result is the apparent\n                             position of the target---the position\n                             as seen by the observer.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction.  In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges (three\n                             iterations on all supported platforms).\n\n                             The \"CN\" correction typically does not\n                             substantially improve accuracy because\n                             the errors made by ignoring\n                             relativistic effects may be larger than\n                             the improvement afforded by obtaining\n                             convergence of the light time solution.\n                             The \"CN\" correction computation also\n                             requires a significantly greater number\n                             of CPU cycles than does the\n                             one-iteration light time correction.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             and stellar aberration corrections.\n\n\n               The following values of 'abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               target's location at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             position of the target at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for one-way\n                             light time and stellar aberration using a\n                             Newtonian formulation.  This option\n                             modifies the position obtained with the\n                             \"XLT\" option to account for the observer's\n                             velocity relative to the solar system\n                             barycenter. The computed target position\n                             indicates the direction that photons\n                             emitted from the observer's location must\n                             be \"aimed\" to hit the target.\n\n                  \"XCN\"      \"Transmission\" case:  converged\n                             Newtonian light time correction.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n\n               Neither special nor general relativistic effects are\n               accounted for in the aberration corrections applied\n               by this routine.\n\n               Case and blanks are not significant in the string\n               'abcorr'.\n\n   obs         is the name of an observing body.  Optionally, you may\n               supply the ID code of the object as an integer string.\n               For example, both \"EARTH\" and \"399\" are legitimate\n               strings to supply to indicate the observer is\n               Earth.\n\n-Detailed_Output\n\n   ptarg       is a Cartesian 3-vector representing the position of\n               the target body relative to the specified observer.\n               `ptarg' is corrected for the specified aberrations, and\n               is expressed with respect to the reference frame\n               specified by `ref'.  The three components of `ptarg'\n               represent the x-, y- and z-components of the target's\n               position.\n\n               Units are always km.\n\n               `ptarg' points from the observer's location at `et' to\n               the aberration-corrected location of the target.\n               Note that the sense of this position vector is\n               independent of the direction of radiation travel\n               implied by the aberration correction.\n\n               Non-inertial frames are treated as follows: letting\n               ltcent be the one-way light time between the observer\n               and the central body associated with the frame, the\n               orientation of the frame is evaluated at et-ltcent,\n               et+ltcent, or `et' depending on whether the requested\n               aberration correction is, respectively, for received\n               radiation, transmitted radiation, or is omitted. ltcent\n               is computed using the method indicated by 'abcorr'.\n\n   lt          is the one-way light time between the observer and\n               target in seconds. If the target position is\n               corrected for aberrations, then `lt' is the one-way\n               light time between the observer and the light time\n               corrected target location.\n\n");

/* void spkssb_c ( SpiceInt targ,SpiceDouble et,ConstSpiceChar * ref,
SpiceDouble starg[6] ); */
static PyObject * spice_spkssb(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble starg[6];
  /* variables for inputs */
  int targ;
  double et;
  char * ref;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ids", &targ, &et, &ref));
  spkssb_c(targ, et, ref, starg);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, starg[0], starg[1], starg[2], starg[3], starg[4], starg[5]);
  return returnVal;
}
PyDoc_STRVAR(spkssb_doc, "-Abstract\n\n   Return the state (position and velocity) of a target body\n   relative to the solar system barycenter.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   targ       I   Target body.\n   et         I   Target epoch.\n   ref        I   Target reference frame.\n   starg      O   State of target.\n\n-Detailed_Input\n\n   targ        is the standard NAIF ID code for a target body.\n\n   et          is the epoch (ephemeris time) at which the state of the\n               target body is to be computed.\n\n   ref         is the name of the reference frame to which the vectors\n               returned by the routine should be rotated. This may be\n               any frame supported by the CSPICE frame system,\n               including dynamic and other non-inertial frames.\n\n-Detailed_Output\n\n   starg       contains the position and velocity of the target body,\n               relative to the solar system barycenter, at epoch 'et'.\n               These vectors are rotated into the specified reference\n               frame. Units are always km and km/sec.\n\n");

/* void spksub_c ( SpiceInt handle,SpiceDouble descr[5],ConstSpiceChar * ident,
SpiceDouble begin,SpiceDouble end,SpiceInt newh ); */
static PyObject * spice_spksub(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  double descr[5];
  char * ident;
  double begin;
  double end;
  int newh;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i(ddddd)sddi", &handle, &descr[0], &descr[1], &descr[2], &descr[3], &descr[4], &ident, &begin, &end, &newh));
  spksub_c(handle, descr, ident, begin, end, newh);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(spksub_doc, "-Abstract\n\n   Extract a subset of the data in an SPK segment into a\n   separate segment.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of source segment.\n   descr      I   Descriptor of source segment.\n   ident      I   Identifier of source segment.\n   begin      I   Beginning (initial epoch) of subset.\n   end        I   End (final epoch) of subset.\n   newh       I   Handle of new segment.\n\n-Detailed_Input\n\n   handle,\n   descr,\n   ident       are the file handle assigned to a SPK file, the\n               descriptor for a segment within the file, and the\n               identifier for that segment. Together they determine\n               a complete set of ephemeris data, from which a\n               subset is to be extracted.\n\n   begin,\n   end         are the initial and final epochs (ephemeris time)\n               of the subset.\n\n   newh        is the file handle assigned to the file in which\n               the new segment is to be written. The file must\n               be open for write access. newh and handle may refer\n               to the same file.\n\n-Detailed_Output\n\n   See $Files section.\n\n");

/* void spkuds_c ( ConstSpiceDouble descr [5],SpiceInt * body,
SpiceInt * center,SpiceInt * frame,SpiceInt * type,SpiceDouble * first,
SpiceDouble * last,SpiceInt * begin,SpiceInt * end ); */
static PyObject * spice_spkuds(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt body;
  SpiceInt center;
  SpiceInt frame;
  SpiceInt type;
  SpiceDouble first;
  SpiceDouble last;
  SpiceInt begin;
  SpiceInt end;
  /* variables for inputs */
  double descr[5];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddddd)", &descr[0], &descr[1], &descr[2], &descr[3], &descr[4]));
  spkuds_c(descr, &body, &center, &frame, &type, &first, &last, &begin, &end);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, body, center, frame, type, first, last, begin, end);
  return returnVal;
}
PyDoc_STRVAR(spkuds_doc, "-Abstract\n\n   Unpack the contents of an SPK segment descriptor\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   descr      I   An SPK segment descriptor.\n   body       O   The NAIF ID code for the body of the segment.\n   center     O   The center of motion for body.\n   frame      O   The ID code for the frame of this segment.\n   type       O   The type of SPK segment.\n   first      O   The first epoch for which the segment is valid.\n   last       O   The last  epoch for which the segment is valid.\n   begin      O   Beginning DAF address of the segment.\n   end        O   Ending DAF address of the segment.\n\n-Detailed_Input\n\n   descr      is an SPK segment descriptor.\n\n-Detailed_Output\n\n   body       is the NAIF ID code for the body of the segment.\n\n   center     is the center of motion for body.\n\n   frame      is the SPICE integer code for the frame to which states\n              for the body are be referenced.\n\n   type       is the type of SPK segment.\n\n   first      is the first epoch for which the segment has\n              ephemeris data.\n\n   last       is the last epoch for which the segment has\n              ephemeris data.\n\n   begin      is the starting address of the data associated\n              with this descriptor.\n\n   end        is the last address of the data associated with\n              this descriptor.\n\n");

/* void spkuef_c ( SpiceInt handle ); */
static PyObject * spice_spkuef(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &handle));
  spkuef_c(handle);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(spkuef_doc, "-Abstract\n\n   Unload an ephemeris file so that it will no longer be searched by\n   the readers.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of file to be unloaded\n\n-Detailed_Input\n\n   handle     Integer handle assigned to the file upon loading.\n\n-Detailed_Output\n\n   None.\n\n");

/* void spkw15_c ( SpiceInt handle,SpiceInt body,SpiceInt center,
ConstSpiceChar * frame,SpiceDouble first,SpiceDouble last,
ConstSpiceChar * segid,SpiceDouble epoch,ConstSpiceDouble tp [3],
ConstSpiceDouble pa [3],SpiceDouble p,SpiceDouble ecc,SpiceDouble j2flg,
ConstSpiceDouble pv [3],SpiceDouble gm,SpiceDouble j2,SpiceDouble radius ); */
static PyObject * spice_spkw15(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  int body;
  int center;
  char * frame;
  double first;
  double last;
  char * segid;
  double epoch;
  double tp[3];
  double pa[3];
  double p;
  double ecc;
  double j2flg;
  double pv[3];
  double gm;
  double j2;
  double radius;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiisddsd(ddd)(ddd)ddd(ddd)ddd", &handle, &body, &center, &frame, &first, &last, &segid, &epoch, &tp[0], &tp[1], &tp[2], &pa[0], &pa[1], &pa[2], &p, &ecc, &j2flg, &pv[0], &pv[1], &pv[2], &gm, &j2, &radius));
  spkw15_c(handle, body, center, frame, first, last, segid, epoch, tp, pa, p, ecc, j2flg, pv, gm, j2, radius);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(spkw15_doc, "-Abstract\n\n   Write an SPK segment of type 15 given a type 15 data record.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of an SPK file open for writing.\n   body       I   Body code for ephemeris object.\n   center     I   Body code for the center of motion of the body.\n   frame      I   The reference frame of the states.\n   first      I   First valid time for which states can be computed.\n   last       I   Last valid time for which states can be computed.\n   segid      I   Segment identifier.\n   epoch      I   Epoch of the periapse.\n   tp         I   Trajectory pole vector.\n   pa         I   Periapsis vector.\n   p          I   Semi-latus rectum.\n   ecc        I   Eccentricity.\n   j2flg      I   J2 processing flag.\n   pv         I   Central body pole vector.\n   gm         I   Central body GM.\n   j2         I   Central body J2.\n   radius     I   Equatorial radius of central body.\n\n-Detailed_Input\n\n\n            All units are radians, km, seconds.\n\n\n\n   handle      is the file handle of an SPK file that has been\n               opened for writing.\n\n   body        is the NAIF ID for the body whose states are\n               to be recorded in an SPK file.\n\n   center      is the NAIF ID for the center of motion associated\n               with body.\n\n   frame       is the reference frame that states are referenced to,\n               for example \"J2000\".\n\n   first       are the bounds on the ephemeris times, expressed as\n   last        seconds past J2000.\n\n   segid       is the segment identifier. An SPK segment identifier\n               may contain up to 40 characters.\n\n   epoch       is the epoch of the orbit elements at periapse\n               in ephemeris seconds past J2000.\n\n   tp          is a unit vector parallel to the angular momentum\n               vector of the orbit at epoch expressed relative to\n               frame.\n\n   pa          is a unit vector parallel to the position vector\n               of the trajectory at periapsis of epoch expressed\n               relative to frame.\n\n   p           is the semi-latus rectum---p in the equation:\n\n                  r = p/(1 + ecc*cos(Nu))\n\n   ecc          is the eccentricity.\n\n   j2flg        is the J2 processing flag describing what J2\n                corrections are to be applied when the orbit is\n                propagated.\n\n                All J2 corrections are applied if the value of j2flg\n                is not 1, 2 or 3.\n\n                If the value of the flag is 3 no corrections are\n                done.\n\n                If the value of the flag is 1 no corrections are\n                computed for the precession of the line of apsides.\n                However, regression of the line of nodes is\n                performed.\n\n                If the value of the flag is 2 no corrections are\n                done for the regression of the line of nodes.\n                However, precession of the line of apsides is\n                performed.\n\n                Note that J2 effects are computed only if the orbit\n                is elliptic and does not intersect the central body.\n\n   pv           is a unit vector parallel to the north pole vector\n                of the central body expressed relative to frame.\n\n   gm           is the central body gm.\n\n   j2           is the central body J2 (dimensionless).\n\n   radius       is the equatorial radius of the central body.\n\n\n-Detailed_Output\n\n   None.  A type 15 segment is written to the file attached\n   to handle.\n\n");

/* void spkw17_c ( SpiceInt handle,SpiceInt body,SpiceInt center,
ConstSpiceChar * frame,SpiceDouble first,SpiceDouble last,
ConstSpiceChar * segid,SpiceDouble epoch,ConstSpiceDouble eqel [9],
SpiceDouble rapol,SpiceDouble decpol ); */
static PyObject * spice_spkw17(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int handle;
  int body;
  int center;
  char * frame;
  double first;
  double last;
  char * segid;
  double epoch;
  double eqel[9];
  double rapol;
  double decpol;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "iiisddsd(ddddddddd)dd", &handle, &body, &center, &frame, &first, &last, &segid, &epoch, &eqel[0], &eqel[1], &eqel[2], &eqel[3], &eqel[4], &eqel[5], &eqel[6], &eqel[7], &eqel[8], &rapol, &decpol));
  spkw17_c(handle, body, center, frame, first, last, segid, epoch, eqel, rapol, decpol);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(spkw17_doc, "-Abstract\n\n   Write an SPK segment of type 17 given a type 17 data record.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   handle     I   Handle of an SPK file open for writing.\n   body       I   Body code for ephemeris object.\n   center     I   Body code for the center of motion of the body.\n   frame      I   The reference frame of the states.\n   first      I   First valid time for which states can be computed.\n   last       I   Last valid time for which states can be computed.\n   segid      I   Segment identifier.\n   epoch      I   Epoch of elements in seconds past J2000.\n   eqel       I   Array of equinoctial elements.\n   rapol      I   Right Ascension of the pole of the reference plane.\n   decpol     I   Declination of the pole of the reference plane.\n\n-Detailed_Input\n\n   handle         is the file handle of an SPK file that has been\n                  opened for writing.\n\n   body           is the NAIF ID for the body whose states are\n                  to be recorded in an SPK file.\n\n   center         is the NAIF ID for the center of motion associated\n                  with body.\n\n   frame          is the reference frame that states are referenced to,\n                  for example \"J2000\".\n\n   first          are the bounds on the ephemeris times, expressed as\n   last           seconds past J2000.\n\n   segid          is the segment identifier. An SPK segment identifier\n                  may contain up to 40 characters.\n\n   epoch          is the epoch of equinoctial elements in seconds\n                  past the J2000 epoch.\n\n   eqel           is an array of 9 double precision numbers that\n                  are the equinoctial elements for some orbit relative\n                  to the equatorial frame of a central body.\n\n                  The z-axis of the equatorial frame is the direction\n                  of the pole of the central body relative to frame.\n                  The x-axis is given by the cross product of the\n                  Z-axis of frame with the direction of the pole of\n                  the central body.  The Y-axis completes a right\n                  handed frame.\n\n                  The specific arrangement of the elements is spelled\n                  out below.  The following terms are used in the\n                  discussion of elements of eqel:\n\n                      inc  --- inclination of the orbit\n                      argp --- argument of periapse\n                      node --- longitude of the ascending node\n                      e    --- eccentricity of the orbit\n\n                  eqel[0] is the semi-major axis (A) of the orbit in km.\n\n                  eqel[1] is the value of H at the specified epoch.\n                          ( e*sin(argp+node) ).\n\n                  eqel[2] is the value of K at the specified epoch\n                          ( e*cos(argp+node) ).\n\n                  eqel[3] is the mean longitude (mean0+argp+node) at\n                          the epoch of the elements measured in radians.\n\n                  eqel[4] is the value of p (tan(inc/2)*sin(node)) at\n                          the specified epoch.\n\n                  eqel[5] is the value of q (tan(inc/2)*cos(node)) at\n                          the specified epoch.\n\n                  eqel[6] is the rate of the longitude of periapse\n                          (dargp/dt + dnode/dt ) at the epoch of\n                          the elements.  This rate is assumed to hold\n                          for all time. The rate is measured in\n                          radians per second.\n\n                  eqel[7] is the derivative of the mean longitude\n                          ( dm/dt + dargp/dt + dnode/dt ).  This\n                          rate is assumed to be constant and is\n                          measured in radians/second.\n\n                  eqel[8] is the rate of the longitude of the ascending\n                          node ( dnode/dt).  This rate is measured\n                          in radians per second.\n\n   rapol          Right Ascension of the pole of the reference plane\n                  relative to frame measured in radians.\n\n   DECPOL         Declination of the pole of the reference plane\n                  relative to frame measured in radians.\n\n-Detailed_Output\n\n   None.  A type 17 segment is written to the file attached\n   to handle.\n\n");

/* void srfrec_c ( SpiceInt body,SpiceDouble lon,SpiceDouble lat,
SpiceDouble rectan[3] ); */
static PyObject * spice_srfrec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rectan[3];
  /* variables for inputs */
  int body;
  double lon;
  double lat;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idd", &body, &lon, &lat));
  srfrec_c(body, lon, lat, rectan);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rectan[0], rectan[1], rectan[2]);
  return returnVal;
}
PyDoc_STRVAR(srfrec_doc, "-Abstract\n\n   Convert planetocentric latitude and longitude of a surface\n   point on a specified body to rectangular coordinates.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   body       I   NAIF integer code of an extended body.\n   longitude  I   Longitude of point in radians.\n   latitude   I   Latitude of point in radians.\n   rectan     O   Rectangular coordinates of the point.\n\n-Detailed_Input\n\n   body       is the NAIF integer code of an extended body\n              on which a surface point of interest is located.\n              The body is modeled as a triaxial ellipsoid.\n\n   longitude  Longitude of the input point.  This is the angle between\n              the prime meridian and the meridian containing `rectan'.\n              The direction of increasing longitude is from the +X axis\n              towards the +Y axis.\n\n              Longitude is measured in radians.  On input, the range\n              of longitude is unrestricted.\n\n\n   latitude   Latitude of the input point. This is the angle from\n              the XY plane of the ray from the origin through the\n              point.\n\n              Latitude is measured in radians. On input, the range of\n              latitude is unrestricted.\n\n-Detailed_Output\n\n   rectan     The rectangular coordinates of the input point. `rectan'\n              is a 3-vector.\n\n              Units are the same as those used to define the radii of\n              `body'.  Normally, these units are km.\n\n");

/* void srfxpt_c ( ConstSpiceChar * method,ConstSpiceChar * target,
SpiceDouble et,ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,
ConstSpiceChar * dref,ConstSpiceDouble dvec [3],SpiceDouble spoint [3],
SpiceDouble * dist,SpiceDouble * trgepc,SpiceDouble obspos [3],
SpiceBoolean * found ); */
static PyObject * spice_srfxpt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble spoint[3];
  SpiceDouble dist;
  SpiceDouble trgepc;
  SpiceDouble obspos[3];
  SpiceBoolean found;
  /* variables for inputs */
  char * method;
  char * target;
  double et;
  char * abcorr;
  char * obsrvr;
  char * dref;
  double dvec[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdsss(ddd)", &method, &target, &et, &abcorr, &obsrvr, &dref, &dvec[0], &dvec[1], &dvec[2]));
  srfxpt_c(method, target, et, abcorr, obsrvr, dref, dvec, spoint, &dist, &trgepc, obspos, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "(ddd)");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, spoint[0], spoint[1], spoint[2], dist, trgepc, obspos[0], obspos[1], obspos[2]);
  return returnVal;
  }

}
PyDoc_STRVAR(srfxpt_doc, "-Abstract\n\n   Deprecated: This routine has been superseded by the CSPICE\n   routine sincpt_c. This routine is supported for purposes of\n   backward compatibility only.\n\n   Given an observer and a direction vector defining a ray, compute the\n   surface intercept point of the ray on a target body at a specified\n   epoch, optionally corrected for light time and stellar aberration.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   method     I   Computation method.\n   target     I   Name of target body.\n   et         I   Epoch in ephemeris seconds past J2000 TDB.\n   abcorr     I   Aberration correction.\n   obsrvr     I   Name of observing body.\n   dref       I   Reference frame of input direction vector.\n   dvec       I   Ray's direction vector.\n   spoint     O   Surface intercept point on the target body.\n   dist       O   Distance from the observer to the intercept point.\n   trgepc     O   Intercept epoch.\n   obspos     O   Observer position relative to target center.\n   found      O   Flag indicating whether intercept was found.\n\n-Detailed_Input\n\n   method      is a short string providing parameters defining\n               the computation method to be used.  Parameters\n               include, but are not limited to, the shape model\n               used to represent the surface of the target body.\n\n               The only choice currently supported is\n\n                  \"Ellipsoid\"        The intercept computation uses\n                                     a triaxial ellipsoid to model\n                                     the surface of the target body.\n                                     The ellipsoid's radii must be\n                                     available in the kernel pool.\n\n               Neither case nor white space are significant in\n               `method'.  For example, the string \" eLLipsoid \" is\n               valid.\n\n               In a later Toolkit release, this argument will be\n               used to invoke a wider range of surface\n               representations. For example, it will be possible to\n               represent the target body's surface using a digital\n               model.\n\n\n   target      is the name of the target body.  `target' is\n               case-insensitive, and leading and trailing blanks in\n               `target' are not significant. Optionally, you may supply\n               a string containing the integer ID code for the object.\n               For example both \"MOON\" and \"301\" are legitimate strings\n               that indicate the moon is the target body.\n\n               When the target body's surface is represented by a\n               tri-axial ellipsoid, this routine assumes that a kernel\n               variable representing the ellipsoid's radii is present\n               in the kernel pool.  Normally the kernel variable would\n               be defined by loading a PCK file.\n\n\n   et          is the epoch of participation of the observer, expressed\n               as ephemeris seconds past J2000 TDB: `et' is the epoch\n               at which the observer's state is computed.\n\n               When aberration corrections are not used, `et' is also\n               the epoch at which the state and orientation of the\n               target body are computed.\n\n               When aberration corrections are used, `et' is the epoch\n               at which the observer's state relative to the solar\n               system barycenter is computed; in this case the position\n               and orientation of the target body are computed at et-lt\n               or et+lt, where `lt' is the one-way light time between\n               the intercept point and the observer, and the sign\n               applied to lt depends on the selected correction. See\n               the description of `abcorr' below for details.\n\n\n   abcorr      indicates the aberration correction to be applied\n               when computing the observer-target state and the\n               orientation of the target body.  `abcorr' may be any of\n               the following.\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric surface intercept point on the\n                             target body.\n\n               Let `lt' represent the one-way light time between the\n               observer and the surface intercept point (note: NOT\n               between the observer and the target body's center).\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               intercept point's location at the light-time\n               corrected epoch et-lt and *arrive* at the observer's\n               location at `et':\n\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the location of the surface\n                             intercept point at the moment it\n                             emitted photons arriving at the\n                             observer at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation. The solution invoked by the\n                             \"LT\" option uses one iteration.\n\n                             Both the target state as seen by the\n                             observer, and rotation of the target\n                             body, are corrected for light time.\n\n                  \"LT+S\"     Correct for one-way light time and\n                             stellar aberration using a Newtonian\n                             formulation. This option modifies the\n                             state obtained with the \"LT\" option to\n                             account for the observer's velocity\n                             relative to the solar system\n                             barycenter. The result is the apparent\n                             surface intercept point as seen by the\n                             observer.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction.  In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges. Both the\n                             state and rotation of the target body\n                             are corrected for light time.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             and stellar aberration corrections.\n\n               The following values of `abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               intercept point at the light-time corrected epoch\n               et+lt:\n\n\n                  \"XLT\"      \"Transmission\" case:  correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             intercept location at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation. The solution invoked by the\n                             \"LT\" option uses one iteration.\n\n                             Both the target state as seen by the\n                             observer, and rotation of the target\n                             body, are corrected for light time.\n\n                  \"XLT+S\"    \"Transmission\" case:  correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation  This option modifies the\n                             intercept obtained with the \"XLT\"\n                             option to account for the observer's\n                             velocity relative to the solar system\n                             barycenter.\n\n                  \"XCN\"      Converged Newtonian light time\n                             correction.  This is the same as \"XLT\"\n                             correction but with further iterations\n                             to a converged Newtonian light time\n                             solution.\n\n                  \"XCN+S\"    \"Transmission\" case:  converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n\n   obsrvr      is the name of the observing body.  This is typically\n               a spacecraft, the earth, or a surface point on the\n               earth.  `obsrvr' is case-insensitive, and leading and\n               trailing blanks in `obsrvr' are not significant.\n               Optionally, you may supply a string containing the\n               integer ID code for the object.  For example both\n               \"EARTH\" and \"399\" are legitimate strings that indicate\n               the earth is the observer.\n\n\n   dref        is the name of the reference frame relative to which the\n               input direction vector is expressed. This may be any\n               frame supported by the SPICE system, including built-in\n               frames (documented in the Frames Required Reading) and\n               frames defined by a loaded frame kernel (FK).\n\n               When `dref' designates a non-inertial frame, the\n               orientation of the frame is evaluated at an epoch\n               dependent on the frame's center and, if the center is\n               not the observer, on the selected aberration\n               correction. See the description of the direction\n               vector `dvec' for details.\n\n\n   dvec        Pointing vector emanating from the observer.  The\n               intercept with the target body's surface of the ray\n               defined by the observer and `dvec' is sought.\n\n               `dvec' is specified relative to the reference frame\n               designated by `dref'.\n\n               Non-inertial reference frames are treated as follows:\n               if the center of the frame is at the observer's\n               location, the frame is evaluated at `et'.  If the\n               frame's center is located elsewhere, then letting\n               `ltcent' be the one-way light time between the observer\n               and the central body associated with the frame, the\n               orientation of the frame is evaluated at et-ltcent,\n               et+ltcent, or `et' depending on whether the requested\n               aberration correction is, respectively, for received\n               radiation, transmitted radiation, or is omitted.\n               `ltcent' is computed using the method indicated by\n               `abcorr'.\n\n-Detailed_Output\n\n\n   spoint      is the surface intercept point on the target body of\n               the ray defined by the observer and the direction\n               vector. If the ray intersects the target body in\n               multiple points, the selected intersection point is\n               the one closest to the observer.  The output\n               argument `found' (see below) indicates whether an\n               intercept was found.\n\n               `spoint' is expressed in Cartesian coordinates,\n               relative to the body-fixed frame associated with the\n               target body.  The body-fixed target frame is\n               evaluated at the intercept epoch `trgepc' (see\n               description below).\n\n               When light time correction is used, the duration of\n               light travel between `spoint' to the observer is\n               considered to be the one way light time.  When both\n               light time and stellar aberration corrections are\n               used, `spoint' is selected such that, when `spoint' is\n               corrected for light time and the vector from the\n               observer to the light-time corrected location of\n               `spoint' is corrected for stellar aberration, the\n               resulting vector is parallel to the ray defined by\n               the observer's location and `dvec'.\n\n               The components of `spoint' are given in units of km.\n\n\n   dist        is the distance between the observer and the surface\n               intercept on the target body.  `dist' is given in units\n               of km.\n\n\n   trgepc      is the \"intercept epoch.\"  This is the epoch at which\n               the ray defined by `obsrvr' and `dvec' intercepts the\n               target surface at `spoint'.  `trgepc' is defined as\n               follows: letting `lt' be the one-way light time between\n               the observer and the intercept point, `trgepc' is the\n               epoch et-lt, et+lt, or `et' depending on whether the\n               requested aberration correction is, respectively, for\n               received radiation, transmitted radiation, or\n               omitted. `lt' is computed using the method indicated by\n               `abcorr'.\n\n               `trgepc' is expressed as seconds past J2000 TDB.\n\n\n   obspos      is the vector from the center of the target body at\n               epoch `trgepc' to the observer at epoch `et'.  `obspos' is\n               expressed in the target body-fixed reference frame\n               evaluated at `trgepc'.  (This is the frame relative to\n               which `spoint' is given.)\n\n               `obspos' is returned to simplify various related\n               computations that would otherwise be cumbersome.  For\n               example, the vector `xvec' from the observer to `spoint'\n               can be calculated via the call\n\n                  vsub_c ( spoint, obspos, xvec );\n\n               The components of `obspos' are given in units of km.\n\n\n   found       A logical flag indicating whether or not the ray\n               intersects the target.  If an intersection exists\n               `found' will be returned as SPICETRUE.  If the ray misses\n               the target, `found' will be returned as SPICEFALSE.\n\n");

/* void ssize_c ( SpiceInt size,SpiceCell * cell ); */
static PyObject * spice_ssize(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell cell;
  /* variables for inputs */
  int size;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &size));
  ssize_c(size, &cell);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&cell));
  return returnVal;
}
PyDoc_STRVAR(ssize_doc, "-Abstract\n\n   Set the size (maximum cardinality) of a CSPICE cell of any data\n   type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   size       I   Size (maximum cardinality) of the cell.\n   cell       O   The cell.\n\n-Detailed_Input\n\n   size        is the new value of the size (maximum number of\n               elements) of the cell.\n\n               size must be non-negative and must be no larger than\n               the initial declared size of the cell.\n\n\n   cell        is a CSPICE cell of any data type.\n\n-Detailed_Output\n\n\n   cell        is, on output, the cell with its size updated to\n               the value given by the input argument size.\n\n               The cardinality of the cell is set to 0.\n\n               The cell becomes a  CSPICE set:  the cell's \"is a set?\"\n               attribute becomes true.  The cell then can be used as\n               an input to the CSPICE set routines such as insrt*_c.\n\n               Unlike the cell \"set size\" routines in the Fortran\n               SPICE Toolkit's SPICELIB library, this routine does\n               not clear the unused portion of the cell's control\n               area.\n\n");

/* void stelab_c ( ConstSpiceDouble pobj[3],ConstSpiceDouble vobs[3],
SpiceDouble appobj[3] ); */
static PyObject * spice_stelab(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble appobj[3];
  /* variables for inputs */
  double pobj[3];
  double vobs[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &pobj[0], &pobj[1], &pobj[2], &vobs[0], &vobs[1], &vobs[2]));
  stelab_c(pobj, vobs, appobj);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, appobj[0], appobj[1], appobj[2]);
  return returnVal;
}
PyDoc_STRVAR(stelab_doc, "-Abstract\n\n    Correct the apparent position of an object for stellar\n    aberration.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    pobj       I   Position of an object with respect to the\n                   observer.\n    vobs       I   Velocity of the observer with respect to the\n                   Solar System barycenter.\n    appobj     O   Apparent position of the object with respect to\n                   the observer, corrected for stellar aberration.\n\n-Detailed_Input\n\n    pobj        is the position (x, y, z, km) of an object with\n                respect to the observer, possibly corrected for\n                light time.\n\n    vobs        is the velocity (dx/dt, dy/dt, dz/dt, km/sec)\n                of the observer with respect to the Solar System\n                barycenter.\n\n-Detailed_Output\n\n    appobj      is the apparent position of the object relative\n                to the observer, corrected for stellar aberration.\n\n");

/* void stpool_c ( ConstSpiceChar * item,SpiceInt nth,ConstSpiceChar * contin,
SpiceInt lenout,SpiceChar * string,SpiceInt * size,SpiceBoolean * found ); */
static PyObject * spice_stpool(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar string[STRING_LEN];
  SpiceInt size;
  SpiceBoolean found;
  /* variables for inputs */
  char * item;
  int nth;
  char * contin;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sis", &item, &nth, &contin));
  stpool_c(item, nth, contin, lenout, string, &size, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "i");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, string, size);
  return returnVal;
  }

}
PyDoc_STRVAR(stpool_doc, "-Abstract\n\n   Retrieve the nth string from the kernel pool variable, where the\n   string may be continued across several components of the kernel pool\n   variable.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   item       I   Name of the kernel pool variable.\n   nth        I   Index of the full string to retrieve.\n   contin     I   Character sequence used to indicate continuation.\n   lenout     I   Available space in output string.\n   string     O   A full string concatenated across continuations.\n   size       O   The number of characters in the full string value.\n   found      O   Flag indicating success or failure of request.\n\n-Detailed_Input\n\n   item       is the name of a kernel pool variable for which\n              the caller wants to retrieve a full (potentially\n              continued) string.\n\n   nth        is the number of the string to retrieve from the kernel\n              pool.  The range of `nth' is 0 to one less than the\n              number of full strings that are present.\n\n   contin     is a sequence of characters which (if they appear as the\n              last non-blank sequence of characters in a component of a\n              value of a kernel pool variable) act as a continuation\n              marker:  the marker indicates that the string associated\n              with the component containing it is continued into the\n              next literal component of the kernel pool variable.\n\n              If contin is blank, all of the components of `item'\n              will be retrieved as a single string.\n\n   lenout     is the available space in the output string, counting\n              room for the terminating null.  Up to lenout-1 \"data\"\n              characters will be assigned to the output string.\n\n-Detailed_Output\n\n   string     is the nth full string associated with the kernel\n              pool variable specified by item.\n\n              Note that if `string' is not sufficiently long to hold\n              the fully continued string, the value will be truncated.\n              You can determine if `string' has been truncated by\n              examining the variable `size'.  `string' will always be\n              null-terminated, even if truncation of the data occurs.\n\n   size       is the index of last non-blank character of the continued\n              string as it is represented in the kernel pool.  This is\n              the actual number of characters needed to hold the\n              requested string.  If `string' contains a truncated\n              portion of the full string, strlen(string) will be less\n              than `size'.\n\n              If the value of `string' should be a blank, then\n              SIZE will be set to 1.\n\n   found      is a logical variable indicating success of the\n              request to retrieve the nth string associated\n              with item.  If an nth string exists, `found' will be\n              set to SPICETRUE; otherwise `found' will be set to\n              SPICEFALSE.\n\n");

/* void str2et_c ( ConstSpiceChar * date,SpiceDouble * et ); */
static PyObject * spice_str2et(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble et;
  /* variables for inputs */
  char * date;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &date));
  str2et_c(date, &et);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, et);
  return returnVal;
}
PyDoc_STRVAR(str2et_doc, "-Abstract\n\n   Convert a string representing an epoch to a double precision\n   value representing the number of TDB seconds past the J2000\n   epoch corresponding to the input epoch.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   str        I   A string representing an epoch.\n   et         O   The equivalent value in seconds past J2000, TDB.\n\n-Detailed_Input\n\n   str        is a string representing an epoch.  Virtually all common\n              calendar representations are allowed. You may specify a\n              time string belonging to any of the systems TDB, TDT,\n              UTC.  Moreover, you may specify a time string relative to\n              a specific UTC based time zone.\n\n              The rules used in the parsing of `str' are spelled out in\n              great detail in the CSPICE routine tpartv_. The basics\n              are given in the Particulars section below.\n\n-Detailed_Output\n\n   et        is the double precision number of TDB seconds past the\n             J2000 epoch that corresponds to the input `str'.\n\n");

/* void subpnt_c ( ConstSpiceChar * method,ConstSpiceChar * target,
SpiceDouble et,ConstSpiceChar * fixref,ConstSpiceChar * abcorr,
ConstSpiceChar * obsrvr,SpiceDouble spoint [3],SpiceDouble * trgepc,
SpiceDouble srfvec [3] ); */
static PyObject * spice_subpnt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble spoint[3];
  SpiceDouble trgepc;
  SpiceDouble srfvec[3];
  /* variables for inputs */
  char * method;
  char * target;
  double et;
  char * fixref;
  char * abcorr;
  char * obsrvr;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdsss", &method, &target, &et, &fixref, &abcorr, &obsrvr));
  subpnt_c(method, target, et, fixref, abcorr, obsrvr, spoint, &trgepc, srfvec);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, spoint[0], spoint[1], spoint[2], trgepc, srfvec[0], srfvec[1], srfvec[2]);
  return returnVal;
}
PyDoc_STRVAR(subpnt_doc, "-Abstract\n\n   Compute the rectangular coordinates of the sub-observer point on\n   a target body at a specified epoch, optionally corrected for\n   light time and stellar aberration.\n\n   This routine supersedes subpt_c.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   method     I   Computation method.\n   target     I   Name of target body.\n   et         I   Epoch in ephemeris seconds past J2000 TDB.\n   fixref     I   Body-fixed, body-centered target body frame.\n   abcorr     I   Aberration correction.\n   obsrvr     I   Name of observing body.\n   spoint     O   Sub-observer point on the target body.\n   trgepc     O   Sub-observer point epoch.\n   srfvec     O   Vector from observer to sub-observer point.\n\n-Detailed_Input\n\n   method      is a short string providing parameters defining\n               the computation method to be used.\n\n               The supported values of `method' are listed below.\n               Please note that the colon is a required delimiter;\n               using a blank will not work.\n\n                  \"Near point: ellipsoid\"   The sub-observer point\n                                            computation uses a\n                                            triaxial ellipsoid to\n                                            model the surface of the\n                                            target body. The\n                                            sub-observer point is\n                                            defined as the nearest\n                                            point on the target\n                                            relative to the\n                                            observer.\n\n                  \"Intercept: ellipsoid\"    The sub-observer point\n                                            computation uses a\n                                            triaxial ellipsoid to\n                                            model the surface of the\n                                            target body. The\n                                            sub-observer point is\n                                            defined as the target\n                                            surface intercept of the\n                                            line containing the\n                                            observer and the\n                                            target's center.\n\n               Neither case nor white space are significant in\n               `method'. For example, the string\n\n                 \" nearpoint:ELLIPSOID \"\n\n               is valid.\n\n\n   target      is the name of the target body. The target body is\n               an ephemeris object (its trajectory is given by\n               SPK data), and is an extended object.\n\n               The string `target' is case-insensitive, and leading\n               and trailing blanks in `target' are not significant.\n               Optionally, you may supply a string containing the\n               integer ID code for the object. For example both\n               \"MOON\" and \"301\" are legitimate strings that indicate\n               the Moon is the target body.\n\n               When the target body's surface is represented by a\n               tri-axial ellipsoid, this routine assumes that a\n               kernel variable representing the ellipsoid's radii is\n               present in the kernel pool. Normally the kernel\n               variable would be defined by loading a PCK file.\n\n\n   et          is the epoch of participation of the observer,\n               expressed as ephemeris seconds past J2000 TDB: `et' is\n               the epoch at which the observer's state is computed.\n\n               When aberration corrections are not used, `et' is also\n               the epoch at which the position and orientation of\n               the target body are computed.\n\n               When aberration corrections are used, the position and\n               orientation of the target body are computed at et-lt or\n               et+lt, where `lt' is the one-way light time between the\n               sub-observer point and the observer, and the sign\n               applied to `lt' depends on the selected correction. See\n               the description of `abcorr' below for details.\n\n\n   fixref      is the name of the body-fixed, body-centered reference\n               frame associated with the target body. The output\n               sub-observer point `spoint' will be expressed relative\n               to this reference frame. The string `fixref' is\n               case-insensitive, and leading and trailing blanks in\n               `fixref' are not significant.\n\n\n   abcorr      indicates the aberration corrections to be applied when\n               computing the target's position and orientation.\n\n               For remote sensing applications, where the apparent\n               sub-observer point seen by the observer is desired,\n               normally either of the corrections\n\n                  \"LT+S\"\n                  \"CN+S\"\n\n               should be used. These and the other supported options\n               are described below. `abcorr' may be any of the\n               following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric sub-observer point on the\n                             target body.\n\n               Let `lt' represent the one-way light time between the\n               observer and the sub-observer point (note: NOT\n               between the observer and the target body's center).\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               sub-observer point's location at the light-time\n               corrected epoch et-lt and *arrive* at the observer's\n               location at `et':\n\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the location of sub-observer\n                             point at the moment it emitted photons\n                             arriving at the observer at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation. The solution invoked by the\n                             \"LT\" option uses one iteration.\n\n                             Both the target position as seen by the\n                             observer, and rotation of the target\n                             body, are corrected for light time.\n\n                  \"LT+S\"     Correct for one-way light time and stellar\n                             aberration using a Newtonian formulation.\n                             This option modifies the sub-observer\n                             point obtained with the \"LT\" option to\n                             account for the observer's velocity\n                             relative to the solar system barycenter.\n                             These corrections yield the apparent\n                             sub-observer point.\n\n                  \"CN\"       Converged Newtonian light time\n                             correction. In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges. Both the\n                             position and rotation of the target\n                             body are corrected for light time.\n\n                  \"CN+S\"     Converged Newtonian light time and\n                             stellar aberration corrections. This\n                             option produces a solution that is at\n                             least as accurate at that obtainable\n                             with the \"LT+S\" option. Whether the \"CN+S\"\n                             solution is substantially more accurate\n                             depends on the geometry of the\n                             participating objects and on the\n                             accuracy of the input data. In all\n                             cases this routine will execute more\n                             slowly when a converged solution is\n                             computed.\n\n\n               The following values of `abcorr' apply to the\n               \"transmission\" case in which photons *depart* from\n               the observer's location at `et' and arrive at the\n               sub-observer point at the light-time corrected epoch\n               et+lt:\n\n                  \"XLT\"      \"Transmission\" case: correct for\n                             one-way light time using a Newtonian\n                             formulation. This correction yields the\n                             sub-observer location at the moment it\n                             receives photons emitted from the\n                             observer's location at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation. The solution invoked by the\n                             \"LT\" option uses one iteration.\n\n                             Both the target position as seen by the\n                             observer, and rotation of the target\n                             body, are corrected for light time.\n\n                  \"XLT+S\"    \"Transmission\" case: correct for\n                             one-way light time and stellar\n                             aberration using a Newtonian\n                             formulation  This option modifies the\n                             sub-observer point obtained with the\n                             \"XLT\" option to account for the\n                             observer's velocity relative to the\n                             solar system barycenter.\n\n                  \"XCN\"      Converged Newtonian light time\n                             correction. This is the same as \"XLT\"\n                             correction but with further iterations\n                             to a converged Newtonian light time\n                             solution.\n\n                  \"XCN+S\"    \"Transmission\" case: converged\n                             Newtonian light time and stellar\n                             aberration corrections.\n\n                Neither case nor white space are significant in\n                `abcorr'. For example, the string\n\n                  'Lt + s'\n\n                is valid.\n\n\n   obsrvr      is the name of the observing body. The observing body\n               is an ephemeris object: it typically is a spacecraft,\n               the earth, or a surface point on the earth. `obsrvr' is\n               case-insensitive, and leading and trailing blanks in\n               `obsrvr' are not significant. Optionally, you may\n               supply a string containing the integer ID code for\n               the object. For example both \"MOON\" and \"301\" are\n               legitimate strings that indicate the Moon is the\n               observer.\n\n-Detailed_Output\n\n\n   spoint      is the sub-observer point on the target body.\n\n               The sub-observer point is defined either as the point\n               on the target body that is closest to the observer,\n               or the target surface intercept of the line from the\n               observer to the target's center; the input argument\n               `method' selects the definition to be used.\n\n               `spoint' is expressed in Cartesian coordinates,\n               relative to the body-fixed target frame designated by\n               `fixref'. The body-fixed target frame is evaluated at\n               the sub-observer epoch `trgepc' (see description below).\n\n               When light time correction is used, the duration of\n               light travel between `spoint' to the observer is\n               considered to be the one way light time.\n\n               When aberration corrections are used, `spoint' is\n               computed using target body position and orientation\n               that have been adjusted for the corrections\n               applicable to `spoint' itself rather than to the target\n               body's center. In particular, if the stellar\n               aberration correction applicable to `spoint' is\n               represented by a shift vector `s', then the light-time\n               corrected position of the target is shifted by `s'\n               before the sub-observer point is computed.\n\n               The components of `spoint' have units of km.\n\n\n   trgepc      is the \"sub-observer point epoch.\" `trgepc' is defined\n               as follows: letting `lt' be the one-way light time\n               between the observer and the sub-observer point,\n               `trgepc' is the epoch et-lt, et+lt, or `et' depending on\n               whether the requested aberration correction is,\n               respectively, for received radiation, transmitted\n               radiation, or omitted. `lt' is computed using the\n               method indicated by `abcorr'.\n\n               `trgepc' is expressed as seconds past J2000 TDB.\n\n\n   srfvec      is the vector from the observer's position at `et' to\n               the aberration-corrected (or optionally, geometric)\n               position of `spoint', where the aberration corrections\n               are specified by `abcorr'. `srfvec' is expressed in the\n               target body-fixed reference frame designated by\n               `fixref', evaluated at `trgepc'.\n\n               The components of `srfvec' are given in units of km.\n\n               One can use the CSPICE function vnorm_c to obtain the\n               distance between the observer and `spoint':\n\n                  dist = vnorm_c ( srfvec );\n\n               The observer's position `obspos', relative to the\n               target body's center, where the center's position is\n               corrected for aberration effects as indicated by\n               `abcorr', can be computed via the call:\n\n                  vsub_c ( spoint, srfvec, obspos );\n\n               To transform the vector `srfvec' to a time-dependent\n               reference frame `ref' at `et', a sequence of two frame\n               transformations is required. For example, let `mfix'\n               and `mref' be 3x3 matrices respectively describing the\n               target body-fixed to J2000 frame transformation at\n               `trgepc' and the J2000 to (time-dependent frame) `ref'\n               transformation at `et', and let `xform' be the 3x3 matrix\n               representing the composition of `mref' with `mfix'. Then\n               `srfvec' can be transformed to the result `refvec' as\n               follows:\n\n                   pxform_c ( fixref,  \"j2000\", trgepc, mfix   );\n                   pxform_c ( \"j2000\", ref,     et,     mref   );\n                   mxm_c    ( mref,    mfix,            xform  );\n                   mxv_c    ( xform,   srfvec,          refvec );\n\n               The second example in the Examples header section\n               below presents a complete program that demonstrates\n               this procedure.\n\n");

/* void subpt_c ( ConstSpiceChar * method,ConstSpiceChar * target,
SpiceDouble et,ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,
SpiceDouble spoint [3],SpiceDouble * alt ); */
static PyObject * spice_subpt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble spoint[3];
  SpiceDouble alt;
  /* variables for inputs */
  char * method;
  char * target;
  double et;
  char * abcorr;
  char * obsrvr;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdss", &method, &target, &et, &abcorr, &obsrvr));
  subpt_c(method, target, et, abcorr, obsrvr, spoint, &alt);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, spoint[0], spoint[1], spoint[2], alt);
  return returnVal;
}
PyDoc_STRVAR(subpt_doc, "-Abstract\n\n   Deprecated: This routine has been superseded by the CSPICE\n   routine subpnt_c. This routine is supported for purposes of\n   backward compatibility only.\n\n   Compute the rectangular coordinates of the sub-observer point on\n   a target body at a particular epoch, optionally corrected for\n   planetary (light time) and stellar aberration.  Return these\n   coordinates expressed in the body-fixed frame associated with the\n   target body.  Also, return the observer's altitude above the\n   target body.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   method     I   Computation method.\n   target     I   Name of target body.\n   et         I   Epoch in ephemeris seconds past J2000 TDB.\n   abcorr     I   Aberration correction.\n   obsrvr     I   Name of observing body.\n   spoint     O   Sub-observer point on the target body.\n   alt        O   Altitude of the observer above the target body.\n\n-Detailed_Input\n\n   method      is a short string specifying the computation method\n               to be used.  The choices are:\n\n                  \"Near point\"       The sub-observer point is\n                                     defined as the nearest point on\n                                     the target relative to the\n                                     observer.\n\n                  \"Intercept\"        The sub-observer point is\n                                     defined as the target surface\n                                     intercept of the line\n                                     containing the observer and the\n                                     target's center.\n\n               In both cases, the intercept computation treats the\n               surface of the target body as a triaxial ellipsoid.\n               The ellipsoid's radii must be available in the kernel\n               pool.\n\n               Neither case nor white space are significant in\n               `method'.  For example, the string \" NEARPOINT\" is\n               valid.\n\n\n   target      is the name of the target body.  `target' is\n               case-insensitive, and leading and trailing blanks in\n               `target' are not significant. Optionally, you may supply\n               a string containing the integer ID code for the object.\n               For example both \"MOON\" and \"301\" are legitimate strings\n               that indicate the moon is the target body.\n\n               This routine assumes that the target body is modeled by\n               a tri-axial ellipsoid, and that a PCK file containing\n               its radii has been loaded into the kernel pool via\n               furnsh_c.\n\n\n   et          is the epoch in ephemeris seconds past J2000 at which\n               the sub-observer point on the target body is to be\n               computed.\n\n\n   abcorr      indicates the aberration corrections to be applied\n               when computing the observer-target state.  `abcorr'\n               may be any of the following.\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric sub-observer point on the\n                             target body.\n\n                  \"LT\"       Correct for planetary (light time)\n                             aberration.  Both the state and rotation\n                             of the target body are corrected for\n                             light time.\n\n                  \"LT+S\"     Correct for planetary (light time) and\n                             stellar aberrations. Both the state and\n                             rotation of the target body are\n                             corrected for light time.\n\n                  \"CN\"       Converged Newtonian light time\n                             corrections.  This is the same as LT\n                             corrections but with further iterations\n                             to a converged Newtonian light time\n                             solution.  Given that relativistic\n                             effects may be as large as the higher\n                             accuracy achieved by this computation,\n                             this is correction is seldom worth the\n                             additional computations required unless\n                             the user incorporates additional\n                             relativistic corrections.  Both the\n                             state and rotation of the target body\n                             are corrected for light time.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             corrections and stellar aberration.\n                             Both the state and rotation of the\n                             target body are corrected for light\n                             time.\n\n   obsrvr      is the name of the observing body.  This is typically a\n               spacecraft, the earth, or a surface point on the earth.\n               `obsrvr' is case-insensitive, and leading and trailing\n               blanks in `obsrvr' are not significant. Optionally, you\n               may supply a string containing the integer ID code for\n               the object.  For example both \"EARTH\" and \"399\" are\n               legitimate strings that indicate the earth is the\n               observer.\n\n-Detailed_Output\n\n   spoint      is the sub-observer point on the target body at `et'\n               expressed relative to the body-fixed frame of the\n               target body.\n\n               The sub-observer point is defined either as the point\n               on the target body that is closest to the observer,\n               or the target surface intercept of the line from the\n               observer to the target's center; the input argument\n               `method' selects the definition to be used.\n\n               The body-fixed frame, which is time-dependent, is\n               evaluated at `et' if `abcorr' is \"NONE\"; otherwise the\n               frame is evaluated at et-lt, where `lt' is the one-way\n               light time from target to observer.\n\n               The state of the target body is corrected for\n               aberration as specified by `abcorr'; the corrected\n               state is used in the geometric computation.  As\n               indicated above, the rotation of the target is\n               retarded by one-way light time if `abcorr' specifies\n               that light time correction is to be done.\n\n   alt         is the \"altitude\" of the observer above the target\n               body.  When `method' specifies a \"near point\"\n               computation, `alt' is truly altitude in the standard\n               geometric sense:  the length of a segment dropped from\n               the observer to the target's surface, such that the\n               segment is perpendicular to the surface at the\n               contact point `spoint'.\n\n               When `method' specifies an \"intercept\" computation, `alt'\n               is still the length of the segment from the observer\n               to the surface point `spoint', but this segment in\n               general is not perpendicular to the surface.\n\n");

/* void subslr_c ( ConstSpiceChar * method,ConstSpiceChar * target,
SpiceDouble et,ConstSpiceChar * fixref,ConstSpiceChar * abcorr,
ConstSpiceChar * obsrvr,SpiceDouble spoint [3],SpiceDouble * trgepc,
SpiceDouble srfvec [3] ); */
static PyObject * spice_subslr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble spoint[3];
  SpiceDouble trgepc;
  SpiceDouble srfvec[3];
  /* variables for inputs */
  char * method;
  char * target;
  double et;
  char * fixref;
  char * abcorr;
  char * obsrvr;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdsss", &method, &target, &et, &fixref, &abcorr, &obsrvr));
  subslr_c(method, target, et, fixref, abcorr, obsrvr, spoint, &trgepc, srfvec);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, spoint[0], spoint[1], spoint[2], trgepc, srfvec[0], srfvec[1], srfvec[2]);
  return returnVal;
}
PyDoc_STRVAR(subslr_doc, "-Abstract\n\n   Compute the rectangular coordinates of the sub-solar point on\n   a target body at a specified epoch, optionally corrected for\n   light time and stellar aberration.\n\n   This routine supersedes subsol_c.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   method     I   Computation method.\n   target     I   Name of target body.\n   et         I   Epoch in ephemeris seconds past J2000 TDB.\n   fixref     I   Body-fixed, body-centered target body frame.\n   abcorr     I   Aberration correction.\n   obsrvr     I   Name of observing body.\n   spoint     O   Sub-solar point on the target body.\n   trgepc     O   Sub-solar point epoch.\n   srfvec     O   Vector from observer to sub-solar point.\n\n-Detailed_Input\n\n   method      is a short string providing parameters defining\n               the computation method to be used.\n\n               The supported values of `method' are listed below.\n               Please note that the colon is a required delimiter;\n               using a blank will not work.\n\n                  \"Near point: ellipsoid\"   The sub-solar point\n                                            computation uses a\n                                            triaxial ellipsoid to\n                                            model the surface of the\n                                            target body. The\n                                            sub-solar point is\n                                            defined as the nearest\n                                            point on the target\n                                            relative to the Sun.\n\n                  \"Intercept: ellipsoid\"    The sub-solar point\n                                            computation uses a\n                                            triaxial ellipsoid to\n                                            model the surface of the\n                                            target body. The\n                                            sub-solar point is\n                                            defined as the target\n                                            surface intercept of the\n                                            line containing the\n                                            Sun and the\n                                            target's center.\n\n               Neither case nor white space are significant in\n               `method'. For example, the string\n\n                 \" nearpoint:ELLIPSOID \"\n\n               is valid.\n\n\n   target      is the name of the target body. The target body is\n               an ephemeris object (its trajectory is given by\n               SPK data), and is an extended object.\n\n               The string `target' is case-insensitive, and leading\n               and trailing blanks in `target' are not significant.\n               Optionally, you may supply a string containing the\n               integer ID code for the object. For example both\n               \"MOON\" and \"301\" are legitimate strings that indicate\n               the Moon is the target body.\n\n               When the target body's surface is represented by a\n               tri-axial ellipsoid, this routine assumes that a\n               kernel variable representing the ellipsoid's radii is\n               present in the kernel pool. Normally the kernel\n               variable would be defined by loading a PCK file.\n\n\n   et          is the epoch of participation of the observer,\n               expressed as ephemeris seconds past J2000 TDB: `et' is\n               the epoch at which the observer's state is computed.\n\n               When aberration corrections are not used, `et' is also\n               the epoch at which the position and orientation of\n               the target body and the position of the Sun are computed.\n\n               When aberration corrections are used, `et' is the epoch\n               at which the observer's state relative to the solar\n               system barycenter is computed; in this case the position\n               and orientation of the target body are computed at\n               et-lt, where `lt' is the one-way light time between the\n               sub-solar point and the observer. See the description of\n               `abcorr' below for details.\n\n\n   fixref      is the name of the body-fixed, body-centered reference\n               frame associated with the target body. The output\n               sub-solar point `spoint' will be expressed relative to\n               this reference frame. The string `fixref' is\n               case-insensitive, and leading and trailing blanks in\n               `fixref' are not significant.\n\n\n   abcorr      indicates the aberration correction to be applied when\n               computing the target position and orientation, and the\n               position of the Sun.\n\n               For remote sensing applications, where the apparent\n               sub-solar point seen by the observer is desired,\n               normally either of the corrections\n\n                  \"LT+S\"\n                  \"CN+S\"\n\n               should be used. These and the other supported options\n               are described below. `abcorr' may be any of the\n               following:\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric sub-solar point on the\n                             target body.\n\n               Let `lt' represent the one-way light time between the\n               observer and the sub-solar point (note: NOT\n               between the observer and the target body's center).\n               The following values of `abcorr' apply to the\n               \"reception\" case in which photons depart from the\n               sub-solar point's location at the light-time\n               corrected epoch et-lt and *arrive* at the observer's\n               location at `et':\n\n\n                  \"LT\"       Correct for one-way light time (also\n                             called \"planetary aberration\") using a\n                             Newtonian formulation. This correction\n                             yields the location of sub-solar\n                             point at the moment it emitted photons\n                             arriving at the observer at `et'.\n\n                             The light time correction uses an\n                             iterative solution of the light time\n                             equation. The solution invoked by the\n                             \"LT\" option uses one iteration.\n\n                             The target position and orientation as\n                             seen by the observer are corrected for\n                             light time. The position of the Sun\n                             relative to the target is corrected for\n                             one-way light time between the Sun and\n                             target.\n\n\n                  \"LT+S\"     Correct for one-way light time and stellar\n                             aberration using a Newtonian formulation.\n                             This option modifies the sub-solar point\n                             obtained with the \"LT\" option to account\n                             for the observer's velocity relative to\n                             the solar system barycenter. These\n                             corrections yield the apparent\n                             sub-solar point.\n\n\n                  \"CN\"       Converged Newtonian light time\n                             correction. In solving the light time\n                             equation, the \"CN\" correction iterates\n                             until the solution converges. Both the\n                             position and rotation of the target\n                             body, and the position of the Sun,\n                             are corrected for light time.\n\n                  \"CN+S\"     Converged Newtonian light time and\n                             stellar aberration corrections. This\n                             option produces a solution that is at\n                             least as accurate at that obtainable\n                             with the \"LT+S\" option. Whether the \"CN+S\"\n                             solution is substantially more accurate\n                             depends on the geometry of the\n                             participating objects and on the\n                             accuracy of the input data. In all\n                             cases this routine will execute more\n                             slowly when a converged solution is\n                             computed.\n\n                Neither case nor white space are significant in\n                `abcorr'. For example, the string\n\n                  'Lt + s'\n\n                is valid.\n\n\n   obsrvr      is the name of the observing body. The observing body\n               is an ephemeris object: it typically is a spacecraft,\n               the earth, or a surface point on the earth. `obsrvr' is\n               case-insensitive, and leading and trailing blanks in\n               `obsrvr' are not significant. Optionally, you may\n               supply a string containing the integer ID code for\n               the object. For example both \"MOON\" and \"301\" are\n               legitimate strings that indicate the Moon is the\n               observer.\n\n-Detailed_Output\n\n\n   spoint      is the sub-solar point on the target body.\n\n               The sub-solar point is defined either as the point\n               on the target body that is closest to the Sun,\n               or the target surface intercept of the line from the\n               Sun to the target's center; the input argument\n               `method' selects the definition to be used.\n\n               `spoint' is expressed in Cartesian coordinates,\n               relative to the body-fixed target frame designated by\n               `fixref'. The body-fixed target frame is evaluated at\n               the sub-solar epoch `trgepc' (see description below).\n\n               When light time correction is used, the duration of\n               light travel between `spoint' to the observer is\n               considered to be the one way light time.\n\n               When aberration corrections are used, `spoint' is\n               computed using target body position and orientation\n               that have been adjusted for the corrections\n               applicable to `spoint' itself rather than to the target\n               body's center. In particular, if the stellar\n               aberration correction applicable to `spoint' is\n               represented by a shift vector `s', then the light-time\n               corrected position of the target is shifted by `s'\n               before the sub-solar point is computed.\n\n               The components of `spoint' have units of km.\n\n\n   trgepc      is the \"sub-solar point epoch.\" `trgepc' is defined\n               as follows: letting `lt' be the one-way light time\n               between the observer and the sub-solar point,\n               `trgepc' is either the epoch et-lt or `et' depending on\n               whether the requested aberration correction is,\n               respectively, for received radiation or omitted. `lt' is\n               computed using the method indicated by `abcorr'.\n\n               `trgepc' is expressed as seconds past J2000 TDB.\n\n\n   srfvec      is the vector from the observer's position at `et' to\n               the aberration-corrected (or optionally, geometric)\n               position of `spoint', where the aberration corrections\n               are specified by `abcorr'. `srfvec' is expressed in the\n               target body-fixed reference frame designated by\n               `fixref', evaluated at `trgepc'.\n\n\n               The components of `srfvec' are given in units of km.\n\n               One can use the CSPICE function vnorm_c to obtain the\n               distance between the observer and `spoint':\n\n                  dist = vnorm_c ( srfvec );\n\n               The observer's position `obspos', relative to the\n               target body's center, where the center's position is\n               corrected for aberration effects as indicated by\n               `abcorr', can be computed via the call:\n\n                  vsub_c ( spoint, srfvec, obspos );\n\n               To transform the vector `srfvec' to a time-dependent\n               reference frame `ref' at `et', a sequence of two frame\n               transformations is required. For example, let `mfix'\n               and `mref' be 3x3 matrices respectively describing the\n               target body-fixed to J2000 frame transformation at\n               `trgepc' and the J2000 to (time-dependent frame) `ref'\n               transformation at `et', and let `xform' be the 3x3 matrix\n               representing the composition of `mref' with `mfix'. Then\n               `srfvec' can be transformed to the result `refvec' as\n               follows:\n\n                   pxform_c ( fixref,  \"j2000\", trgepc, mfix   );\n                   pxform_c ( \"j2000\", ref,     et,     mref   );\n                   mxm_c    ( mref,    mfix,            xform  );\n                   mxv_c    ( xform,   srfvec,          refvec );\n\n               The second example in the Examples header section\n               below presents a complete program that demonstrates\n               this procedure.\n\n");

/* void subsol_c ( ConstSpiceChar * method,ConstSpiceChar * target,
SpiceDouble et,ConstSpiceChar * abcorr,ConstSpiceChar * obsrvr,
SpiceDouble spoint[3] ); */
static PyObject * spice_subsol(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble spoint[3];
  /* variables for inputs */
  char * method;
  char * target;
  double et;
  char * abcorr;
  char * obsrvr;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssdss", &method, &target, &et, &abcorr, &obsrvr));
  subsol_c(method, target, et, abcorr, obsrvr, spoint);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, spoint[0], spoint[1], spoint[2]);
  return returnVal;
}
PyDoc_STRVAR(subsol_doc, "-Abstract\n\n   Deprecated: This routine has been superseded by the CSPICE\n   routine subslr_c. This routine is supported for purposes of\n   backward compatibility only.\n\n   Determine the coordinates of the sub-solar point on a target\n   body as seen by a specified observer at a specified epoch,\n   optionally corrected for planetary (light time) and stellar\n   aberration.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   method     I   Computation method.\n   target     I   Name of target body.\n   et         I   Epoch in ephemeris seconds past J2000 TDB.\n   abcorr     I   Aberration correction.\n   obsrvr     I   Name of observing body.\n   spoint     O   Sub-solar point on the target body.\n\n-Detailed_Input\n\n   method      is a short string specifying the computation method\n               to be used.  The choices are:\n\n                  \"Near point\"       The sub-solar point is defined\n                                     as the nearest point on the\n                                     target to the sun.\n\n                  \"Intercept\"        The sub-observer point is defined\n                                     as the target surface intercept of\n                                     the line containing the target's\n                                     center and the sun's center.\n\n               In both cases, the intercept computation treats the\n               surface of the target body as a triaxial ellipsoid.\n               The ellipsoid's radii must be available in the kernel\n               pool.\n\n               Neither case nor white space are significant in\n               method.  For example, the string \" NEARPOINT\" is\n               valid.\n\n\n   target      is the name of the target body.  `target' is\n               case-insensitive, and leading and trailing blanks in\n               `target' are not significant. Optionally, you may supply\n               a string containing the integer ID code for the object.\n               For example both \"MOON\" and \"301\" are legitimate strings\n               that indicate the moon is the target body.\n\n               This routine assumes that the target body is modeled by\n               a tri-axial ellipsoid, and that a PCK file containing\n               its radii has been loaded into the kernel pool via\n               furnsh_c.\n\n\n   et          is the epoch in ephemeris seconds past J2000 at which\n               the sub-solar point on the target body is to be\n               computed.\n\n\n   abcorr      indicates the aberration corrections to be applied\n               when computing the observer-target state.  abcorr\n               may be any of the following.\n\n                  \"NONE\"     Apply no correction. Return the\n                             geometric sub-solar point on the target\n                             body.\n\n                  \"LT\"       Correct for planetary (light time)\n                             aberration.  Both the state and rotation\n                             of the target body are corrected for one\n                             way light time from target to observer.\n\n                             The state of the sun relative to the\n                             target is corrected for one way light\n                             from the sun to the target; this state\n                             is evaluated at the epoch obtained by\n                             retarding et by the one way light time\n                             from target to observer.\n\n                  \"LT+S\"     Correct for planetary (light time) and\n                             stellar aberrations.  Light time\n                             corrections are the same as in the \"LT\"\n                             case above.  The target state is\n                             additionally corrected for stellar\n                             aberration as seen by the observer, and\n                             the sun state is corrected for stellar\n                             aberration as seen from the target.\n\n                  \"CN\"       Converged Newtonian light time\n                             corrections.  This is the same as LT\n                             corrections but with further iterations\n                             to a converged Newtonian light time\n                             solution.  Given that relativistic\n                             effects may be as large as the higher\n                             accuracy achieved by this computation,\n                             this is correction is seldom worth the\n                             additional computations required unless\n                             the user incorporates additional\n                             relativistic corrections.  Light\n                             time corrections are applied as in the\n                             \"LT\" case.\n\n                  \"CN+S\"     Converged Newtonian light time\n                             corrections and stellar aberration.\n                             Light time and stellar aberration\n                             corrections are applied as in the\n                             \"LT+S\" case.\n\n\n   obsrvr      is the name of the observing body.  This is typically\n               a spacecraft, the earth, or a surface point on the\n               earth.  `obsrvr' is case-insensitive, and leading and\n               trailing blanks in `obsrvr' are not significant.\n               Optionally, you may supply a string containing the\n               integer ID code for the object.  For example both\n               \"EARTH\" and \"399\" are legitimate strings that indicate\n               the earth is the observer.\n\n\n-Detailed_Output\n\n   spoint      is the sub-solar point on the target body at et,\n               expressed relative to the body-fixed frame of the\n               target body.\n\n               The sub-solar point is defined either as the point on\n               the target body that is closest to the sun, or the\n               target surface intercept of the line containing the sun's\n               center and the target's center; the input argument\n               method selects the definition to be used.\n\n               The body-fixed frame, which is time-dependent, is\n               evaluated at et if abcorr is \"NONE\"; otherwise the\n               frame is evaluated at et-lt, where lt is the one way\n               light time from target to observer.\n\n               The state of the target body is corrected for\n               aberration as specified by abcorr; the corrected\n               state is used in the geometric computation.  As\n               indicated above, the rotation of the target is\n               retarded by one way light time if abcorr specifies\n               that light time correction is to be done.\n\n               The state of the sun as seen from the target body\n               body is also corrected for aberration as specified\n               by abcorr.  The corrections, when selected, are\n               applied at the epoch et-lt, where lt is the one way\n               light time from target to observer.\n\n");

/* void surfnm_c ( SpiceDouble a,SpiceDouble b,SpiceDouble c,
ConstSpiceDouble point[3],SpiceDouble normal[3] ); */
static PyObject * spice_surfnm(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble normal[3];
  /* variables for inputs */
  double a;
  double b;
  double c;
  double point[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd(ddd)", &a, &b, &c, &point[0], &point[1], &point[2]));
  surfnm_c(a, b, c, point, normal);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, normal[0], normal[1], normal[2]);
  return returnVal;
}
PyDoc_STRVAR(surfnm_doc, "-Abstract\n\n   This routine computes the outward-pointing, unit normal vector\n   from a point on the surface of an ellipsoid.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   Length of the ellisoid semi-axis along the x-axis.\n   b          I   Length of the ellisoid semi-axis along the y-axis.\n   c          I   Length of the ellisoid semi-axis along the z-axis.\n   point      I   Body-fixed coordinates of a point on the ellipsoid\n   normal     O   Outward pointing unit normal to ellipsoid at point\n\n-Detailed_Input\n\n   a          This is the length of the semi-axis of the ellipsoid\n              that is parallel to the x-axis of the body-fixed\n              coordinate system.\n\n   b          This is the length of the semi-axis of the ellipsoid\n              that is parallel to the y-axis of the body-fixed\n              coordinate system.\n\n   c          This is the length of the semi-axis of the ellipsoid\n              that is parallel to the z-axis of the body-fixed\n              coordinate system.\n\n   point      This is a 3-vector giving the bodyfixed coordinates\n              of a point on the ellipsoid. In bodyfixed coordinates,\n              the semi-axes of the ellipsoid are aligned with the\n              x, y, and z-axes of the coordinate system.\n\n-Detailed_Output\n\n   normal    A unit vector pointing away from the ellipsoid and\n             normal to the ellipsoid at point.\n\n");

/* void surfpt_c ( ConstSpiceDouble positn[3],ConstSpiceDouble u[3],
SpiceDouble a,SpiceDouble b,SpiceDouble c,SpiceDouble point[3],
SpiceBoolean * found ); */
static PyObject * spice_surfpt(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble point[3];
  SpiceBoolean found;
  /* variables for inputs */
  double positn[3];
  double u[3];
  double a;
  double b;
  double c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)ddd", &positn[0], &positn[1], &positn[2], &u[0], &u[1], &u[2], &a, &b, &c));
  surfpt_c(positn, u, a, b, c, point, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, point[0], point[1], point[2]);
  return returnVal;
  }

}
PyDoc_STRVAR(surfpt_doc, "-Abstract\n\n   Determine the intersection of a line-of-sight vector with the\n   surface of an ellipsoid.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   positn     I   Position of the observer in body-fixed frame.\n   u          I   Vector from the observer in some direction.\n   a          I   Length of the ellipsoid semi-axis along the x-axis.\n   b          I   Length of the ellipsoid semi-axis along the y-axis.\n   c          I   Length of the ellipsoid semi-axis along the z-axis.\n   point      O   Point on the ellipsoid pointed to by u.\n   found      O   Flag indicating if u points at the ellipsoid.\n\n-Detailed_Input\n\n   positn     3-vector giving the position of an observer with respect\n              to the center of an ellipsoid.  The vector is expressed\n              in a body-fixed reference frame. The semi-axes of the\n              ellipsoid are aligned with the x, y, and z-axes of the\n              body-fixed frame.\n\n   u          Direction vector emanating from the observer.\n\n   a          Length of the semi-axis of the ellipsoid that is parallel\n              to the x-axis of the body-fixed reference frame.\n\n   b          Length of the semi-axis of the ellipsoid that is parallel\n              to the y-axis of the body-fixed reference frame.\n\n   c          Length of the semi-axis of the ellipsoid that is parallel\n              to the z-axis of the body-fixed reference frame.\n\n\n-Detailed_Output\n\n   point      If the ray with direction vector u emanating from\n              positn intersects the ellipsoid, point will be\n              returned with the body-fixed coordinates of the point\n              where the ray first meets the ellipsoid.  Otherwise,\n              point will be returned as (0, 0, 0).\n\n   found      A logical flag indicating whether or not the ray from\n              positn with direction u actually intersects the\n              ellipsoid.  If the ray does intersect the ellipsoid,\n              found will be returned as SPICETRUE. If the ray misses\n              the ellipsoid, found will be returned as SPICEFALSE.\n\n");

/* void surfpv_c ( ConstSpiceDouble stvrtx[6],ConstSpiceDouble stdir [6],
SpiceDouble a,SpiceDouble b,SpiceDouble c,SpiceDouble stx [6],
SpiceBoolean * found ); */
static PyObject * spice_surfpv(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble stx[6];
  SpiceBoolean found;
  /* variables for inputs */
  double stvrtx[6];
  double stdir[6];
  double a;
  double b;
  double c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(dddddd)(dddddd)ddd", &stvrtx[0], &stvrtx[1], &stvrtx[2], &stvrtx[3], &stvrtx[4], &stvrtx[5], &stdir[0], &stdir[1], &stdir[2], &stdir[3], &stdir[4], &stdir[5], &a, &b, &c));
  surfpv_c(stvrtx, stdir, a, b, c, stx, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, stx[0], stx[1], stx[2], stx[3], stx[4], stx[5]);
  return returnVal;
  }

}
PyDoc_STRVAR(surfpv_doc, "-Abstract\n\n   Find the state (position and velocity) of the surface intercept\n   defined by a specified ray, ray velocity, and ellipsoid.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   stvrtx     I   State of ray's vertex.\n   stdir      I   State of ray's direction vector.\n   a          I   Length of ellipsoid semi-axis along the x-axis.\n   b          I   Length of ellipsoid semi-axis along the y-axis.\n   c          I   Length of ellipsoid semi-axis along the z-axis.\n   stx        O   State of surface intercept.\n   found      O   Flag indicating whether intercept state was found.\n\n-Detailed_Input\n\n   stvrtx         is the state of a ray's vertex. The first three\n                  components of `stvrtx' are the vertex's x, y, and z\n                  position components; the vertex's x, y, and z\n                  velocity components follow.\n\n                  The reference frame relative to which `stvrtx' is\n                  specified has axes aligned with with those of a\n                  triaxial ellipsoid. See the description below of the\n                  arguments `a', `b', and `c'.\n\n                  The vertex may be inside or outside of this\n                  ellipsoid, but not on it, since the surface intercept\n                  is a discontinuous function at vertices on the\n                  ellipsoid's surface.\n\n                  No assumption is made about the units of length and\n                  time, but these units must be consistent with those\n                  of the other inputs.\n\n\n   stdir          is the state of the input ray's direction vector.\n                  The first three components of `stdir' are a non-zero\n                  vector giving the x, y, and z components of the\n                  ray's direction; the direction vector's x, y, and\n                  z velocity components follow.\n\n                  `stdir' is specified relative to the same reference\n                  frame as is `stvrtx'.\n\n\n   a,\n   b,\n   c              are, respectively, the lengths of a triaxial\n                  ellipsoid's semi-axes lying along the x, y, and\n                  z axes of the reference frame relative to which\n                  `stvrtx' and `stdir' are specified.\n\n-Detailed_Output\n\n   stx            is the state of the intercept of the input ray on the\n                  surface of the input ellipsoid. The first three\n                  components of `stx' are the intercept's x, y, and z\n                  position components; the intercept's x, y, and z\n                  velocity components follow.\n\n                  `stx' is specified relative to the same reference\n                  frame as are `stvrtx' and `stdir'.\n\n                  `stx' is defined if and only if both the intercept\n                  and its velocity are computable, as indicated by the\n                  output argument `found'.\n\n                  The position units of `stx' are the same as those of\n                  `stvrtx', `stdir', and `a', `b', and `c'. The time\n                  units are the same as those of `stvrtx' and `stdir'.\n\n\n   found          is a logical flag indicating whether `stx' is\n                  defined. `found' is SPICETRUE if and only if both the\n                  intercept and its velocity are computable. Note\n                  that in some cases the intercept may computable\n                  while the velocity is not; this can happen for\n                  near-tangency cases.\n\n");

/* void sxform_c ( ConstSpiceChar * from,ConstSpiceChar * to,SpiceDouble et,
SpiceDouble xform[6][6] ); */
static PyObject * spice_sxform(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble xform[6][6];
  /* variables for inputs */
  char * from;
  char * to;
  double et;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ssd", &from, &to, &et));
  sxform_c(from, to, et, xform);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((dddddd)(dddddd)(dddddd)(dddddd)(dddddd)(dddddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, xform[0][0], xform[0][1], xform[0][2], xform[0][3], xform[0][4], xform[0][5], xform[1][0], xform[1][1], xform[1][2], xform[1][3], xform[1][4], xform[1][5], xform[2][0], xform[2][1], xform[2][2], xform[2][3], xform[2][4], xform[2][5], xform[3][0], xform[3][1], xform[3][2], xform[3][3], xform[3][4], xform[3][5], xform[4][0], xform[4][1], xform[4][2], xform[4][3], xform[4][4], xform[4][5], xform[5][0], xform[5][1], xform[5][2], xform[5][3], xform[5][4], xform[5][5]);
  return returnVal;
}
PyDoc_STRVAR(sxform_doc, "-Abstract\n\n   Return the state transformation matrix from one frame to\n   another at a specified epoch.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   from       I   Name of the frame to transform from.\n   to         I   Name of the frame to transform to.\n   et         I   Epoch of the state transformation matrix.\n   xform      O   A state transformation matrix.\n\n-Detailed_Input\n\n   from        is the name of a reference frame in which a state is\n               known.\n\n   to          is the name of a reference frame in which it is desired\n               to represent the state.\n\n   et          is the epoch in ephemeris seconds past the epoch of\n               J2000 (TDB) at which the state transformation matrix\n               should be evaluated.\n\n-Detailed_Output\n\n   xform       is the matrix that transforms states from the reference\n               frame `from' to the frame `to' at epoch `et'. If (x, y,\n               z, dx, dy, dz) is a state relative to the frame `from'\n               then the vector ( x', y', z', dx', dy', dz' ) is the\n               same state relative to the frame `to' at epoch `et'.\n               Here the vector ( x', y', z', dx', dy', dz' ) is defined\n               by the equation:\n\n                  -   -       -          -     -  -\n                 | x'  |     |            |   | x  |\n                 | y'  |     |            |   | y  |\n                 | z'  |  =  |   xform    |   | z  |\n                 | dx' |     |            |   | dx |\n                 | dy' |     |            |   | dy |\n                 | dz' |     |            |   | dz |\n                  -   -       -          -     -  -\n\n");

/* void szpool_c ( ConstSpiceChar * name,SpiceInt * n,SpiceBoolean * found ); */
static PyObject * spice_szpool(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceInt n;
  SpiceBoolean found;
  /* variables for inputs */
  char * name;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &name));
  szpool_c(name, &n, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "i");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, n);
  return returnVal;
  }

}
PyDoc_STRVAR(szpool_doc, "-Abstract\n\n   Return the kernel pool size limitations.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   name       I   Name of the parameter to be returned.\n   n          O   Value of parameter specified by name.\n   found      O   SPICETRUE if name is recognized.\n\n-Detailed_Input\n\n   name       is the name of a kernel pool size parameter.\n              The following parameters may be specified:\n\n              MAXVAR      is the maximum number of variables that the\n                          kernel pool may contain at any one time.\n                          MAXVAR should be a prime number.\n\n              MAXLEN      is the maximum length of the variable names\n                          that can be stored in the kernel pool.\n\n              MAXVAL      is the maximum number of distinct values that\n                          may belong to the variables in the kernel\n                          pool.  Each variable must have at least one\n                          value, and may have any number, so long as\n                          the total number does not exceed MAXVAL.\n                          MAXVAL must be at least as large as MAXVAR.\n\n              MXNOTE      is the maximum number of distinct\n                          variable-agents pairs that can be maintained\n                          by the kernel pool.  (A variable is \"paired\"\n                          with an agent, if that agent is to be\n                          notified whenever the variable is updated.)\n\n              MAXAGT      is the maximum number of agents that can be\n                          kept on the distribution list for\n                          notification of updates to kernel variables.\n\n              MAXCHR      is the maximum number of characters that can\n                          be stored in a component of a string valued\n                          kernel variable.\n\n              MAXLIN      is the maximum number of character strings\n                          that can be stored as data for kernel pool\n                          variables.\n\n              Note that the case of name is insignificant.  Embedded\n              blanks are also ignored.\n\n-Detailed_Output\n\n   n          is the value of the parameter specified by name.  If\n              name is not one of the items specified above, n will\n              be returned with the value 0.\n\n   found      is SPICETRUE if the parameter is recognized and\n              SPICEFALSE if it is not.\n\n");

/* void timdef_c ( ConstSpiceChar * action,ConstSpiceChar * item,
SpiceInt lenout,SpiceChar * value ); */
static PyObject * spice_timdef(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar value[STRING_LEN];
  /* variables for inputs */
  char * action;
  char * item;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ss", &action, &item));
  timdef_c(action, item, lenout, value);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, value);
  return returnVal;
}
PyDoc_STRVAR(timdef_doc, "-Abstract\n\n   Set and retrieve the defaults associated with calendar\n   input strings.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   action     I   is the kind of action to take \"SET\" or \"GET\".\n   item       I   is the default item of interest.\n   lenout     I   Length of list for output.\n   value     I/O  is the value associated with the default item.\n\n-Detailed_Input\n\n   action     is a word that specifies whether timdef_c sets the\n              value associated with item or retrieves the value\n              associated with item.  The allowed values for\n              action are \"SET\" and \"GET\".  The routine is not\n              sensitive to the case of the letters in action.\n\n   item       is the default items whose value should be set or\n              retrieved.  The items that may be requested are:\n\n              item        Allowed Values\n              ---------   --------------\n              CALENDAR    GREGORIAN\n                          JULIAN\n                          MIXED\n\n              SYSTEM      TDB\n                          TDT\n                          UTC\n\n              ZONE        EST, EDT, CST, CDT, MST, MDT, PST, PDT\n                          UTC+HR\n                          UTC-HR       ( 0 <= HR < 13 )\n                          UTC+HR:MN    ( 0 <= MN < 60 )\n                          UTC-HR:MN\n\n              The case of item is not significant.\n\n   lenout     is the allowed length of the string when returning a\n              value via a \"GET\".  The size described by lenout should\n              be large enough to hold any possible output plus 1.\n\n   value      if the action is \"SET\" then value is an input and\n              is the value to be associated with item.  Note that\n              value is checked to ensure it is within the range\n              of allowed values for item.  If it is not within\n              the expected range and appropriate error message\n              is signalled.  The case of value is not significant.\n\n-Detailed_Output\n\n   value      if the action is \"GET\" then value will be the\n              value associated with the requested item.  Note that\n              when time zones are set, they are translated to the\n              UTC offset form ( UTC(+/-)HR[:MN] ).  When value is\n              an output it will be in upper case.\n\n");

/* void timout_c ( SpiceDouble et,ConstSpiceChar * pictur,SpiceInt lenout,
SpiceChar * output ); */
static PyObject * spice_timout(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar output[STRING_LEN];
  /* variables for inputs */
  double et;
  char * pictur;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ds", &et, &pictur));
  timout_c(et, pictur, lenout, output);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, output);
  return returnVal;
}
PyDoc_STRVAR(timout_doc, "-Abstract\n\n   This routine converts an input epoch represented in TDB seconds\n   past the TDB epoch of J2000 to a character string formatted to\n   the specifications of a user's format picture.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   et         I   An epoch in seconds past the ephemeris epoch J2000.\n   pictur     I   A format specification for the output string.\n   lenout     I   The length of the output string plus 1.\n   output     O   A string representation of the input epoch.\n\n-Detailed_Input\n\n   et         a double precision representation of time in seconds\n              past the ephemeris epoch J2000.\n\n   pictur     is a string that specifies how the output should be\n              presented.  The string is made up of various markers\n              that stand for various components associated with\n              a time.\n\n              There are five types of markers that may appear in a\n              format picture.  These are String Markers, Numeric\n              Markers, Meta markers, Modifier Markers and Literal\n              Markers.\n\n              The pictur string is examined and the various markers\n              are identified. The output time string is constructed\n              by replacing each of the identified markers with\n              an appropriate time component.\n\n              The various markers and their meanings are discussed\n              in the Particulars section below.\n\n   lenout     The allowed length of the output string.  This length\n              must large enough to hold the output string plus the\n              terminator.  If the output string is expected to have x\n              characters, lenout needs to be x + 1.\n\n-Detailed_Output\n\n   output     is the input epoch converted to the string format\n              described by pictur\n\n");

/* void tipbod_c ( ConstSpiceChar * ref,SpiceInt body,SpiceDouble et,
SpiceDouble tipm[3][3] ); */
static PyObject * spice_tipbod(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble tipm[3][3];
  /* variables for inputs */
  char * ref;
  int body;
  double et;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sid", &ref, &body, &et));
  tipbod_c(ref, body, et, tipm);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, tipm[0][0], tipm[0][1], tipm[0][2], tipm[1][0], tipm[1][1], tipm[1][2], tipm[2][0], tipm[2][1], tipm[2][2]);
  return returnVal;
}
PyDoc_STRVAR(tipbod_doc, "-Abstract\n\n   Return a 3x3 matrix that transforms positions in inertial\n   coordinates to positions in body-equator-and-prime-meridian\n   coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   ref        I   ID of inertial reference frame to transform from.\n   body       I   ID code of body.\n   et         I   Epoch of transformation.\n   tipm       O   Transformation (position), inertial to prime\n                  meridian.\n\n-Detailed_Input\n\n   ref         is the NAIF name for an inertial reference frame.\n               Acceptable names include:\n\n                 Name       Description\n                 --------   --------------------------------\n                 \"J2000\"    Earth mean equator, dynamical\n                            equinox of J2000\n\n                 \"B1950\"    Earth mean equator, dynamical\n                            equinox of B1950\n\n                 \"FK4\"      Fundamental Catalog (4)\n\n                 \"DE-118\"   JPL Developmental Ephemeris (118)\n\n                 \"DE-96\"    JPL Developmental Ephemeris ( 96)\n\n                 \"DE-102\"   JPL Developmental Ephemeris (102)\n\n                 \"DE-108\"   JPL Developmental Ephemeris (108)\n\n                 \"DE-111\"   JPL Developmental Ephemeris (111)\n\n                 \"DE-114\"   JPL Developmental Ephemeris (114)\n\n                 \"DE-122\"   JPL Developmental Ephemeris (122)\n\n                 \"DE-125\"   JPL Developmental Ephemeris (125)\n\n                 \"DE-130\"   JPL Developmental Ephemeris (130)\n\n                 \"GALACTIC\" Galactic System II\n\n                 \"DE-200\"   JPL Developmental Ephemeris (200)\n\n                 \"DE-202\"   JPL Developmental Ephemeris (202)\n\n               (See the routine CHGIRF for a full list of names.)\n\n               The output tipm will give the transformation\n               from this frame to the bodyfixed frame specified by\n               body at the epoch specified by et.\n\n\n   body        is the integer ID code of the body for which the\n               position transformation matrix is requested. Bodies\n               are numbered according to the standard NAIF\n               numbering scheme.  The numbering scheme is\n               explained in the NAIF_IDS required reading file.\n\n   et          is the epoch at which the position transformation\n               matrix is requested. (This is typically the\n               epoch of observation minus the one-way light time\n               from the observer to the body at the epoch of\n               observation.)\n\n-Detailed_Output\n\n   tipm        is a 3x3 coordinate transformation matrix.  It is\n               used to transform positions from inertial coordinates to\n               body fixed (also called equator and prime meridian)\n               coordinates.\n\n               Given a position P in the inertial reference frame\n               specified by ref, the corresponding bodyfixed\n               position is given by the matrix vector product\n\n                  tipm * s\n\n               The X axis of the PM system is directed to the\n               intersection of the equator and prime meridian.\n               The Z axis points along  the spin axis and points\n               towards the same side of the invariable plane of\n               the solar system as does earth's north pole.\n\n");

/* void tisbod_c ( ConstSpiceChar * ref,SpiceInt body,SpiceDouble et,
SpiceDouble tsipm[6][6] ); */
static PyObject * spice_tisbod(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble tsipm[6][6];
  /* variables for inputs */
  char * ref;
  int body;
  double et;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "sid", &ref, &body, &et));
  tisbod_c(ref, body, et, tsipm);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((dddddd)(dddddd)(dddddd)(dddddd)(dddddd)(dddddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, tsipm[0][0], tsipm[0][1], tsipm[0][2], tsipm[0][3], tsipm[0][4], tsipm[0][5], tsipm[1][0], tsipm[1][1], tsipm[1][2], tsipm[1][3], tsipm[1][4], tsipm[1][5], tsipm[2][0], tsipm[2][1], tsipm[2][2], tsipm[2][3], tsipm[2][4], tsipm[2][5], tsipm[3][0], tsipm[3][1], tsipm[3][2], tsipm[3][3], tsipm[3][4], tsipm[3][5], tsipm[4][0], tsipm[4][1], tsipm[4][2], tsipm[4][3], tsipm[4][4], tsipm[4][5], tsipm[5][0], tsipm[5][1], tsipm[5][2], tsipm[5][3], tsipm[5][4], tsipm[5][5]);
  return returnVal;
}
PyDoc_STRVAR(tisbod_doc, "-Abstract\n\n   Return a 6x6 matrix that transforms states in inertial coordinates to\n   states in body-equator-and-prime-meridian coordinates.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   ref        I   ID of inertial reference frame to transform from\n   body       I   ID code of body\n   et         I   Epoch of transformation\n   tsipm      O   Transformation (state), inertial to prime meridian\n\n-Detailed_Input\n\n   ref         is the NAIF name for an inertial reference frame.\n               Acceptable names include:\n\n                  Name       Description\n                  --------   --------------------------------\n                  \"J2000\"    Earth mean equator, dynamical\n                             equinox of J2000\n\n                  \"B1950\"    Earth mean equator, dynamical\n                             equinox of B1950\n\n                  \"FK4\"      Fundamental Catalog (4)\n\n                  \"DE-118\"   JPL Developmental Ephemeris (118)\n\n                  \"DE-96\"    JPL Developmental Ephemeris ( 96)\n\n                  \"DE-102\"   JPL Developmental Ephemeris (102)\n\n                  \"DE-108\"   JPL Developmental Ephemeris (108)\n\n                  \"DE-111\"   JPL Developmental Ephemeris (111)\n\n                  \"DE-114\"   JPL Developmental Ephemeris (114)\n\n                  \"DE-122\"   JPL Developmental Ephemeris (122)\n\n                  \"DE-125\"   JPL Developmental Ephemeris (125)\n\n                  \"DE-130\"   JPL Developmental Ephemeris (130)\n\n                  \"GALACTIC\" Galactic System II\n\n                  \"DE-200\"   JPL Developmental Ephemeris (200)\n\n                  \"DE-202\"   JPL Developmental Ephemeris (202)\n\n               (See the routine chgirf_c for a full list of names.)\n\n               The output tipm will give the transformation\n               from this frame to the bodyfixed frame specified by\n               body at the epoch specified by et.\n\n   body        is the integer ID code of the body for which the\n               state transformation matrix is requested. Bodies\n               are numbered according to the standard NAIF\n               numbering scheme.  The numbering scheme is\n               explained in the NAIF_IDS required reading file.\n\n   et          is the epoch at which the state transformation\n               matrix is requested. (This is typically the\n               epoch of observation minus the one-way light time\n               from the observer to the body at the epoch of\n               observation.)\n\n-Detailed_Output\n\n   tsipm       is a 6x6 transformation matrix.  It is used to\n               transform states from inertial coordinates to body\n               fixed (also called equator and prime meridian --- PM)\n\n\n               Given a state s in the inertial reference frame\n               specified by ref, the corresponding bodyfixed state\n               is given by the matrix vector product:\n\n                  tsipm * s\n\n               The X axis of the PM system is directed  to the\n               intersection of the equator and prime meridian.\n               The Z axis points along  the spin axis and points\n               towards the same side of the invariable plane of\n               the solar system as does earth's north pole.\n\n               NOTE: The inverse of tsipm is NOT its transpose.\n               The matrix tsipm has the structure shown below:\n\n                    -            -\n                   |       :      |\n                   |   r   :  0   |\n                   | ......:......|\n                   |       :      |\n                   | dr_dt :  r   |\n                   |       :      |\n                    -            -\n\n               where r is a time varying rotation matrix and\n               dr_dt is its derivative.  The inverse of this\n               matrix is:\n\n                    -              -\n                   |     T  :       |\n                   |    r   :  0    |\n                   | .......:.......|\n                   |        :       |\n                   |      T :   T   |\n                   | dr_dt  :  r    |\n                   |        :       |\n                    -              -\n\n               The CSPICE routine invstm_c is available for\n               producing this inverse.\n\n");

/* ConstSpiceChar * tkvrsn_c ( ConstSpiceChar * item ); */
static PyObject * spice_tkvrsn(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * item;

  char failed = 0;

  /* variable for result */
  ConstSpiceChar * result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &item));
  result = tkvrsn_c(item);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("s", result);
}
PyDoc_STRVAR(tkvrsn_doc, "-Abstract\n\n   Given an item such as the Toolkit or an entry point name, return\n   the latest version string.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   item       I   Item for which a version string is desired.\n\n   The function returns a pointer to a version string.\n\n-Detailed_Input\n\n   item       is the item for which a version string is to be\n              returned. item may be \"TOOLKIT\", entry point names,\n              or program names. item is case insensitive.\n\n              Currently, the only item supported is \"toolkit\"\n              and it will return the toolkit version number.\n\n              Any other item will return \"No version found.\"\n\n-Detailed_Output\n\n   The function returns a pointer to the latest version string for the\n   specified item.\n\n   If item is not one of the items haveing a version, a pointer to the\n   string \"No version found.\" will return.\n\n");

/* void tparse_c ( ConstSpiceChar * string,SpiceInt lenout,
SpiceDouble * sp2000,SpiceChar * errmsg ); */
static PyObject * spice_tparse(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sp2000;
  SpiceChar errmsg[STRING_LEN];
  /* variables for inputs */
  char * string;
  int lenout = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &string));
  tparse_c(string, lenout, &sp2000, errmsg);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sp2000, errmsg);
  return returnVal;
}
PyDoc_STRVAR(tparse_doc, "-Abstract\n\n   Parse a time string and return seconds past the J2000 epoch\n   on a formal calendar.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   string     I   Input time string, UTC.\n   lenout     I   Available space in output error message string.\n   sp2000     O   Equivalent UTC seconds past J2000.\n   errmsg     O   Descriptive error message.\n\n-Detailed_Input\n\n   string      is an input time string, containing a Calendar or\n               Julian Date.  It may be in several different formats\n               and can make use of abbreviations. Several example\n               strings and the times that they translate to are listed\n               below.\n\n   lenout      is the maximum number of characters, including the\n               terminating null, that may be written to the output\n               error message string.\n\n-Detailed_Output\n\n   sp2000      is the equivalent of UTC, expressed in UTC\n               seconds past J2000. If an error occurs, or if\n               the input time string is ambiguous, sp2000 is not\n               changed.\n\n   errmsg      is a descriptive error message, which is empty when\n               no error occurs.\n\n");

/* void tpictr_c ( ConstSpiceChar * sample,SpiceInt lenpictur,
SpiceInt lenerror,SpiceChar * pictur,SpiceBoolean * ok,SpiceChar * error ); */
static PyObject * spice_tpictr(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceChar pictur[STRING_LEN];
  SpiceBoolean ok;
  SpiceChar error[STRING_LEN];
  /* variables for inputs */
  char * sample;
  int lenpictur = STRING_LEN;
  int lenerror = STRING_LEN;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &sample));
  tpictr_c(sample, lenpictur, lenerror, pictur, &ok, error);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "s");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "s");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, pictur, get_py_boolean(&ok), error);
  return returnVal;
}
PyDoc_STRVAR(tpictr_doc, "-Abstract\n\n   Given a sample time string, create a time format picture\n   suitable for use by the routine timout_c.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   sample     I   A sample time string.\n   lenout     I   The length for the output picture string.\n   lenerr     I   The length for the output error string.\n   pictur     O   A format picture that describes sample.\n   ok         O   Flag indicating whether sample parsed successfully.\n   errmsg     O   Diagnostic returned if sample cannot be parsed.\n\n-Detailed_Input\n\n\n   sample     is a representative time string to use as a model to\n              format time strings.\n\n   lenout     is the allowed length for the output picture.  This length\n              must large enough to hold the output string plus the null\n              terminator.  If the output string is expected to have x\n              characters, lenout needs to be x + 1.  80 is a reasonable\n              value for lenout (79 characters plus the null\n              terminator).\n\n   lenerr     is the allowed length for the output error string.\n\n\n-Detailed_Output\n\n\n   pictur     is a format picture suitable for use with the SPICE\n              routine timout_c.  This picture, when used to format an\n              epoch via timout_c, will yield the same time components in\n              the same order as the components in sample.\n\n   ok         is a logical flag indicating whether the input format\n              sample could be parsed. If all of the components of\n              sample are recognizable, ok will be returned with the\n              value SPICEFALSE.  If some part of pictur cannot be\n              parsed, ok will be returned with the value SPICEFALSE.\n\n   errmsg     is a diagnostic message that indicates what part of\n              sample was not recognizable.  If sample was successfully\n              parsed, ok will be SPICEFALSE and errmsg will be\n              returned as an empty string.\n\n");

/* SpiceDouble trace_c ( ConstSpiceDouble matrix[3][3] ); */
static PyObject * spice_trace(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double matrix[3][3];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))", &matrix[0][0], &matrix[0][1], &matrix[0][2], &matrix[1][0], &matrix[1][1], &matrix[1][2], &matrix[2][0], &matrix[2][1], &matrix[2][2]));
  result = trace_c(matrix);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(trace_doc, "-Abstract\n\n    Return the trace of a 3x3 matrix.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    matrix     I     3x3 matrix of double precision numbers.\n    trace      O     The trace of matrix.\n\n-Detailed_Input\n\n    matrix  is a double precision 3x3 matrix.\n\n-Detailed_Output\n\n    trace   is the trace of matrix, i.e. it is the sum of the\n            diagonal elements of matrix.\n\n");

/* void trcoff_c ( void ); */
static PyObject * spice_trcoff(PyObject *self, PyObject *args)
{

  char failed = 0;

  trcoff_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(trcoff_doc, "-Abstract\n\n   Disable tracing.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n\n   None.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   None.\n\n");

/* void tsetyr_c ( SpiceInt year ); */
static PyObject * spice_tsetyr(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  int year;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "i", &year));
  tsetyr_c(year);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(tsetyr_doc, "-Abstract\n\n  Set the lower bound on the 100 year range\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   year       I   Lower bound on the 100 year interval of expansion\n\n-Detailed_Input\n\n   year       is the year associated with the lower bound on all\n              year expansions computed by texpyr_.  For example\n              if year is 1980, then the range of years that\n              can be abbreviated is from 1980 to 2079.\n\n-Detailed_Output\n\n   None.\n\n");

/* SpiceDouble twopi_c ( void ); */
static PyObject * spice_twopi(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = twopi_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(twopi_doc, "-Abstract\n\n   Return twice the value of pi (the ratio of the circumference of\n   a circle to its diameter).\n\n-Brief_I/O\n\n   The function returns twice the value of pi.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns twice the value of pi (the ratio of\n   a circle's circumference to its diameter), determined by\n   the ACOS function. That is,\n\n           twopi = acos ( -1. ) * 2.\n\n");

/* void twovec_c ( ConstSpiceDouble axdef [3],SpiceInt indexa,
ConstSpiceDouble plndef [3],SpiceInt indexp,SpiceDouble mout [3][3] ); */
static PyObject * spice_twovec(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[3][3];
  /* variables for inputs */
  double axdef[3];
  int indexa;
  double plndef[3];
  int indexp;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)i(ddd)i", &axdef[0], &axdef[1], &axdef[2], &indexa, &plndef[0], &plndef[1], &plndef[2], &indexp));
  twovec_c(axdef, indexa, plndef, indexp, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[1][0], mout[1][1], mout[1][2], mout[2][0], mout[2][1], mout[2][2]);
  return returnVal;
}
PyDoc_STRVAR(twovec_doc, "-Abstract\n\n    Find the transformation to the right-handed frame having a\n    given vector as a specified axis and having a second given\n    vector lying in a specified coordinate plane.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  -------------------------------------------------\n    axdef      I   Vector defining a principal axis.\n    indexa     I   Principal axis number of axdef (X=1, Y=2, Z=3).\n    plndef     I   Vector defining (with axdef) a principal plane.\n    indexp     I   Second axis number (with indexa) of principal\n                   plane.\n    mout       O   Output rotation matrix.\n\n-Detailed_Input\n\n    axdef      is a vector defining one of the principal axes of a\n               coordinate frame.\n\n    indexa     is a number that determines which of the three\n               coordinate axes contains axdef.\n\n               If indexa is 1 then axdef defines the X axis of the\n               coordinate frame.\n\n               If indexa is 2 then axdef defines the Y axis of the\n               coordinate frame.\n\n               If indexa is 3 then axdef defines the Z axis of the\n               coordinate frame\n\n    plndef     is a vector defining (with axdef) a principal plane of\n               the coordinate frame.\n\n    indexp     is the second axis of the principal frame determined\n               by axdef and plndef.\n\n               If indexp is 1, the second axis of the principal\n               plane is the X-axis.\n\n               If indexp is 2, the second axis of the principal\n               plane is the Y-axis.\n\n               If indexp is 3, the second axis of the principal plane\n               is the Z-axis.\n\n-Detailed_Output\n\n    mout       is a rotation matrix that transforms coordinates given\n               in the input frame to the frame determined by axdef,\n               plndef, indexa and indexp.\n\n");

/* SpiceDouble tyear_c ( void ); */
static PyObject * spice_tyear(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  result = tyear_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(tyear_doc, "-Abstract\n\n   Return the number of seconds in a tropical year.\n\n-Brief_I/O\n\n   VARIABLE  I/O              DESCRIPTION\n   --------  ---  --------------------------------------------------\n   tyear_c       O   The number of seconds/tropical year\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   The function returns the number of seconds per tropical\n   year.  This value is taken from the 1992 Explanatory Supplement\n   to the Astronomical Almanac.\n\n");

/* void ucrss_c ( ConstSpiceDouble v1[3],ConstSpiceDouble v2[3],
SpiceDouble vout[3] ); */
static PyObject * spice_ucrss(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double v1[3];
  double v2[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &v1[0], &v1[1], &v1[2], &v2[0], &v2[1], &v2[2]));
  ucrss_c(v1, v2, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(ucrss_doc, "-Abstract\n\n   Compute the normalized cross product of two 3-vectors.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I     Left vector for cross product.\n   v2         I     Right vector for cross product.\n   vout       O     Normalized cross product (v1xv2) / |v1xv2|.\n\n-Detailed_Input\n\n   v1   A 3-vector.\n\n   v2   A 3-vector.\n\n-Detailed_Output\n\n   vout is the result of the computation (v1xv2)/|v1xv2|\n\n");

/* void union_c ( SpiceCell * a,SpiceCell * b,SpiceCell * c ); */
static PyObject * spice_union(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  SpiceCell b;
  SpiceCell c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  union_c(&a, &b, &c);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a), get_py_cell(&b), get_py_cell(&c));
  return returnVal;
}
PyDoc_STRVAR(union_doc, "-Abstract\n\n   Compute the union of two sets of any data type to form a third set.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   First input set.\n   b          I   Second input set.\n   c          O   Union of a and b.\n\n-Detailed_Input\n\n   a           is a CSPICE set.  a must be declared as a SpiceCell\n               of data type character, double precision, or integer.\n\n   b           is a CSPICE set, distinct from a.  b must have the\n               same data type as a.\n\n-Detailed_Output\n\n   c           is a CSPICE set, distinct from sets a and b, which\n               contains the union of a and b (that is, all of\n               the elements which are in a or b or both).  c must\n               have the same data type as a and b.\n\n               When comparing elements of character sets, this routine\n               ignores trailing blanks.  Trailing blanks will be\n               trimmed from the members of the output set c.\n\n");

/* SpiceDouble unitim_c ( SpiceDouble epoch,ConstSpiceChar * insys,
ConstSpiceChar * outsys ); */
static PyObject * spice_unitim(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double epoch;
  char * insys;
  char * outsys;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dss", &epoch, &insys, &outsys));
  result = unitim_c(epoch, insys, outsys);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(unitim_doc, "-Abstract\n\n   Transform time from one uniform scale to another.  The uniform\n   time scales are TAI, TDT, TDB, ET, JED, JDTDB, JDTDT.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   epoch      I   An epoch to be converted.\n   insys      I   The time scale associated with the input epoch.\n   outsys     I   The time scale associated with the function value.\n\n   The function returns the d.p. in outsys that is equivalent to the\n   epoch on the insys time scale.\n\n-Detailed_Input\n\n   epoch      is an epoch relative to the insys time scale.\n\n   insys      is a time scale.  Acceptable values are:\n\n              \"TAI\"     International Atomic Time.\n              \"TDB\"     Barycentric Dynamical Time.\n              \"TDT\"     Terrestrial Dynamical Time.\n              \"ET\"      Ephemeris time (in the SPICE system, this is\n                        equivalent to TDB).\n              \"JDTDB\"   Julian Date relative to TDB.\n              \"JDTDT\"   Julian Date relative to TDT.\n              \"JED\"     Julian Ephemeris date (in the SPICE system\n                        this is equivalent to JDTDB).\n\n              The routine is not sensitive to the case of the\n              characters in insys;  \"tai\" \"Tai\" and \"TAI\" are\n              all equivalent from the point of view of this routine.\n\n   outsys     is the time scale to which epoch should be converted.\n              Acceptable values are the same as for insys.  The\n              routine is not sensitive to the case of outsys.\n\n-Detailed_Output\n\n   The function returns the time in the system specified by outsys\n   that is equivalent to the epoch in the insys time scale.\n\n");

/* void unload_c ( ConstSpiceChar * file ); */
static PyObject * spice_unload(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char * file;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &file));
  unload_c(file);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(unload_doc, "-Abstract\n\n   Unload a SPICE kernel.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   file       I   The name of a kernel to unload.\n\n-Detailed_Input\n\n   file       is the name of a file to unload.  This file\n              should be one loaded through the interface furnsh_c.\n              If the file is not on the list of loaded kernels\n              no action is taken.\n\n              Note that if file is a meta-text kernel, all of\n              the files loaded as a result of loading the meta-text\n              kernel will be unloaded.\n\n-Detailed_Output\n\n   None.\n\n");

/* void unorm_c ( ConstSpiceDouble v1[3],SpiceDouble vout[3],
SpiceDouble * vmag ); */
static PyObject * spice_unorm(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  SpiceDouble vmag;
  /* variables for inputs */
  double v1[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &v1[0], &v1[1], &v1[2]));
  unorm_c(v1, vout, &vmag);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2], vmag);
  return returnVal;
}
PyDoc_STRVAR(unorm_doc, "-Abstract\n\n   Normalize a double precision 3-vector and return its magnitude.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I     Vector to be normalized.\n   vout       O     Unit vector v1 / |v1|.\n                    If v1 is the zero vector, then vout will also\n                    be zero. vout can overwrite v1.\n   vmag       O     Magnitude of v1, i.e. |v1|.\n\n-Detailed_Input\n\n   v1      This variable may contain any 3-vector, including the\n            zero vector.\n\n-Detailed_Output\n\n   vout    This variable contains the unit vector in the direction\n           of v1.  If v1 is the zero vector, then vout will also be\n           the zero vector.\n   vmag    This is the magnitude of v1.\n\n");

/* void unormg_c ( ConstSpiceDouble * v1,SpiceInt ndim,SpiceDouble * vout,
SpiceDouble * vmag ); */
static PyObject * spice_unormg(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout;
  SpiceDouble vmag;
  /* variables for inputs */
  double * v1;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "di", &v1, &ndim));
  unormg_c(v1, ndim, &vout, &vmag);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout, vmag);
  return returnVal;
}
PyDoc_STRVAR(unormg_doc, "-Abstract\n\n   Normalize a double precision vector of arbitrary dimension and\n   return its magnitude.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    v1        I     Vector to be normalized.\n    ndim      I     Dimension of v1 (and also vout).\n    vout      O     Unit vector v1 / |v1|.\n                    If v1 = 0, vout will also be zero.\n                    vout can overwrite v1.\n    vmag      O     Magnitude of v1, that is, |v1|.\n\n-Detailed_Input\n\n   v1      This variable may contain any vector of arbitrary\n           dimension, including the zero vector.\n   ndim    This is the dimension of v1 and vout.\n\n-Detailed_Output\n\n   vout    This variable contains the unit vector in the direction\n           of v1.  If v1 is the zero vector, then vout will also be\n           the zero vector.\n\n   vmag    This is the magnitude of v1.\n\n");

/* void utc2et_c ( ConstSpiceChar * utcstr,SpiceDouble * et ); */
static PyObject * spice_utc2et(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble et;
  /* variables for inputs */
  char * utcstr;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &utcstr));
  utc2et_c(utcstr, &et);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, et);
  return returnVal;
}
PyDoc_STRVAR(utc2et_doc, "-Abstract\n\n   Convert an input time from Calendar or Julian Date format, UTC,\n   to ephemeris seconds past J2000.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   utcstr     I   Input time string, UTC.\n   et         O   Output epoch, ephemeris seconds past J2000.\n\n-Detailed_Input\n\n   utcstr      is an input time string, containing a Calendar or\n               Julian Date, UTC. Any input string acceptable to the\n               routine tpartv_ are acceptable to utc2et_c. The length\n               of utcstr should not exceed 80 characters.\n\n-Detailed_Output\n\n   et          is the equivalent of utcstr, expressed in ephemeris\n               seconds past J2000. If an error occurs, or if the\n               input string is ambiguous, et is not changed.\n\n\n");

/* void vadd_c ( ConstSpiceDouble v1[3],ConstSpiceDouble v2[3],
SpiceDouble vout[3] ) ; */
static PyObject * spice_vadd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double v1[3];
  double v2[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &v1[0], &v1[1], &v1[2], &v2[0], &v2[1], &v2[2]));
  vadd_c(v1, v2, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(vadd_doc, "-Abstract\n\n   Add two 3 dimensional vectors.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I     First vector to be added.\n   v2         I     Second vector to be added.\n   vout       O     Sum vector, v1 + v2.\n                     vout can overwrite either v1 or v2.\n\n-Detailed_Input\n\n   v1      This may be any 3-element vector.\n\n   v2      Likewise.\n\n-Detailed_Output\n\n   vout   This is vector sum of v1 and v2. vout may overwrite either\n           v1 or v2.\n\n");

/* void vaddg_c ( ConstSpiceDouble * v1,ConstSpiceDouble * v2,SpiceInt ndim,
SpiceDouble * vout ); */
static PyObject * spice_vaddg(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout;
  /* variables for inputs */
  double * v1;
  double * v2;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddi", &v1, &v2, &ndim));
  vaddg_c(v1, v2, ndim, &vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout);
  return returnVal;
}
PyDoc_STRVAR(vaddg_doc, "-Abstract\n\n    Add two vectors of arbitrary dimension.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n     v1        I     First vector to be added.\n     v2        I     Second vector to be added.\n     ndim      I     Dimension of v1, v2, and vout.\n     vout      O     Sum vector, v1 + v2.\n                     vout can overwrite either v1 or v2.\n\n-Detailed_Input\n\n    v1      This may be any double precision vector of arbitrary\n            dimension.\n\n    v2      Likewise.\n\n    ndim    the dimension of v1, v2 and vout.\n\n-Detailed_Output\n\n    vout   This is vector sum of v1 and v2. vout may overwrite either\n           v1 or v2.\n\n");

/* void valid_c ( SpiceInt size,SpiceInt n,SpiceCell * a ); */
static PyObject * spice_valid(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  /* variables for inputs */
  int size;
  int n;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &size, &n));
  valid_c(size, n, &a);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a));
  return returnVal;
}
PyDoc_STRVAR(valid_doc, "-Abstract\n\n   Create a valid CSPICE set from a CSPICE Cell of any data type.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   size       I   Size (maximum cardinality) of the set.\n   n          I   Initial no. of (possibly non-distinct) elements.\n   set       I/O  Set to be validated.\n\n-Detailed_Input\n\n   size        is the maximum cardinality (number of elements)\n               of the set.  size must not exceed the declared size\n               of the set's data array.\n\n   n           is the number of (possibly non-distinct) elements\n               initially contained in the set's data array.\n               N cannot be greater than the size of the set.\n\n   set         is a CSPICE set.  set must be declared as a character,\n               double precision, or integer SpiceCell.\n\n               On input, set contains n elements.\n\n-Detailed_Output\n\n   set         on output is a valid set created from the input set.\n\n               To create a valid set, the elements are ordered, and\n               duplicate elements are removed.  The set's size and\n               cardinality members are assigned their correct values.\n\n               The set is ready for use with other set routines.\n\n               When validating a character set, trailing blanks are not\n               considered significant in process of sorting and\n               removing duplicates.  Trailing blanks are not preserved\n               on output.\n\n");

/* void vcrss_c ( ConstSpiceDouble v1[3],ConstSpiceDouble v2[3],
SpiceDouble vout[3] ); */
static PyObject * spice_vcrss(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double v1[3];
  double v2[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &v1[0], &v1[1], &v1[2], &v2[0], &v2[1], &v2[2]));
  vcrss_c(v1, v2, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(vcrss_doc, "-Abstract\n\n   Compute the cross product of two 3-dimensional vectors.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I     Left hand vector for cross product.\n   v2         I     Right hand vector for cross product.\n   vout       O     Cross product v1xv2.\n                    vout can overwrite either v1 or v2.\n\n-Detailed_Input\n\n   v1      This may be any 3-dimensional vector.  Typically, this\n           might represent the (possibly unit) vector to a planet,\n           sun, or a star which defines the orientation of axes of\n           some coordinate system.\n\n   v2      Ditto.\n\n-Detailed_Output\n\n   vout    This variable represents the cross product of v1 and v2.\n           vout may overwrite v1 or v2.\n\n");

/* SpiceDouble vdist_c ( ConstSpiceDouble v1[3],ConstSpiceDouble v2[3] ); */
static PyObject * spice_vdist(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double v1[3];
  double v2[3];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &v1[0], &v1[1], &v1[2], &v2[0], &v2[1], &v2[2]));
  result = vdist_c(v1, v2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vdist_doc, "-Abstract\n\n   Return the distance between two three-dimensional vectors.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n\n   v1,\n   v2         I   Two 3-vectors.\n\n   The function returns the distance between v1 and v2.\n\n-Detailed_Input\n\n   v1,\n   v2         are two vectors in three-dimensional space, the\n              distance between which is desired.\n\n-Detailed_Output\n\n   The function returns the distance between v1 and v2.  This is\n   defined as\n\n            ||  v1 - v2  ||,\n\n   where || x || indicates the Euclidean norm of the vector x.\n\n");

/* SpiceDouble vdistg_c ( ConstSpiceDouble * v1,ConstSpiceDouble * v2,
SpiceInt ndim ); */
static PyObject * spice_vdistg(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double * v1;
  double * v2;
  int ndim;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddi", &v1, &v2, &ndim));
  result = vdistg_c(v1, v2, ndim);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vdistg_doc, "-Abstract\n\n   Return the distance between two vectors of arbitrary dimension.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   v1,\n   v2         I   Two vectors of arbitrary dimension.\n   ndim       I   The common dimension of v1 and v2\n\n   The function returns the distance between v1 and v2.\n\n-Detailed_Input\n\n   v1,\n   v2         are two vectors of arbitrary dimension, the\n              distance between which is desired.\n\n   ndim       is the common dimension of v1 and v2.  ndim must be\n              non-negative and must not exceed the minimum of the\n              declared sizes of the actual arguments corresponding\n              to v1 and v2.\n\n-Detailed_Output\n\n   The function returns the distance between v1 and v2.  This is\n   defined as\n\n            ||  v1 - v2  ||,\n\n   where || x || indicates the Euclidean norm of the vector x.\n\n   If ndim is less than 1, the function value is set to 0..\n\n");

/* SpiceDouble vdot_c ( ConstSpiceDouble v1[3],ConstSpiceDouble v2[3] ); */
static PyObject * spice_vdot(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double v1[3];
  double v2[3];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &v1[0], &v1[1], &v1[2], &v2[0], &v2[1], &v2[2]));
  result = vdot_c(v1, v2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vdot_doc, "-Abstract\n\n   Compute the dot product of two double precision, 3-dimensional\n   vectors.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I   First vector in the dot product.\n   v2         I   Second vector in the dot product.\n\n   The function returns the value of the dot product of v1 and v2.\n\n-Detailed_Input\n\n    v1      This may be any 3-dimensional, double precision vector.\n\n    v2      This may be any 3-dimensional, double precision vector.\n\n-Detailed_Output\n\n   The function returns the value of the dot product of v1 and v2.\n\n");

/* SpiceDouble vdotg_c ( ConstSpiceDouble * v1,ConstSpiceDouble * v2,
SpiceInt ndim ); */
static PyObject * spice_vdotg(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double * v1;
  double * v2;
  int ndim;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddi", &v1, &v2, &ndim));
  result = vdotg_c(v1, v2, ndim);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vdotg_doc, "-Abstract\n\n   Compute the dot product of two vectors of arbitrary dimension.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    v1        I     First vector in the dot product.\n    v2        I     Second vector in the dot product.\n    ndim      I     Dimension of v1 and v2.\n\n   The function returns the value of the dot product of v1 and v2.\n\n-Detailed_Input\n\n   v1      This may be any double precision vector of arbitrary\n           dimension.\n\n   v2      This may be any double precision vector of arbitrary\n           dimension.\n\n-Detailed_Output\n\n   The function returns the value of the dot product of v1 and v2.\n\n");

/* void vequ_c ( ConstSpiceDouble vin[3],SpiceDouble vout[3] ); */
static PyObject * spice_vequ(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double vin[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &vin[0], &vin[1], &vin[2]));
  vequ_c(vin, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(vequ_doc, "-Abstract\n\n    Make one double precision 3-dimensional vector equal to\n    another.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   vin       I   3-dimensional double precision vector.\n   vout      O   3-dimensional double precision vector set equal\n                 to vin.\n\n-Detailed_Input\n\n   vin      This may be ANY 3-dimensional double precision vector.\n\n-Detailed_Output\n\n   vout    This 3-dimensional double precision vector is set equal\n           to vin.\n\n");

/* void vequg_c ( ConstSpiceDouble * vin,SpiceInt ndim,SpiceDouble * vout ); */
static PyObject * spice_vequg(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout;
  /* variables for inputs */
  double * vin;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "di", &vin, &ndim));
  vequg_c(vin, ndim, &vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout);
  return returnVal;
}
PyDoc_STRVAR(vequg_doc, "-Abstract\n\n   Make one double precision vector of arbitrary dimension equal\n   to another.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    vin       I   ndim-dimensional double precision vector.\n    ndim      I   Dimension of vin (and also vout).\n    vout      O   ndim-dimensional double precision vector set\n                  equal to vin.\n\n-Detailed_Input\n\n   vin      is a double precision vector of arbitrary dimension.\n\n   ndim     is the number of components of vin.\n\n-Detailed_Output\n\n   vout     is a double precision vector set equal to vin.\n\n");

/* void vhat_c ( ConstSpiceDouble v1 [3],SpiceDouble vout[3] ); */
static PyObject * spice_vhat(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double v1[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &v1[0], &v1[1], &v1[2]));
  vhat_c(v1, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(vhat_doc, "-Abstract\n\n   Find the unit vector along a double precision 3-dimensional vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I   Vector to be unitized.\n   vout       O   Unit vector v1 / |v1|.\n\n-Detailed_Input\n\n    v1            This is any double precision, 3-dimensional vector.\n\n-Detailed_Output\n\n    vout          vout contains the unit vector in the direction of v1.\n                  If v1 represents the zero vector, then vout will also\n                  be the zero vector.  vout may overwrite v1.\n\n");

/* void vhatg_c ( ConstSpiceDouble * v1,SpiceInt ndim,SpiceDouble * vout ); */
static PyObject * spice_vhatg(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout;
  /* variables for inputs */
  double * v1;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "di", &v1, &ndim));
  vhatg_c(v1, ndim, &vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout);
  return returnVal;
}
PyDoc_STRVAR(vhatg_doc, "-Abstract\n\n   Find the unit vector along a double precision vector of\n   arbitrary dimension.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I   Vector to be normalized.\n   ndim       I   Dimension of v1 (and also vout).\n   vout       O   Unit vector v1 / |v1|.\n                  If v1 = 0, vout will also be zero.\n                  vout can overwrite v1.\n\n-Detailed_Input\n\n    v1            This is any double precision vector of arbitrary\n                  dimension.  This routine will detect if is V1 the\n                  zero vector, and will not attempt to divide by zero.\n\n    ndim          is the dimension of V1 (and also VOUT).\n\n-Detailed_Output\n\n    vout          contains the unit vector in the direction of v1. If\n                  v1 represents the zero vector, then vout will also be\n                  the zero vector.  vout may overwrite v1.\n\n");

/* void vlcom_c ( SpiceDouble a,ConstSpiceDouble v1[3],SpiceDouble b,
ConstSpiceDouble v2[3],SpiceDouble sum[3] ); */
static PyObject * spice_vlcom(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sum[3];
  /* variables for inputs */
  double a;
  double v1[3];
  double b;
  double v2[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d(ddd)d(ddd)", &a, &v1[0], &v1[1], &v1[2], &b, &v2[0], &v2[1], &v2[2]));
  vlcom_c(a, v1, b, v2, sum);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sum[0], sum[1], sum[2]);
  return returnVal;
}
PyDoc_STRVAR(vlcom_doc, "-Abstract\n\n   Compute a vector linear combination of two double precision,\n   3-dimensional vectors.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   Coefficient of v1\n   v1         I   Vector in 3-space\n   b          I   Coefficient of v2\n   v2         I   Vector in 3-space\n   sum        O   Linear Vector Combination a*v1 + b*v2\n\n-Detailed_Input\n\n   a     This double precision variable multiplies v1.\n   v1    This is an arbitrary, double precision 3-dimensional\n          vector.\n   b     This double precision variable multiplies v2.\n   v2    This is an arbitrary, double precision 3-dimensional\n          vector.\n\n-Detailed_Output\n\n   sum   is an arbitrary, double precision 3-dimensional vector\n          which contains the linear combination a*v1 + b*v2.\n\n");

/* void vlcom3_c ( SpiceDouble a,ConstSpiceDouble v1[3],SpiceDouble b,
ConstSpiceDouble v2[3],SpiceDouble c,ConstSpiceDouble v3[3],
SpiceDouble sum[3] ); */
static PyObject * spice_vlcom3(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sum[3];
  /* variables for inputs */
  double a;
  double v1[3];
  double b;
  double v2[3];
  double c;
  double v3[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d(ddd)d(ddd)d(ddd)", &a, &v1[0], &v1[1], &v1[2], &b, &v2[0], &v2[1], &v2[2], &c, &v3[0], &v3[1], &v3[2]));
  vlcom3_c(a, v1, b, v2, c, v3, sum);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sum[0], sum[1], sum[2]);
  return returnVal;
}
PyDoc_STRVAR(vlcom3_doc, "-Abstract\n\n   This subroutine computes the vector linear combination\n   a*v1 + b*v2 + c*v3 of double precision, 3-dimensional vectors.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   Coefficient of v1\n   v1         I   Vector in 3-space\n   b          I   Coefficient of v2\n   v2         I   Vector in 3-space\n   c          I   Coefficient of v3\n   v3         I   Vector in 3-space\n   sum        O   Linear Vector Combination a*v1 + b*v2 + c*v3\n\n-Detailed_Input\n\n   a     is a double precision number.\n\n   v1    is a double precision 3-dimensional vector.\n\n   b     is a double precision number.\n\n   v2    is a double precision 3-dimensional vector.\n\n   c     is a double precision number.\n\n   v3    is a double precision 3-dimensional vector.\n\n-Detailed_Output\n\n   sum   is a double precision 3-dimensional vector which contains\n         the linear combination a*v1 + b*v2 + c*v3\n\n");

/* void vlcomg_c ( SpiceInt n,SpiceDouble a,ConstSpiceDouble * v1,
SpiceDouble b,ConstSpiceDouble * v2,SpiceDouble * sum ); */
static PyObject * spice_vlcomg(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble sum;
  /* variables for inputs */
  int n;
  double a;
  double * v1;
  double b;
  double * v2;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "idddd", &n, &a, &v1, &b, &v2));
  vlcomg_c(n, a, v1, b, v2, &sum);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, sum);
  return returnVal;
}
PyDoc_STRVAR(vlcomg_doc, "-Abstract\n\n   Compute a vector linear combination of two double precision\n   vectors of arbitrary dimension.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n    n          I   Dimension of vector space\n    a          I   Coefficient of v1\n    v1         I   Vector in n-space\n    b          I   Coefficient of v2\n    v2         I   Vector in n-space\n    sum        O   Linear Vector Combination a*v1 + b*v2\n\n-Detailed_Input\n\n    n   This variable contains the dimension of the v1, v2 and sum.\n    a   This double precision variable multiplies v1.\n    v1  This is an arbitrary, double precision n-dimensional vector.\n    b   This double precision variable multiplies v2.\n    v2  This is an arbitrary, double precision n-dimensional vector.\n\n-Detailed_Output\n\n    sum   is an arbitrary, double precision n-dimensional vector\n          which contains the linear combination a*v1 + b*v2.\n\n");

/* void vminug_c ( ConstSpiceDouble * vin,SpiceInt ndim,SpiceDouble * vout ); */
static PyObject * spice_vminug(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout;
  /* variables for inputs */
  double * vin;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "di", &vin, &ndim));
  vminug_c(vin, ndim, &vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout);
  return returnVal;
}
PyDoc_STRVAR(vminug_doc, "-Abstract\n\n   Negate a double precision vector of arbitrary dimension.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n     vin       I   ndim-dimensional double precision vector to\n                   be negated.\n     ndim      I   Dimension of vin (and also vout).\n     vout      O   ndim-dimensional double precision vector equal to\n                   -vin.\n\n-Detailed_Input\n\n    vin      double precision vector of arbitrary size.\n\n    ndim     the dimension of vin and vout.\n\n-Detailed_Output\n\n    vout    a double precision vector which contains the negation\n            of vin. vout may overwrite vin.\n\n");

/* void vminus_c ( ConstSpiceDouble v1[3],SpiceDouble vout[3] ); */
static PyObject * spice_vminus(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double v1[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &v1[0], &v1[1], &v1[2]));
  vminus_c(v1, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(vminus_doc, "-Abstract\n\n   Negate a double precision 3-dimensional vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I     Vector to be negated.\n   vout       O     Negated vector -v1. vout can overwrite v1.\n\n\n-Detailed_Input\n\n   v1      This may be any 3-dimensional, double precision vector.\n\n-Detailed_Output\n\n   vout    This will be the negation (additive inverse) of v1.  It\n           is a 3-dimensional, double precision vector.  vout may\n           overwrite v1.\n\n");

/* SpiceDouble vnorm_c ( ConstSpiceDouble v1[3] ); */
static PyObject * spice_vnorm(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double v1[3];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &v1[0], &v1[1], &v1[2]));
  result = vnorm_c(v1);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vnorm_doc, "-Abstract\n\n   Compute the magnitude of a double precision, 3-dimensional vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I   Vector whose magnitude is to be found.\n\n   The function returns the norm of v1.\n\n-Detailed_Input\n\n   v1             may be any 3-dimensional, double precision vector.\n\n-Detailed_Output\n\n   The function returns the magnitude of v1 calculated in a numerically\n   stable way.\n\n");

/* SpiceDouble vnormg_c ( ConstSpiceDouble * v1,SpiceInt ndim ); */
static PyObject * spice_vnormg(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double * v1;
  int ndim;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "di", &v1, &ndim));
  result = vnormg_c(v1, ndim);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vnormg_doc, "-Abstract\n\n   Compute the magnitude of a double precision vector of arbitrary\n   dimension.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    v1        I     Vector whose magnitude is to be found.\n    ndim      I     Dimension of v1.\n\n-Detailed_Input\n\n   v1      This may be any double precision vector or arbitrary\n           size.\n\n-Detailed_Output\n\n   vnormg_c is the magnitude of v1 calculated in a numerically stable\n   way.\n\n");

/* void vpack_c ( SpiceDouble x,SpiceDouble y,SpiceDouble z,
SpiceDouble v[3] ); */
static PyObject * spice_vpack(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble v[3];
  /* variables for inputs */
  double x;
  double y;
  double z;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddd", &x, &y, &z));
  vpack_c(x, y, z, v);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, v[0], v[1], v[2]);
  return returnVal;
}
PyDoc_STRVAR(vpack_doc, "-Abstract\n\n   Pack three scalar components into a vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   x,\n   y,\n   z          I   Scalar components of a 3-vector.\n   v          O   Equivalent 3-vector.\n\n-Detailed_Input\n\n   x,\n   y,\n   z           are the scalar components of a 3-vector.\n\n-Detailed_Output\n\n   v           is the equivalent vector, such that v[0] == x\n                                                   v[1] == y\n                                                   v[2] == z\n\n");

/* void vperp_c ( ConstSpiceDouble a[3],ConstSpiceDouble b[3],
SpiceDouble p[3] ); */
static PyObject * spice_vperp(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble p[3];
  /* variables for inputs */
  double a[3];
  double b[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &a[0], &a[1], &a[2], &b[0], &b[1], &b[2]));
  vperp_c(a, b, p);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, p[0], p[1], p[2]);
  return returnVal;
}
PyDoc_STRVAR(vperp_doc, "-Abstract\n\n   Find the component of a vector that is perpendicular to a second\n   vector.  All vectors are 3-dimensional.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    a         I    The vector whose orthogonal component is sought.\n    b         I    The vector used as the orthogonal reference.\n    p         O    The component of a orthogonal to b.\n\n-Detailed_Input\n\n   a     is a double precision, 3-dimensional vector.  It the vector\n         whose component orthogonal to b is sought. (There is a\n         unique decomposition of a into a sum v + p, where v is\n         parallel to b and p is orthogonal to b.  We want the\n         component p.)\n\n   b     is a double precision, 3-dimensional vector.  This\n         vector is the vector used as a reference for the\n         decomposition of a.\n\n\n-Detailed_Output\n\n   p     is a double precision, 3-dimensional vector containing\n         the component of a that is orthogonal to b.\n         p may overwrite either a or b.\n\n");

/* void vprjp_c ( ConstSpiceDouble vin [3],ConstSpicePlane * plane,
SpiceDouble vout [3] ); */
static PyObject * spice_vprjp(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double vin[3];
  ConstSpicePlane * plane;
  PyObject * py_plane = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)O", &vin[0], &vin[1], &vin[2], &py_plane));
  plane = get_spice_plane(py_plane);

  vprjp_c(vin, plane, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(vprjp_doc, "-Abstract\n\n   Project a vector onto a specified plane, orthogonally.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   vin        I   Vector to be projected.\n   plane      I   A CSPICE plane onto which vin is projected.\n   vout       O   Vector resulting from projection.\n\n-Detailed_Input\n\n   vin            is a 3-vector that is to be orthogonally projected\n                  onto a specified plane.\n\n   plane          is a CSPICE plane that represents the geometric\n                  plane onto which vin is to be projected.\n\n-Detailed_Output\n\n   vout           is the vector resulting from the orthogonal\n                  projection of vin onto plane.  vout is the closest\n                  point in the specified plane to vin.\n\n");

/* void vprjpi_c ( ConstSpiceDouble vin [3],ConstSpicePlane * projpl,
ConstSpicePlane * invpl,SpiceDouble vout [3],SpiceBoolean * found ); */
static PyObject * spice_vprjpi(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  SpiceBoolean found;
  /* variables for inputs */
  double vin[3];
  ConstSpicePlane * projpl;
  PyObject * py_projpl = NULL;
  ConstSpicePlane * invpl;
  PyObject * py_invpl = NULL;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)OO", &vin[0], &vin[1], &vin[2], &py_projpl, &py_invpl));
  projpl = get_spice_plane(py_projpl);
invpl = get_spice_plane(py_invpl);

  vprjpi_c(vin, projpl, invpl, vout, &found);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  if(!found) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
  }

}
PyDoc_STRVAR(vprjpi_doc, "-Abstract\n\n   Find the vector in a specified plane that maps to a specified\n   vector in another plane under orthogonal projection.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   vin        I   The projected vector.\n   projpl     I   Plane containing vin.\n   invpl      I   Plane containing inverse image of vin.\n   vout       O   Inverse projection of vin.\n   found      O   Flag indicating whether vout could be calculated.\n\n-Detailed_Input\n\n   vin,\n   projpl,\n   invpl          are, respectively, a 3-vector, a CSPICE plane\n                  containing the vector, and a CSPICE plane\n                  containing the inverse image of the vector under\n                  orthogonal projection onto projpl.\n\n-Detailed_Output\n\n   vout           is the inverse orthogonal projection of vin.  This\n                  is the vector lying in the plane invpl whose\n                  orthogonal projection onto the plane projpl is\n                  vin.  vout is valid only when found (defined below)\n                  is SPICETRUE. Otherwise, vout is undefined.\n\n   found          indicates whether the inverse orthogonal projection\n                  of vin could be computed.  found is SPICETRUE if so,\n                  SPICEFALSE otherwise.\n\n");

/* void vproj_c ( ConstSpiceDouble a[3],ConstSpiceDouble b[3],
SpiceDouble p[3] ); */
static PyObject * spice_vproj(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble p[3];
  /* variables for inputs */
  double a[3];
  double b[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &a[0], &a[1], &a[2], &b[0], &b[1], &b[2]));
  vproj_c(a, b, p);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, p[0], p[1], p[2]);
  return returnVal;
}
PyDoc_STRVAR(vproj_doc, "-Abstract\n\n   vproj_c finds the projection of one vector onto another vector.\n   All vectors are 3-dimensional.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    a         I    The vector to be projected.\n    b         I    The vector onto which a is to be projected.\n    p         O    The projection of a onto b.\n\n-Detailed_Input\n\n   a     is a double precision, 3-dimensional vector.  This\n          vector is to be projected onto the vector b.\n\n   b     is a double precision, 3-dimensional vector.  This\n          vector is the vector which receives the projection.\n\n-Detailed_Output\n\n   p     is a double precision, 3-dimensional vector containing\n          the projection of a onto b.  p may overwrite either\n          a or b.  (p is necessarily parallel to b.)  If b is\n          the zero vector then p will be returned as the zero vector.\n\n");

/* SpiceDouble vrel_c ( ConstSpiceDouble v1[3],ConstSpiceDouble v2[3] ); */
static PyObject * spice_vrel(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double v1[3];
  double v2[3];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &v1[0], &v1[1], &v1[2], &v2[0], &v2[1], &v2[2]));
  result = vrel_c(v1, v2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vrel_doc, "-Abstract\n\n   Return the relative difference between two 3-dimensional vectors.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n    v1,v2     I   Input vectors.\n\n-Detailed_Input\n\n    v1, v2        are two 3-dimensional vectors for which the\n                  relative difference is to be computed.\n\n-Detailed_Output\n\n    vrel_c        the relative difference between V1 and V2.\n                  It is defined as:\n                                              || v1 - v2 ||\n                            vrel_c   =   ----------------------\n                                       max ( ||v1||, ||v2|| )\n\n                  where || x || indicates the Euclidean norm of\n                  the vector x ( ||x|| = sqrt( x . x ) ).\n\n                  vrel_c assumes values in the range [0,2]. If both\n                  v1 and v2 are zero vectors then vrel_c is defined\n                  to be zero.\n\n\n");

/* SpiceDouble vrelg_c ( ConstSpiceDouble * v1,ConstSpiceDouble * v2,
SpiceInt ndim ); */
static PyObject * spice_vrelg(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double * v1;
  double * v2;
  int ndim;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddi", &v1, &v2, &ndim));
  result = vrelg_c(v1, v2, ndim);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vrelg_doc, "-Abstract\n\n   Return the relative difference between two vectors of general\n   dimension.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n    v1,v2     I   Input vectors.\n    ndim      I   Dimension of v1 and v2.\n\n-Detailed_Input\n\n    v1, v2        are two vectors for which the relative difference\n                  is to be computed.\n\n    ndim          is the dimension of v1 and v2.\n\n-Detailed_Output\n\n    vrelg_c       is the relative difference between v1 and v2.\n                  It is defined as:\n                                              || v1 - v2 ||\n                            vrelg_c  =   ----------------------\n                                       max ( ||v1||, ||v2|| )\n\n                  where || x || indicates the euclidean norm of\n                  the vector x ( ||x|| = sqrt( x . x ) ).\n\n                  vrelg_c assumes values in the range [0,2]. If both\n                  v1 and v2 are zero vectors then vrelg_c is defined\n                  to be zero.\n\n");

/* void vrotv_c ( ConstSpiceDouble v[3],ConstSpiceDouble axis[3],
SpiceDouble theta,SpiceDouble r[3] ); */
static PyObject * spice_vrotv(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble r[3];
  /* variables for inputs */
  double v[3];
  double axis[3];
  double theta;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)d", &v[0], &v[1], &v[2], &axis[0], &axis[1], &axis[2], &theta));
  vrotv_c(v, axis, theta, r);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, r[0], r[1], r[2]);
  return returnVal;
}
PyDoc_STRVAR(vrotv_doc, "-Abstract\n\n   Rotate a vector about a specified axis vector by a specified\n   angle and return the rotated vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v          I   Vector to be rotated.\n   axis       I   Axis of the rotation.\n   theta      I   Angle of rotation (radians).\n   r          O   Result of rotating v about axis by theta.\n\n-Detailed_Input\n\n   v          is a 3-dimensional vector to be rotated.\n\n   axis       is the axis about which the rotation is to be\n              performed.\n\n   theta      is the angle through which v is to be rotated about\n              axis.\n\n-Detailed_Output\n\n   r          is the result of rotating v about axis by theta.\n              If axis is the zero vector, r = v.\n\n");

/* void vscl_c ( SpiceDouble s,ConstSpiceDouble v1[3],SpiceDouble vout[3] ); */
static PyObject * spice_vscl(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double s;
  double v1[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d(ddd)", &s, &v1[0], &v1[1], &v1[2]));
  vscl_c(s, v1, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(vscl_doc, "-Abstract\n\n   Multiply a scalar and a 3-dimensional double precision vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    s         I     Scalar to multiply a vector.\n    v1        I     Vector to be multiplied.\n    vout      O     Product vector, s*v1. vout can overwrite v1.\n\n-Detailed_Input\n\n   s    This is a double precision scalar used to multiply the\n        vector v1.\n\n   v1   This is a 3-dimensional, double precision vector which is\n        to be scaled by s.\n\n-Detailed_Output\n\n   vout   This is a 3-dimensional, double precision vector which\n          is the scalar multiple of v1.  vout = s*v1.\n\n");

/* void vsclg_c ( SpiceDouble s,ConstSpiceDouble * v1,SpiceInt ndim,
SpiceDouble * vout ); */
static PyObject * spice_vsclg(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout;
  /* variables for inputs */
  double s;
  double * v1;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddi", &s, &v1, &ndim));
  vsclg_c(s, v1, ndim, &vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout);
  return returnVal;
}
PyDoc_STRVAR(vsclg_doc, "-Abstract\n\n   Multiply a scalar and a double precision vector of arbitrary\n   dimension.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   s          I     Scalar to multiply a vector.\n   v1         I     Vector to be multiplied.\n   ndim       I     Dimension of v1 (and also vout).\n   vout       O     Product vector, s*v1. vout can overwrite v1.\n\n-Detailed_Input\n\n   s      is a double precision scalar.\n\n   v1     is a double precision vector of arbitrary dimension.\n\n   ndim   is the dimension of v1 (and vout).\n\n-Detailed_Output\n\n   vout   is a double precision vector of arbitrary dimension\n          containing the product of the scalar with the vector v1.\n          vout may overwrite v1.\n\n");

/* SpiceDouble vsep_c ( ConstSpiceDouble v1[3],ConstSpiceDouble v2[3] ); */
static PyObject * spice_vsep(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double v1[3];
  double v2[3];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &v1[0], &v1[1], &v1[2], &v2[0], &v2[1], &v2[2]));
  result = vsep_c(v1, v2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vsep_doc, "-Abstract\n\n   Find the separation angle in radians between two double\n   precision, 3-dimensional vectors.  This angle is defined as zero\n   if either vector is zero.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    v1        I     First vector.\n    v2        I     Second vector.\n\n\n-Detailed_Input\n\n   v1      is an arbitrary double precision, 3-dimensional vector.\n   v2      is also an arbitrary double precision, 3-dimensional\n            vector.  v1 or v2 or both may be the zero vector.\n\n-Detailed_Output\n\n   vsep_c    is the angle between v1 and v2 expressed in radians.\n            vsep_c is strictly non-negative.  If either v1 or v2 is\n            the zero vector, then vsep_c is defined to be 0 radians.\n\n");

/* void vsub_c ( ConstSpiceDouble v1[3],ConstSpiceDouble v2[3],
SpiceDouble vout[3] ); */
static PyObject * spice_vsub(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout[3];
  /* variables for inputs */
  double v1[3];
  double v2[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)(ddd)", &v1[0], &v1[1], &v1[2], &v2[0], &v2[1], &v2[2]));
  vsub_c(v1, v2, vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout[0], vout[1], vout[2]);
  return returnVal;
}
PyDoc_STRVAR(vsub_doc, "-Abstract\n\n   Compute the difference between two 3-dimensional, double\n   precision vectors.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v1         I     First vector (minuend).\n   v2         I     Second vector (subtrahend).\n   vout       O     Difference vector, v1 - v2. vout can overwrite\n                    either v1 or v2.\n\n-Detailed_Input\n\n   v1    This can be any 3-dimensional, double precision vector.\n\n   v2    Ditto.\n\n-Detailed_Output\n\n   vout   This is a 3-dimensional, double precision vector which\n           represents the vector difference, v1 - v2.\n\n");

/* void vsubg_c ( ConstSpiceDouble * v1,ConstSpiceDouble * v2,SpiceInt ndim,
SpiceDouble * vout ); */
static PyObject * spice_vsubg(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble vout;
  /* variables for inputs */
  double * v1;
  double * v2;
  int ndim;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddi", &v1, &v2, &ndim));
  vsubg_c(v1, v2, ndim, &vout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, vout);
  return returnVal;
}
PyDoc_STRVAR(vsubg_doc, "-Abstract\n\n    Compute the difference between two double precision vectors of\n    arbitrary dimension.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n     v1        I     First vector (minuend).\n     v2        I     Second vector (subtrahend).\n     ndim      I     Dimension of v1, v2, and vout.\n     vout      O     Difference vector, v1 - v2.\n                     vout can overwrite either v1 or v2.\n\n-Detailed_Input\n\n    v1      is a double precision vector of arbitrary dimension which\n            is the minuend (i.e. first or left-hand member) in the\n            vector subtraction.\n\n    v2      is a double precision vector of arbitrary dimension which\n            is the subtrahend (i.e. second or right-hand member) in\n            the vector subtraction.\n\n    ndim    is the dimension of v1 and v2 (and vout).\n\n-Detailed_Output\n\n    vout    is a double precision vector containing the difference\n            v1 - v2.\n\n");

/* SpiceDouble vsepg_c ( ConstSpiceDouble * v1,ConstSpiceDouble * v2,
SpiceInt ndim ); */
static PyObject * spice_vsepg(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double * v1;
  double * v2;
  int ndim;

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ddi", &v1, &v2, &ndim));
  result = vsepg_c(v1, v2, ndim);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vsepg_doc, "-Abstract\n\n   vsepg_c finds the separation angle in radians between two double\n   precision vectors of arbitrary dimension. This angle is defined\n   as zero if either vector is zero.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n     v1        I     First vector.\n     v2        I     Second vector.\n     ndim      I     The number of elements in v1 and v2.\n\n-Detailed_Input\n\n    v1      is any double precision vector of arbitrary dimension.\n    v2      is also a double precision vector of arbitrary dimension.\n            v1 or v2 or both may be the zero vector.\n    ndim    is the dimension of the both of the input vectors\n            v1 and v2.\n\n-Detailed_Output\n\n    vsepg_c the angle between v1 and v2 expressed in radians.\n            vsepg_c is strictly non-negative.  For input vectors of\n            four or more dimensions, the angle is defined as the\n            generalization of the definition for three dimensions.\n            If either v1 or v2 is the zero vector, then vsepg_c is\n            defined to be 0 radians.\n\n");

/* SpiceDouble vtmv_c ( ConstSpiceDouble v1 [3],ConstSpiceDouble matrix [3][3],
ConstSpiceDouble v2 [3] ); */
static PyObject * spice_vtmv(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double v1[3];
  double matrix[3][3];
  double v2[3];

  char failed = 0;

  /* variable for result */
  SpiceDouble result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)((ddd)(ddd)(ddd))(ddd)", &v1[0], &v1[1], &v1[2], &matrix[0][0], &matrix[0][1], &matrix[0][2], &matrix[1][0], &matrix[1][1], &matrix[1][2], &matrix[2][0], &matrix[2][1], &matrix[2][2], &v2[0], &v2[1], &v2[2]));
  result = vtmv_c(v1, matrix, v2);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  return Py_BuildValue("d", result);
}
PyDoc_STRVAR(vtmv_doc, "-Abstract\n\n    Multiply the transpose of a 3-dimensional column vector,\n    a 3x3 matrix, and a 3-dimensional column vector.\n\n-Brief_I/O\n\n    VARIABLE  I/O  DESCRIPTION\n    --------  ---  --------------------------------------------------\n     v1        I     3 dimensional double precision column vector.\n     matrix    I     3x3 double precision matrix.\n     v2        I     3 dimensional double precision column vector.\n\n     The function returns the result of (v1**t * matrix * v2 ).\n\n-Detailed_Input\n\n    v1         This may be any 3-dimensional, double precision\n               column vector.\n\n    matrix     This may be any 3x3, double precision matrix.\n\n    v2         This may be any 3-dimensional, double precision\n               column vector.\n\n-Detailed_Output\n\n    the function returns the double precision value of the equation\n    (v1**t * matrix * v2 ).\n\n    Notice that vtmv_c is actually the dot product of the vector\n    resulting from multiplying the transpose of v1 and matrix and the\n    vector v2.\n\n");

/* void vupack_c ( ConstSpiceDouble v[3],SpiceDouble * x,SpiceDouble * y,
SpiceDouble * z ); */
static PyObject * spice_vupack(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble x;
  SpiceDouble y;
  SpiceDouble z;
  /* variables for inputs */
  double v[3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &v[0], &v[1], &v[2]));
  vupack_c(v, &x, &y, &z);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, x, y, z);
  return returnVal;
}
PyDoc_STRVAR(vupack_doc, "-Abstract\n\n   Unpack three scalar components from a vector.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   v          I   3-vector.\n   x,\n   y,\n   z          O   Scalar components of 3-vector.\n\n-Detailed_Input\n\n   v           is a double precision 3-vector.\n\n-Detailed_Output\n\n   x,\n   y,\n   z           are the scalar components of the 3-vector v.  On output,\n               the following equalities hold:\n\n                  x = v[0]\n                  y = v[1]\n                  z = v[2]\n\n");

/* SpiceBoolean vzero_c ( ConstSpiceDouble v[3] ); */
static PyObject * spice_vzero(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double v[3];

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "(ddd)", &v[0], &v[1], &v[2]));
  result = vzero_c(v);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(vzero_doc, "-Abstract\n\n   Indicate whether a 3-vector is the zero vector.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   v          I   Vector to be tested.\n\n   The function returns the value SPICETRUE if and only if v is the\n   zero vector.\n\n-Detailed_Input\n\n   v          is a vector in 3-space.\n\n-Detailed_Output\n\n   The function returns the value SPICETRUE if and only if v is the\n   zero vector.\n\n");

/* SpiceBoolean vzerog_c ( ConstSpiceDouble * v,SpiceInt ndim ); */
static PyObject * spice_vzerog(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  double * v;
  int ndim;

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "di", &v, &ndim));
  result = vzerog_c(v, ndim);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(vzerog_doc, "-Abstract\n\n   Indicate whether a general-dimensional vector is the zero vector.\n\n-Brief_I/O\n\n   Variable  I/O  Description\n   --------  ---  --------------------------------------------------\n   v          I   Vector to be tested.\n   ndim       I   Dimension of v.\n\n   The function returns the value SPICETRUE if and only if v is the\n   zero vector.\n\n-Detailed_Input\n\n   v,\n   ndim           are, respectively, a vector and its dimension.\n\n-Detailed_Output\n\n   The function returns the value SPICETRUE if and only if v is the\n   zero vector.\n\n");

/* SpiceInt wncard_c ( SpiceCell * window ); */
static PyObject * spice_wncard(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceInt result;

  result = wncard_c(&window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wncard_doc, "-Abstract\n\n   Return the cardinality (number of intervals) of a double\n   precision window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   window     I   Input window\n\n   The function returns the window cardinality of the window.\n\n-Detailed_Input\n\n   window      a window containing zero or more intervals\n\n               'window' must be declared as a double precision SpiceCell.\n\n-Detailed_Output\n\n   The function returns the cardinality of (number of intervals in)\n   the input window.\n\n");

/* void wncomd_c ( SpiceDouble left,SpiceDouble right,SpiceCell * window,
SpiceCell * result ); */
static PyObject * spice_wncomd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  SpiceCell result;
  /* variables for inputs */
  double left;
  double right;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dd", &left, &right));
  wncomd_c(left, right, &window, &result);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window), get_py_cell(&result));
  return returnVal;
}
PyDoc_STRVAR(wncomd_doc, "-Abstract\n\n   Determine the complement of a double precision window with\n   respect to a specified interval.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   left,\n   right      I   Left, right endpoints of complement interval.\n   window     I   Input window.\n   result     O   Complement of window with respect to [left,right].\n\n-Detailed_Input\n\n   left,\n   right       are the left and right endpoints of the complement\n               interval.\n\n   window      is the window to be complemented.  window must be\n               declared as a double precision SpiceCell.\n\n-Detailed_Output\n\n   result      is the output window, containing the complement\n               of window with respect to the interval from left\n               to right. If the output window is not large enough\n               to contain the result, as many intervals as will\n               fit are returned.\n\n               result must be declared as a double precision SpiceCell.\n\n               result must be distinct from window.\n\n");

/* void wncond_c ( SpiceDouble left,SpiceDouble right,SpiceCell * window ); */
static PyObject * spice_wncond(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  double left;
  double right;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dd", &left, &right));
  wncond_c(left, right, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wncond_doc, "-Abstract\n\n   Contract each of the intervals of a double precision window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   left       I   Amount added to each left endpoint.\n   right      I   Amount subtracted from each right endpoint.\n   window    I,O  Window to be contracted.\n\n-Detailed_Input\n\n   left        is the amount to be added to the left endpoint of\n               each interval in the input window.\n\n   right       is the amount to be subtracted from the right\n               endpoint of each interval in the window.\n\n   window      on input, is a CSPICE window containing zero or more\n               intervals.  window must be declared as a double precision\n               SpiceCell.\n\n-Detailed_Output\n\n   window      on output, is the original window with each of its\n               intervals contracted by left units on the left and\n               right units on the right.\n\n");

/* void wndifd_c ( SpiceCell * a,SpiceCell * b,SpiceCell * c ); */
static PyObject * spice_wndifd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  SpiceCell b;
  SpiceCell c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  wndifd_c(&a, &b, &c);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a), get_py_cell(&b), get_py_cell(&c));
  return returnVal;
}
PyDoc_STRVAR(wndifd_doc, "-Abstract\n\n   Place the difference of two double precision windows into\n   a third window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a,\n   b          I   Input windows.\n   c          I   Difference of a and b.\n\n-Detailed_Input\n\n   a,\n   b           are CSPICE windows, each of which contains zero or more\n               intervals.\n\n               a and b must be declared as double precision\n               SpiceCells.\n\n-Detailed_Output\n\n   c           is the output CSPICE window, containing the difference\n               of a and b---every point contained in a, but not\n               contained in b.\n\n               c must be declared as a double precision SpiceCell.\n\n               c must be distinct from both a and b.\n");

/* SpiceBoolean wnelmd_c ( SpiceDouble point,SpiceCell * window ); */
static PyObject * spice_wnelmd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  double point;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &point));
  result = wnelmd_c(point, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wnelmd_doc, "-Abstract\n\n   Determine whether a point is an element of a double precision\n   window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   point      I   Input point.\n   window     I   Input window.\n\n   The function returns SPICETRUE if point is an element of window.\n\n-Detailed_Input\n\n   point       is a point, which may or may not be contained in\n               one of the intervals in window.\n\n   window      is a CSPICE window containing zero or more intervals.\n\n               window must be declared as a double precision SpiceCell.\n\n-Detailed_Output\n\n   The function returns SPICETRUE if the input point is an element of\n   the input window---that is, if\n\n      a(i)  <  point  <  b(i)\n            -         -\n\n   for some interval [ a(i), b(i) ] in window---and returns SPICEFALSE\n   otherwise.\n\n");

/* void wnexpd_c ( SpiceDouble left,SpiceDouble right,SpiceCell * window ); */
static PyObject * spice_wnexpd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  double left;
  double right;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dd", &left, &right));
  wnexpd_c(left, right, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wnexpd_doc, "-Abstract\n\n   Expand each of the intervals of a double precision window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   left       I   Amount subtracted from each left endpoint.\n   right      I   Amount added to each right endpoint.\n   window    I,O  Window to be expanded.\n\n-Detailed_Input\n\n   left        is the amount to be subtracted from the left\n               endpoint of each interval in the input window.\n\n   right       is the amount to be added to the right endpoint\n               of each interval in the window.\n\n   window      on input, is a window containing zero or more\n               intervals.\n\n               window must be declared as a double precision\n               SpiceCell.\n\n-Detailed_Output\n\n   window      on output, is the original window with each of its\n               intervals expanded by left units on the left and\n               right units on the right.\n\n");

/* void wnextd_c ( SpiceChar side,SpiceCell * window ); */
static PyObject * spice_wnextd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  char side;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "s", &side));
  wnextd_c(side, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wnextd_doc, "-Abstract\n\n   Extract the left or right endpoints from a double precision\n   window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   side       I   Extract left ('L') or right ('R') endpoints.\n   window    I,O  Window to be extracted.\n\n-Detailed_Input\n\n   side        indicates whether the left or right endpoints of\n               the intervals in the window are to be extracted.\n\n                  'L', 'l'       Left endpoints.\n                  'R', 'r'       Right endpoints.\n\n               If side is not recognized, the input window is\n               not changed.\n\n   window      on input, is a window containing zero or more intervals.\n               window must be declared as a double precision SpiceCell.\n\n-Detailed_Output\n\n    window      on output, is the collection of singleton intervals\n                containing either the left or the right endpoints\n                of the intervals in the original window.\n\n");

/* void wnfetd_c ( SpiceCell * window,SpiceInt n,SpiceDouble * left,
SpiceDouble * right ); */
static PyObject * spice_wnfetd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble left;
  SpiceDouble right;
  /* variables for inputs */
  SpiceCell * window;
  PyObject * py_window = NULL;
  int n;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "Oi", &py_window, &n));
  window = get_spice_cell(py_window);

  wnfetd_c(window, n, &left, &right);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, left, right);
  return returnVal;
}
PyDoc_STRVAR(wnfetd_doc, "-Abstract\n\n   Fetch a particular interval from a double precision window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   window     I   Input window.\n   n          I   Index of interval to be fetched.\n   left,\n   right      O   Left, right endpoints of the nth interval.\n\n-Detailed_Input\n\n   window      is a window containing zero or more intervals.\n\n               window must be declared as a double precision SpiceCell.\n\n   n           is the index of a particular interval within the\n               window.  Indices range from 0 to N-1, where N is the\n               number of intervals in the window.\n\n-Detailed_Output\n\n   left,\n   right       are the left and right endpoints of the nth interval\n               in the input window.\n\n");

/* void wnfild_c ( SpiceDouble sml,SpiceCell * window ); */
static PyObject * spice_wnfild(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  double sml;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &sml));
  wnfild_c(sml, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wnfild_doc, "-Abstract\n\n   Fill small gaps between adjacent intervals of a double precision\n   window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   small      I   Limiting measure of small gaps.\n   window    I,O  Window to be filled.\n\n-Detailed_Input\n\n   small       is the limiting measure of the small gaps to be\n               filled. Adjacent intervals separated by gaps of\n               measure less than or equal to small are merged.\n\n   window      on input, is a window containing zero or more\n               intervals.\n\n               window must be declared as a double precision SpiceCell.\n\n-Detailed_Output\n\n   window      on output, is the original window, after adjacent\n               intervals separated by small gaps have been merged.\n\n");

/* void wnfltd_c ( SpiceDouble sml,SpiceCell * window ); */
static PyObject * spice_wnfltd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  double sml;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "d", &sml));
  wnfltd_c(sml, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wnfltd_doc, "-Abstract\n\n   Filter (remove) small intervals from a double precision window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   small      I   Limiting measure of small intervals.\n   window    I,O  Window to be filtered.\n\n-Detailed_Input\n\n   small       is the limiting measure of the small intervals to\n               be filtered. Intervals of measure less than or equal\n               to small are removed from the window.\n\n   window      on input, is a window containing zero or more\n               intervals.  window must be declared as a double precision\n               SpiceCell.\n\n-Detailed_Output\n\n   window      on output, is the original window, after small\n               intervals have been removed.\n\n");

/* SpiceBoolean wnincd_c ( SpiceDouble left,SpiceDouble right,
SpiceCell * window ); */
static PyObject * spice_wnincd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  double left;
  double right;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dd", &left, &right));
  result = wnincd_c(left, right, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wnincd_doc, "-Abstract\n\n   Determine whether an interval is included in a double precision\n   window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   left,\n   right      I   Input interval.\n   window     I   Input window.\n\n   The function returns SPICETRUE if the input interval is included in\n   ---is a subset of some interval in---window.\n\n-Detailed_Input\n\n   left,\n   right       are the endpoints of an interval, which may or\n               may not be contained in one of the intervals in\n               window.\n\n   window      is a CSPICE window containing zero or more intervals.\n\n               window must be declared as a double precision SPICECELL.\n\n-Detailed_Output\n\n   The function returns SPICETRUE if the input interval is included\n   in the input window---that is, if\n\n      a(i)  <  left  <  right  <  b(i)\n            -        -         -\n\n   for some interval [ a(i), b(i) ] in window---and is SPICEFALSE\n   otherwise.\n\n");

/* void wninsd_c ( SpiceDouble left,SpiceDouble right,SpiceCell * window ); */
static PyObject * spice_wninsd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  double left;
  double right;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "dd", &left, &right));
  wninsd_c(left, right, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wninsd_doc, "-Abstract\n\n   Insert an interval into a double precision window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   left,\n   right      I   Left, right endpoints of new interval.\n   window    I,O  Input, output window.\n\n-Detailed_Input\n\n   left,\n   right       are the left and right endpoints of the interval\n               to be inserted.\n\n   window      on input, is a CSPICE window containing zero or more\n               intervals.\n\n               window must be declared as a double precision\n               SpiceCell.\n\n-Detailed_Output\n\n   window      on output, is the original window following the\n               insertion of the interval from left to right.\n\n");

/* void wnintd_c ( SpiceCell * a,SpiceCell * b,SpiceCell * c ); */
static PyObject * spice_wnintd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  SpiceCell b;
  SpiceCell c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  wnintd_c(&a, &b, &c);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a), get_py_cell(&b), get_py_cell(&c));
  return returnVal;
}
PyDoc_STRVAR(wnintd_doc, "-Abstract\n\n   Place the intersection of two double precision windows into\n   a third window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a,\n   b          I   Input windows.\n   c          I   Intersection of a and b.\n\n-Detailed_Input\n\n   a,\n   b           are CSPICE windows, each of which contains zero or more\n               intervals.\n\n               a and b must be declared as double precision\n               SpiceCells.\n\n-Detailed_Output\n\n   c           is the output CSPICE window, containing the intersection\n               of a and b---every point contained in both a and b.\n\n               c must be declared as a double precision SpiceCell.\n\n               c must be distinct from both a and b.\n\n");

/* SpiceBoolean wnreld_c ( SpiceCell * a,ConstSpiceChar * op,SpiceCell * b ); */
static PyObject * spice_wnreld(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell b;
  /* variables for inputs */
  SpiceCell * a;
  PyObject * py_a = NULL;
  char * op;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  /* variable for result */
  SpiceBoolean result;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "Os", &py_a, &op));
  a = get_spice_cell(py_a);

  result = wnreld_c(a, op, &b);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&b));
  return returnVal;
}
PyDoc_STRVAR(wnreld_doc, "-Abstract\n\n   Compare two double precision windows.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a          I   First window.\n   op         I   Comparison operator.\n   b          I   Second window.\n\n   The function returns the result of comparison: a (op) b.\n\n-Detailed_Input\n\n   a,\n   b           are CSPICE windows, each of which contains zero or more\n               intervals.\n\n               a and b must be declared as double precision SpiceCells.\n\n\n   op          is a comparison operator, indicating the way in\n               which the input sets are to be compared. op may\n               be any of the following:\n\n                  Operator             Meaning\n                  --------  -------------------------------------\n                    \"=\"     a = b is SPICETRUE if a and b are equal\n                            (contain the same intervals).\n\n                    \"<>\"    a <> b is SPICETRUE if a and b are not\n                            equal.\n\n                    \"<=\"    a <= b is SPICETRUE if a is a subset of b.\n\n                    \"<\"     a < b is SPICETRUE is a is a proper subset\n                            of b.\n\n                    \">=\"    a >= b is SPICETRUE if b is a subset of a.\n\n                    \">\"     a > b is SPICETRUE if b is a proper subset\n                            of a.\n\n-Detailed_Output\n\n   The function returns the result of the comparison.\n\n");

/* void wnsumd_c ( SpiceCell * window,SpiceDouble * meas,SpiceDouble * avg,
SpiceDouble * stddev,SpiceInt * shortest,SpiceInt * longest ); */
static PyObject * spice_wnsumd(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  SpiceDouble meas;
  SpiceDouble avg;
  SpiceDouble stddev;
  SpiceInt shortest;
  SpiceInt longest;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  wnsumd_c(&window, &meas, &avg, &stddev, &shortest, &longest);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "d");
  strcat(buildvalue_string, "i");
  strcat(buildvalue_string, "i");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window), meas, avg, stddev, shortest, longest);
  return returnVal;
}
PyDoc_STRVAR(wnsumd_doc, "-Abstract\n\n   Summarize the contents of a double precision window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   window     I   Window to be summarized.\n   meas       O   Total measure of intervals in window.\n   avg        O   Average measure.\n   stddev     O   Standard deviation.\n   shortest,\n   longest    O   Locations of shortest, longest intervals.\n\n-Detailed_Input\n\n   window      is a window containing zero or more intervals.\n\n               window must be declared as a double precision SpiceCell.\n\n-Detailed_Output\n\n   meas        is the total measure of the intervals in the input\n               window. This is just the sum of the measures of the\n               individual intervals.\n\n   avg         is the average of the measures of the intervals in\n               the input window.\n\n   stddev      is the standard deviation of the measures of the\n               intervals in the input window.\n\n   shortest,\n   longest     are the locations of the shortest and longest\n               intervals in the input window. The shortest interval\n               is\n\n                  [   SPICE_CELL_ELEM_D( window, shortest   ),\n                      SPICE_CELL_ELEM_D( window, shortest+1 )   ]\n\n               and the longest is\n\n                  [   SPICE_CELL_ELEM_D( window, longest   ),\n                      SPICE_CELL_ELEM_D( window, longest+1 )   ]\n\n               shortest and longest are both zero if the input window\n               contains no intervals.\n\n               If window contains multiple intervals having the shortest\n               length, shortest is the index of the first such interval.\n               Likewise for the longest length.\n\n               Indices range from 0 to N-1, where N is the number of\n               intervals in the window.\n\n");

/* void wnunid_c ( SpiceCell * a,SpiceCell * b,SpiceCell * c ); */
static PyObject * spice_wnunid(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell a;
  SpiceCell b;
  SpiceCell c;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  wnunid_c(&a, &b, &c);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&a), get_py_cell(&b), get_py_cell(&c));
  return returnVal;
}
PyDoc_STRVAR(wnunid_doc, "-Abstract\n\n   Place the union of two double precision windows into a third\n   window.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   a,\n   b          I   Input windows.\n   c          I   Union of a and b.\n\n-Detailed_Input\n\n   a,\n   b           are CSPICE windows, each of which contains zero or more\n               intervals.\n\n               a and b must be declared as double precision\n               SpiceCells.\n\n-Detailed_Output\n\n   c           is the output CSPICE  window, containing the union of\n               a and b---every point contained in a, or in b,\n               or in both.\n\n               c must be declared as a double precision SpiceCell.\n\n               c must be distinct from both a and b.\n\n");

/* void wnvald_c ( SpiceInt size,SpiceInt n,SpiceCell * window ); */
static PyObject * spice_wnvald(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceCell window;
  /* variables for inputs */
  int size;
  int n;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "ii", &size, &n));
  wnvald_c(size, n, &window);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, get_py_cell(&window));
  return returnVal;
}
PyDoc_STRVAR(wnvald_doc, "-Abstract\n\n   Form a valid double precision window from the contents\n   of a window array.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   size       I   Size of window.\n   n          I   Original number of endpoints.\n   window    I,O  Input, output window.\n\n-Detailed_Input\n\n   size        is the size of the window to be validated. This\n               is the maximum number of endpoints that the cell\n               used to implement the window is capable of holding\n               at any one time.\n\n   n           is the original number of endpoints in the input\n               cell.\n\n   window      on input, is a (possibly uninitialized) cell array\n               containing n endpoints of (possibly unordered\n               and non-disjoint) intervals.\n\n               window must be declared as a double precision SpiceCell.\n\n-Detailed_Output\n\n   window      on output, is a window containing the union of the\n               intervals in the input cell.\n\n");

/* void xf2eul_c ( ConstSpiceDouble xform [6][6],SpiceInt axisa,SpiceInt axisb,
SpiceInt axisc,SpiceDouble eulang [6],SpiceBoolean * unique ); */
static PyObject * spice_xf2eul(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble eulang[6];
  SpiceBoolean unique;
  /* variables for inputs */
  double xform[6][6];
  int axisa;
  int axisb;
  int axisc;

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((dddddd)(dddddd)(dddddd)(dddddd)(dddddd)(dddddd))iii", &xform[0][0], &xform[0][1], &xform[0][2], &xform[0][3], &xform[0][4], &xform[0][5], &xform[1][0], &xform[1][1], &xform[1][2], &xform[1][3], &xform[1][4], &xform[1][5], &xform[2][0], &xform[2][1], &xform[2][2], &xform[2][3], &xform[2][4], &xform[2][5], &xform[3][0], &xform[3][1], &xform[3][2], &xform[3][3], &xform[3][4], &xform[3][5], &xform[4][0], &xform[4][1], &xform[4][2], &xform[4][3], &xform[4][4], &xform[4][5], &xform[5][0], &xform[5][1], &xform[5][2], &xform[5][3], &xform[5][4], &xform[5][5], &axisa, &axisb, &axisc));
  xf2eul_c(xform, axisa, axisb, axisc, eulang, &unique);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "(dddddd)");
  strcat(buildvalue_string, "O");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, eulang[0], eulang[1], eulang[2], eulang[3], eulang[4], eulang[5], get_py_boolean(&unique));
  return returnVal;
}
PyDoc_STRVAR(xf2eul_doc, "-Abstract\n\n   Convert a state transformation matrix to Euler angles and their\n   derivatives with respect to a specified set of axes.\n\n   The companion routine eul2xf_c converts Euler angles and their\n   derivatives with respect to a specified set of axes to a state\n   transformation matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   xform      I   A state transformation matrix.\n   axisa      I   Axis A of the Euler angle factorization.\n   axisb      I   Axis B of the Euler angle factorization.\n   axisc      I   Axis C of the Euler angle factorization.\n   eulang     O   An array of Euler angles and their derivatives.\n   unique     O   Indicates if eulang is a unique representation.\n\n-Detailed_Input\n\n   xform       is a state transformation from some frame frame1 to\n               another frame frame2.  Pictorially, xform has the\n               structure shown here.\n\n                    [       |        ]\n                    |  r    |    0   |\n                    |       |        |\n                    |-------+--------|\n                    |       |        |\n                    | dr/dt |    r   |\n                    [       |        ]\n\n               where r is a rotation that varies with respect to time\n               and dr/dt is its time derivative.\n\n               More specifically, if s1 is the state of some object\n               in frame1, then s2, the state of the same object\n               relative to frame2 is given by\n\n                  s2 = xform*s1\n\n               where '*' denotes the matrix vector product.\n\n   axisa       are the axes desired for the factorization of r.\n   axisb       All must be in the range from 1 to 3.  Moreover\n   axisc       it must be the case that axisa and axisb are distinct\n               and that axisb and axisc are distinct.\n\n               Every rotation matrix can be represented as a product\n               of three rotation matrices about the principal axes\n               of a reference frame.\n\n                   r =  [ alpha ]     [ beta ]     [ gamma ]\n                                 axisa        axisb         axisc\n\n               The value 1 corresponds to the X axis.\n               The value 2 corresponds to the Y axis.\n               The value 3 corresponds to the Z axis.\n\n-Detailed_Output\n\n   eulang      is the set of Euler angles corresponding to the\n               specified factorization.\n\n               If we represent r as shown here:\n\n                   r =  [ alpha ]     [ beta ]     [ gamma ]\n                                 axisa        axisb         axisc\n\n               then\n\n\n                  eulang[0] = alpha\n                  eulang[1] = beta\n                  eulang[2] = gamma\n                  eulang[3] = dalpha/dt\n                  eulang[4] = dbeta/dt\n                  eulang[5] = dgamma/dt\n\n               The range of alpha and gamma is (-pi, pi].\n\n               The range of beta depends on the exact set of\n               axes used for the factorization.  For\n               factorizations in which the first and third axes\n               are the same, the range of beta is [0, pi].\n\n               For factorizations in which the first and third\n               axes are different, the range of beta is\n               [-pi/2, pi/2].\n\n               For rotations such that alpha and gamma are not\n               uniquely determined, alpha and dalpha/dt will\n               always be set to zero; gamma and dgamma/dt are\n               then uniquely determined.\n\n   unique      is a logical that indicates whether or not the\n               values in eulang are uniquely determined.  If\n               the values are unique then unique will be set to\n               SPICETRUE.  If the values are not unique and some\n               components ( eulang[0] and eulang[3] ) have been set\n               to zero, then unique will have the value SPICEFALSE.\n\n\n");

/* void xf2rav_c ( ConstSpiceDouble xform [6][6],SpiceDouble rot [3][3],
SpiceDouble av [3] ); */
static PyObject * spice_xf2rav(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble rot[3][3];
  SpiceDouble av[3];
  /* variables for inputs */
  double xform[6][6];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((dddddd)(dddddd)(dddddd)(dddddd)(dddddd)(dddddd))", &xform[0][0], &xform[0][1], &xform[0][2], &xform[0][3], &xform[0][4], &xform[0][5], &xform[1][0], &xform[1][1], &xform[1][2], &xform[1][3], &xform[1][4], &xform[1][5], &xform[2][0], &xform[2][1], &xform[2][2], &xform[2][3], &xform[2][4], &xform[2][5], &xform[3][0], &xform[3][1], &xform[3][2], &xform[3][3], &xform[3][4], &xform[3][5], &xform[4][0], &xform[4][1], &xform[4][2], &xform[4][3], &xform[4][4], &xform[4][5], &xform[5][0], &xform[5][1], &xform[5][2], &xform[5][3], &xform[5][4], &xform[5][5]));
  xf2rav_c(xform, rot, av);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");
  strcat(buildvalue_string, "(ddd)");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, rot[0][0], rot[0][1], rot[0][2], rot[1][0], rot[1][1], rot[1][2], rot[2][0], rot[2][1], rot[2][2], av[0], av[1], av[2]);
  return returnVal;
}
PyDoc_STRVAR(xf2rav_doc, "-Abstract\n\n   This routine determines the rotation matrix and angular\n   velocity of the rotation from a state transformation matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   xform      I   is a state transformation matrix.\n   rot        O   is the rotation associated with xform.\n   av         O   is the angular velocity associated with xform.\n\n-Detailed_Input\n\n   xform       is a state transformation matrix from one frame\n               frame1 to some other frame frame2.\n\n-Detailed_Output\n\n   rot         is a rotation that gives the transformation from\n               some frame frame1 to another frame frame2.\n\n   av          is the angular velocity of the transformation.\n               In other words, if p is the position of a fixed\n               point in frame2, then from the point of view of\n               frame1,  p rotates (in a right handed sense) about\n               an axis parallel to AV.  Moreover the rate of rotation\n               in radians per unit time is given by the length of\n               av.\n\n               More formally, the velocity v of p in frame1 is\n               given by\n                                  t\n                   v  = av x ( rot * p )\n\n               The components of av are given relative to frame1.\n\n");

/* void xpose_c ( ConstSpiceDouble m1 [3][3],SpiceDouble mout[3][3] ); */
static PyObject * spice_xpose(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[3][3];
  /* variables for inputs */
  double m1[3][3];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((ddd)(ddd)(ddd))", &m1[0][0], &m1[0][1], &m1[0][2], &m1[1][0], &m1[1][1], &m1[1][2], &m1[2][0], &m1[2][1], &m1[2][2]));
  xpose_c(m1, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((ddd)(ddd)(ddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[1][0], mout[1][1], mout[1][2], mout[2][0], mout[2][1], mout[2][2]);
  return returnVal;
}
PyDoc_STRVAR(xpose_doc, "-Abstract\n\n   Transpose a 3x3 matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    m1        I   3x3 matrix to be transposed.\n    mout      I   Transpose of m1.  mout can overwrite m1.\n\n-Detailed_Input\n\n    m1            This variable may contain any double precision 3x3\n                  matrix.\n\n-Detailed_Output\n\n    mout          This variable is a double precision, 3x3 matrix which\n                  contains the transpose of m1.  mout may overwrite m1.\n\n");

/* void xpose6_c ( ConstSpiceDouble m1 [6][6],SpiceDouble mout[6][6] ); */
static PyObject * spice_xpose6(PyObject *self, PyObject *args)
{
  /* variables for outputs */
  SpiceDouble mout[6][6];
  /* variables for inputs */
  double m1[6][6];

  char failed = 0;
  char buildvalue_string[STRING_LEN] = "";

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "((dddddd)(dddddd)(dddddd)(dddddd)(dddddd)(dddddd))", &m1[0][0], &m1[0][1], &m1[0][2], &m1[0][3], &m1[0][4], &m1[0][5], &m1[1][0], &m1[1][1], &m1[1][2], &m1[1][3], &m1[1][4], &m1[1][5], &m1[2][0], &m1[2][1], &m1[2][2], &m1[2][3], &m1[2][4], &m1[2][5], &m1[3][0], &m1[3][1], &m1[3][2], &m1[3][3], &m1[3][4], &m1[3][5], &m1[4][0], &m1[4][1], &m1[4][2], &m1[4][3], &m1[4][4], &m1[4][5], &m1[5][0], &m1[5][1], &m1[5][2], &m1[5][3], &m1[5][4], &m1[5][5]));
  xpose6_c(m1, mout);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }

  /* put together the output buildvalue string */
  strcat(buildvalue_string, "((dddddd)(dddddd)(dddddd)(dddddd)(dddddd)(dddddd))");

  PyObject *returnVal = Py_BuildValue(buildvalue_string, mout[0][0], mout[0][1], mout[0][2], mout[0][3], mout[0][4], mout[0][5], mout[1][0], mout[1][1], mout[1][2], mout[1][3], mout[1][4], mout[1][5], mout[2][0], mout[2][1], mout[2][2], mout[2][3], mout[2][4], mout[2][5], mout[3][0], mout[3][1], mout[3][2], mout[3][3], mout[3][4], mout[3][5], mout[4][0], mout[4][1], mout[4][2], mout[4][3], mout[4][4], mout[4][5], mout[5][0], mout[5][1], mout[5][2], mout[5][3], mout[5][4], mout[5][5]);
  return returnVal;
}
PyDoc_STRVAR(xpose6_doc, "-Abstract\n\n   Transpose a 6x6 matrix.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n    m1        I   6x6 matrix to be transposed.\n    mout      I   Transpose of m1.  mout can overwrite m1.\n\n-Detailed_Input\n\n    m1            This variable may contain any double precision 6x6\n                  matrix.\n\n-Detailed_Output\n\n    mout          This variable is a double precision, 6x6 matrix which\n                  contains the transpose of m1.  mout may overwrite m1.\n\n");

/* SpiceBoolean zzgfgeth_c ( void ); */
static PyObject * spice_zzgfgeth(PyObject *self, PyObject *args)
{

  char failed = 0;

  /* variable for result */
  SpiceBoolean result;

  result = zzgfgeth_c();

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  if(result) { Py_RETURN_TRUE; } else { Py_RETURN_FALSE; }
}
PyDoc_STRVAR(zzgfgeth_doc, "");

/* void zzgfsavh_c( SpiceBoolean status ); */
static PyObject * spice_zzgfsavh(PyObject *self, PyObject *args)
{
  /* variables for inputs */
  char status;

  char failed = 0;

  PYSPICE_CHECK_RETURN_STATUS(PyArg_ParseTuple(args, "O", &status));
  zzgfsavh_c(status);

  PYSPICE_CHECK_FAILED;

  if(failed) {
    return NULL;
  }


  Py_INCREF(Py_None);
  return Py_None;
}
PyDoc_STRVAR(zzgfsavh_doc, "-Abstract\n\n   CSPICE Private routine intended solely for the support of CSPICE\n   routines.  Users should not call this routine directly due\n   to the volatile nature of this routine.\n\n   Store the interrupt handler status polled by gfbail_c.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n   status     I   Interrupt status.\n\n-Detailed_Input\n\n   status     is a logical flag indicating whether the most\n              recent instance of the interrupt signal\n              SIGINT has processed by the GF subsystem. See\n              the Particulars section below for details.\n\n              The value of `status' is stored in static memory by this routine.\n\n\n-Detailed_Output\n\n   None.\n\n-Abstract\n\n   CSPICE Private routine intended solely for the support of CSPICE\n   routines.  Users should not call this routine directly due\n   to the volatile nature of this routine.\n\n   Return the saved interrupt handler status.\n\n-Brief_I/O\n\n   VARIABLE  I/O  DESCRIPTION\n   --------  ---  --------------------------------------------------\n\n   The function returns the saved interrupt status.\n\n-Detailed_Input\n\n   None.\n\n-Detailed_Output\n\n   This function returns the interrupt signal status stored\n   by the last call to zzgfsavh_c. If no such call has occurred,\n   then the value SPICEFALSE is returned.\n\n");

PyMethodDef methods[] = {

  {"axisar", spice_axisar, METH_VARARGS, axisar_doc},
  {"badkpv", spice_badkpv, METH_VARARGS, badkpv_doc},
  {"bodc2n", spice_bodc2n, METH_VARARGS, bodc2n_doc},
  {"bodc2s", spice_bodc2s, METH_VARARGS, bodc2s_doc},
  {"boddef", spice_boddef, METH_VARARGS, boddef_doc},
  {"bodfnd", spice_bodfnd, METH_VARARGS, bodfnd_doc},
  {"bodn2c", spice_bodn2c, METH_VARARGS, bodn2c_doc},
  {"bods2c", spice_bods2c, METH_VARARGS, bods2c_doc},
  {"bodvcd", spice_bodvcd, METH_VARARGS, bodvcd_doc},
  {"bodvrd", spice_bodvrd, METH_VARARGS, bodvrd_doc},
  {"brcktd", spice_brcktd, METH_VARARGS, brcktd_doc},
  {"brckti", spice_brckti, METH_VARARGS, brckti_doc},
  {"bschoi", spice_bschoi, METH_VARARGS, bschoi_doc},
  {"bsrchd", spice_bsrchd, METH_VARARGS, bsrchd_doc},
  {"bsrchi", spice_bsrchi, METH_VARARGS, bsrchi_doc},
  {"b1900", spice_b1900, METH_VARARGS, b1900_doc},
  {"b1950", spice_b1950, METH_VARARGS, b1950_doc},
  {"card", spice_card, METH_VARARGS, card_doc},
  {"cgv2el", spice_cgv2el, METH_VARARGS, cgv2el_doc},
  {"chkin", spice_chkin, METH_VARARGS, chkin_doc},
  {"chkout", spice_chkout, METH_VARARGS, chkout_doc},
  {"cidfrm", spice_cidfrm, METH_VARARGS, cidfrm_doc},
  {"ckcls", spice_ckcls, METH_VARARGS, ckcls_doc},
  {"ckcov", spice_ckcov, METH_VARARGS, ckcov_doc},
  {"ckobj", spice_ckobj, METH_VARARGS, ckobj_doc},
  {"ckgp", spice_ckgp, METH_VARARGS, ckgp_doc},
  {"ckgpav", spice_ckgpav, METH_VARARGS, ckgpav_doc},
  {"cklpf", spice_cklpf, METH_VARARGS, cklpf_doc},
  {"ckopn", spice_ckopn, METH_VARARGS, ckopn_doc},
  {"ckupf", spice_ckupf, METH_VARARGS, ckupf_doc},
  {"clight", spice_clight, METH_VARARGS, clight_doc},
  {"clpool", spice_clpool, METH_VARARGS, clpool_doc},
  {"cmprss", spice_cmprss, METH_VARARGS, cmprss_doc},
  {"cnmfrm", spice_cnmfrm, METH_VARARGS, cnmfrm_doc},
  {"conics", spice_conics, METH_VARARGS, conics_doc},
  {"convrt", spice_convrt, METH_VARARGS, convrt_doc},
  {"copy", spice_copy, METH_VARARGS, copy_doc},
  {"cpos", spice_cpos, METH_VARARGS, cpos_doc},
  {"cposr", spice_cposr, METH_VARARGS, cposr_doc},
  {"cvpool", spice_cvpool, METH_VARARGS, cvpool_doc},
  {"cyllat", spice_cyllat, METH_VARARGS, cyllat_doc},
  {"cylrec", spice_cylrec, METH_VARARGS, cylrec_doc},
  {"cylsph", spice_cylsph, METH_VARARGS, cylsph_doc},
  {"dafbbs", spice_dafbbs, METH_VARARGS, dafbbs_doc},
  {"dafbfs", spice_dafbfs, METH_VARARGS, dafbfs_doc},
  {"dafcls", spice_dafcls, METH_VARARGS, dafcls_doc},
  {"dafcs", spice_dafcs, METH_VARARGS, dafcs_doc},
  {"dafdc", spice_dafdc, METH_VARARGS, dafdc_doc},
  {"daffna", spice_daffna, METH_VARARGS, daffna_doc},
  {"daffpa", spice_daffpa, METH_VARARGS, daffpa_doc},
  {"dafgda", spice_dafgda, METH_VARARGS, dafgda_doc},
  {"dafgn", spice_dafgn, METH_VARARGS, dafgn_doc},
  {"dafgsr", spice_dafgsr, METH_VARARGS, dafgsr_doc},
  {"dafopr", spice_dafopr, METH_VARARGS, dafopr_doc},
  {"dafopw", spice_dafopw, METH_VARARGS, dafopw_doc},
  {"dafrda", spice_dafrda, METH_VARARGS, dafrda_doc},
  {"dafrfr", spice_dafrfr, METH_VARARGS, dafrfr_doc},
  {"dafrs", spice_dafrs, METH_VARARGS, dafrs_doc},
  {"dascls", spice_dascls, METH_VARARGS, dascls_doc},
  {"dasopr", spice_dasopr, METH_VARARGS, dasopr_doc},
  {"dcyldr", spice_dcyldr, METH_VARARGS, dcyldr_doc},
  {"deltet", spice_deltet, METH_VARARGS, deltet_doc},
  {"det", spice_det, METH_VARARGS, det_doc},
  {"diags2", spice_diags2, METH_VARARGS, diags2_doc},
  {"diff", spice_diff, METH_VARARGS, diff_doc},
  {"dgeodr", spice_dgeodr, METH_VARARGS, dgeodr_doc},
  {"dlatdr", spice_dlatdr, METH_VARARGS, dlatdr_doc},
  {"dp2hx", spice_dp2hx, METH_VARARGS, dp2hx_doc},
  {"dpgrdr", spice_dpgrdr, METH_VARARGS, dpgrdr_doc},
  {"dpmax", spice_dpmax, METH_VARARGS, dpmax_doc},
  {"dpmax_", spice_dpmax_, METH_VARARGS, dpmax__doc},
  {"dpmin", spice_dpmin, METH_VARARGS, dpmin_doc},
  {"dpmin_", spice_dpmin_, METH_VARARGS, dpmin__doc},
  {"dpr", spice_dpr, METH_VARARGS, dpr_doc},
  {"drdcyl", spice_drdcyl, METH_VARARGS, drdcyl_doc},
  {"drdgeo", spice_drdgeo, METH_VARARGS, drdgeo_doc},
  {"drdlat", spice_drdlat, METH_VARARGS, drdlat_doc},
  {"drdpgr", spice_drdpgr, METH_VARARGS, drdpgr_doc},
  {"drdsph", spice_drdsph, METH_VARARGS, drdsph_doc},
  {"dsphdr", spice_dsphdr, METH_VARARGS, dsphdr_doc},
  {"dtpool", spice_dtpool, METH_VARARGS, dtpool_doc},
  {"ducrss", spice_ducrss, METH_VARARGS, ducrss_doc},
  {"dvcrss", spice_dvcrss, METH_VARARGS, dvcrss_doc},
  {"dvdot", spice_dvdot, METH_VARARGS, dvdot_doc},
  {"dvhat", spice_dvhat, METH_VARARGS, dvhat_doc},
  {"dvnorm", spice_dvnorm, METH_VARARGS, dvnorm_doc},
  {"dvpool", spice_dvpool, METH_VARARGS, dvpool_doc},
  {"dvsep", spice_dvsep, METH_VARARGS, dvsep_doc},
  {"edlimb", spice_edlimb, METH_VARARGS, edlimb_doc},
  {"ekaced", spice_ekaced, METH_VARARGS, ekaced_doc},
  {"ekacei", spice_ekacei, METH_VARARGS, ekacei_doc},
  {"ekacld", spice_ekacld, METH_VARARGS, ekacld_doc},
  {"ekacli", spice_ekacli, METH_VARARGS, ekacli_doc},
  {"ekappr", spice_ekappr, METH_VARARGS, ekappr_doc},
  {"ekccnt", spice_ekccnt, METH_VARARGS, ekccnt_doc},
  {"ekcii", spice_ekcii, METH_VARARGS, ekcii_doc},
  {"ekcls", spice_ekcls, METH_VARARGS, ekcls_doc},
  {"ekdelr", spice_ekdelr, METH_VARARGS, ekdelr_doc},
  {"ekffld", spice_ekffld, METH_VARARGS, ekffld_doc},
  {"ekfind", spice_ekfind, METH_VARARGS, ekfind_doc},
  {"ekgc", spice_ekgc, METH_VARARGS, ekgc_doc},
  {"ekgd", spice_ekgd, METH_VARARGS, ekgd_doc},
  {"ekgi", spice_ekgi, METH_VARARGS, ekgi_doc},
  {"ekinsr", spice_ekinsr, METH_VARARGS, ekinsr_doc},
  {"eklef", spice_eklef, METH_VARARGS, eklef_doc},
  {"eknelt", spice_eknelt, METH_VARARGS, eknelt_doc},
  {"eknseg", spice_eknseg, METH_VARARGS, eknseg_doc},
  {"ekntab", spice_ekntab, METH_VARARGS, ekntab_doc},
  {"ekopn", spice_ekopn, METH_VARARGS, ekopn_doc},
  {"ekopr", spice_ekopr, METH_VARARGS, ekopr_doc},
  {"ekops", spice_ekops, METH_VARARGS, ekops_doc},
  {"ekopw", spice_ekopw, METH_VARARGS, ekopw_doc},
  {"ekrced", spice_ekrced, METH_VARARGS, ekrced_doc},
  {"ekrcei", spice_ekrcei, METH_VARARGS, ekrcei_doc},
  {"ekssum", spice_ekssum, METH_VARARGS, ekssum_doc},
  {"ektnam", spice_ektnam, METH_VARARGS, ektnam_doc},
  {"ekuced", spice_ekuced, METH_VARARGS, ekuced_doc},
  {"ekucei", spice_ekucei, METH_VARARGS, ekucei_doc},
  {"ekuef", spice_ekuef, METH_VARARGS, ekuef_doc},
  {"elemc", spice_elemc, METH_VARARGS, elemc_doc},
  {"elemd", spice_elemd, METH_VARARGS, elemd_doc},
  {"elemi", spice_elemi, METH_VARARGS, elemi_doc},
  {"eqstr", spice_eqstr, METH_VARARGS, eqstr_doc},
  {"el2cgv", spice_el2cgv, METH_VARARGS, el2cgv_doc},
  {"erract", spice_erract, METH_VARARGS, erract_doc},
  {"errch", spice_errch, METH_VARARGS, errch_doc},
  {"errdev", spice_errdev, METH_VARARGS, errdev_doc},
  {"errdp", spice_errdp, METH_VARARGS, errdp_doc},
  {"errint", spice_errint, METH_VARARGS, errint_doc},
  {"errprt", spice_errprt, METH_VARARGS, errprt_doc},
  {"etcal", spice_etcal, METH_VARARGS, etcal_doc},
  {"et2lst", spice_et2lst, METH_VARARGS, et2lst_doc},
  {"et2utc", spice_et2utc, METH_VARARGS, et2utc_doc},
  {"eul2m", spice_eul2m, METH_VARARGS, eul2m_doc},
  {"eul2xf", spice_eul2xf, METH_VARARGS, eul2xf_doc},
  {"exists", spice_exists, METH_VARARGS, exists_doc},
  {"expool", spice_expool, METH_VARARGS, expool_doc},
  {"failed", spice_failed, METH_VARARGS, failed_doc},
  {"frame", spice_frame, METH_VARARGS, frame_doc},
  {"frinfo", spice_frinfo, METH_VARARGS, frinfo_doc},
  {"frmnam", spice_frmnam, METH_VARARGS, frmnam_doc},
  {"ftncls", spice_ftncls, METH_VARARGS, ftncls_doc},
  {"furnsh", spice_furnsh, METH_VARARGS, furnsh_doc},
  {"gdpool", spice_gdpool, METH_VARARGS, gdpool_doc},
  {"georec", spice_georec, METH_VARARGS, georec_doc},
  {"getfat", spice_getfat, METH_VARARGS, getfat_doc},
  {"getmsg", spice_getmsg, METH_VARARGS, getmsg_doc},
  {"gfbail", spice_gfbail, METH_VARARGS, gfbail_doc},
  {"gfclrh", spice_gfclrh, METH_VARARGS, gfclrh_doc},
  {"gfdist", spice_gfdist, METH_VARARGS, gfdist_doc},
  {"gfinth", spice_gfinth, METH_VARARGS, gfinth_doc},
  {"gfoclt", spice_gfoclt, METH_VARARGS, gfoclt_doc},
  {"gfposc", spice_gfposc, METH_VARARGS, gfposc_doc},
  {"gfrefn", spice_gfrefn, METH_VARARGS, gfrefn_doc},
  {"gfrepf", spice_gfrepf, METH_VARARGS, gfrepf_doc},
  {"gfrepi", spice_gfrepi, METH_VARARGS, gfrepi_doc},
  {"gfrepu", spice_gfrepu, METH_VARARGS, gfrepu_doc},
  {"gfrfov", spice_gfrfov, METH_VARARGS, gfrfov_doc},
  {"gfrr", spice_gfrr, METH_VARARGS, gfrr_doc},
  {"gfsep", spice_gfsep, METH_VARARGS, gfsep_doc},
  {"gfsntc", spice_gfsntc, METH_VARARGS, gfsntc_doc},
  {"gfsstp", spice_gfsstp, METH_VARARGS, gfsstp_doc},
  {"gfstep", spice_gfstep, METH_VARARGS, gfstep_doc},
  {"gfsubc", spice_gfsubc, METH_VARARGS, gfsubc_doc},
  {"gftfov", spice_gftfov, METH_VARARGS, gftfov_doc},
  {"gipool", spice_gipool, METH_VARARGS, gipool_doc},
  {"halfpi", spice_halfpi, METH_VARARGS, halfpi_doc},
  {"hx2dp", spice_hx2dp, METH_VARARGS, hx2dp_doc},
  {"ident", spice_ident, METH_VARARGS, ident_doc},
  {"ilumin", spice_ilumin, METH_VARARGS, ilumin_doc},
  {"illum", spice_illum, METH_VARARGS, illum_doc},
  {"inedpl", spice_inedpl, METH_VARARGS, inedpl_doc},
  {"inelpl", spice_inelpl, METH_VARARGS, inelpl_doc},
  {"insrtc", spice_insrtc, METH_VARARGS, insrtc_doc},
  {"insrtd", spice_insrtd, METH_VARARGS, insrtd_doc},
  {"insrti", spice_insrti, METH_VARARGS, insrti_doc},
  {"inter", spice_inter, METH_VARARGS, inter_doc},
  {"inrypl", spice_inrypl, METH_VARARGS, inrypl_doc},
  {"intmax", spice_intmax, METH_VARARGS, intmax_doc},
  {"intmax_", spice_intmax_, METH_VARARGS, intmax__doc},
  {"intmin", spice_intmin, METH_VARARGS, intmin_doc},
  {"intmin_", spice_intmin_, METH_VARARGS, intmin__doc},
  {"invert", spice_invert, METH_VARARGS, invert_doc},
  {"invort", spice_invort, METH_VARARGS, invort_doc},
  {"isordv", spice_isordv, METH_VARARGS, isordv_doc},
  {"isrot", spice_isrot, METH_VARARGS, isrot_doc},
  {"isrchd", spice_isrchd, METH_VARARGS, isrchd_doc},
  {"isrchi", spice_isrchi, METH_VARARGS, isrchi_doc},
  {"iswhsp", spice_iswhsp, METH_VARARGS, iswhsp_doc},
  {"j1900", spice_j1900, METH_VARARGS, j1900_doc},
  {"j1950", spice_j1950, METH_VARARGS, j1950_doc},
  {"j2000", spice_j2000, METH_VARARGS, j2000_doc},
  {"j2100", spice_j2100, METH_VARARGS, j2100_doc},
  {"jyear", spice_jyear, METH_VARARGS, jyear_doc},
  {"kclear", spice_kclear, METH_VARARGS, kclear_doc},
  {"kdata", spice_kdata, METH_VARARGS, kdata_doc},
  {"kinfo", spice_kinfo, METH_VARARGS, kinfo_doc},
  {"ktotal", spice_ktotal, METH_VARARGS, ktotal_doc},
  {"lastnb", spice_lastnb, METH_VARARGS, lastnb_doc},
  {"latcyl", spice_latcyl, METH_VARARGS, latcyl_doc},
  {"latrec", spice_latrec, METH_VARARGS, latrec_doc},
  {"latsph", spice_latsph, METH_VARARGS, latsph_doc},
  {"ldpool", spice_ldpool, METH_VARARGS, ldpool_doc},
  {"lparss", spice_lparss, METH_VARARGS, lparss_doc},
  {"lspcn", spice_lspcn, METH_VARARGS, lspcn_doc},
  {"lstled", spice_lstled, METH_VARARGS, lstled_doc},
  {"lstlei", spice_lstlei, METH_VARARGS, lstlei_doc},
  {"lstltd", spice_lstltd, METH_VARARGS, lstltd_doc},
  {"lstlti", spice_lstlti, METH_VARARGS, lstlti_doc},
  {"ltime", spice_ltime, METH_VARARGS, ltime_doc},
  {"lx4dec", spice_lx4dec, METH_VARARGS, lx4dec_doc},
  {"lx4num", spice_lx4num, METH_VARARGS, lx4num_doc},
  {"lx4sgn", spice_lx4sgn, METH_VARARGS, lx4sgn_doc},
  {"lx4uns", spice_lx4uns, METH_VARARGS, lx4uns_doc},
  {"lxqstr", spice_lxqstr, METH_VARARGS, lxqstr_doc},
  {"m2eul", spice_m2eul, METH_VARARGS, m2eul_doc},
  {"m2q", spice_m2q, METH_VARARGS, m2q_doc},
  {"matchi", spice_matchi, METH_VARARGS, matchi_doc},
  {"matchw", spice_matchw, METH_VARARGS, matchw_doc},
  {"mequ", spice_mequ, METH_VARARGS, mequ_doc},
  {"mtxm", spice_mtxm, METH_VARARGS, mtxm_doc},
  {"mtxv", spice_mtxv, METH_VARARGS, mtxv_doc},
  {"mxm", spice_mxm, METH_VARARGS, mxm_doc},
  {"mxmt", spice_mxmt, METH_VARARGS, mxmt_doc},
  {"mxv", spice_mxv, METH_VARARGS, mxv_doc},
  {"namfrm", spice_namfrm, METH_VARARGS, namfrm_doc},
  {"ncpos", spice_ncpos, METH_VARARGS, ncpos_doc},
  {"ncposr", spice_ncposr, METH_VARARGS, ncposr_doc},
  {"nearpt", spice_nearpt, METH_VARARGS, nearpt_doc},
  {"npedln", spice_npedln, METH_VARARGS, npedln_doc},
  {"npelpt", spice_npelpt, METH_VARARGS, npelpt_doc},
  {"nplnpt", spice_nplnpt, METH_VARARGS, nplnpt_doc},
  {"nvc2pl", spice_nvc2pl, METH_VARARGS, nvc2pl_doc},
  {"nvp2pl", spice_nvp2pl, METH_VARARGS, nvp2pl_doc},
  {"ordc", spice_ordc, METH_VARARGS, ordc_doc},
  {"ordd", spice_ordd, METH_VARARGS, ordd_doc},
  {"ordi", spice_ordi, METH_VARARGS, ordi_doc},
  {"orderd", spice_orderd, METH_VARARGS, orderd_doc},
  {"orderi", spice_orderi, METH_VARARGS, orderi_doc},
  {"oscelt", spice_oscelt, METH_VARARGS, oscelt_doc},
  {"pckcov", spice_pckcov, METH_VARARGS, pckcov_doc},
  {"pckfrm", spice_pckfrm, METH_VARARGS, pckfrm_doc},
  {"pcklof", spice_pcklof, METH_VARARGS, pcklof_doc},
  {"pckuof", spice_pckuof, METH_VARARGS, pckuof_doc},
  {"pdpool", spice_pdpool, METH_VARARGS, pdpool_doc},
  {"pgrrec", spice_pgrrec, METH_VARARGS, pgrrec_doc},
  {"pi", spice_pi, METH_VARARGS, pi_doc},
  {"pipool", spice_pipool, METH_VARARGS, pipool_doc},
  {"pjelpl", spice_pjelpl, METH_VARARGS, pjelpl_doc},
  {"pl2nvc", spice_pl2nvc, METH_VARARGS, pl2nvc_doc},
  {"pl2nvp", spice_pl2nvp, METH_VARARGS, pl2nvp_doc},
  {"pl2psv", spice_pl2psv, METH_VARARGS, pl2psv_doc},
  {"pos", spice_pos, METH_VARARGS, pos_doc},
  {"posr", spice_posr, METH_VARARGS, posr_doc},
  {"prop2b", spice_prop2b, METH_VARARGS, prop2b_doc},
  {"prsdp", spice_prsdp, METH_VARARGS, prsdp_doc},
  {"prsint", spice_prsint, METH_VARARGS, prsint_doc},
  {"psv2pl", spice_psv2pl, METH_VARARGS, psv2pl_doc},
  {"pxform", spice_pxform, METH_VARARGS, pxform_doc},
  {"q2m", spice_q2m, METH_VARARGS, q2m_doc},
  {"qdq2av", spice_qdq2av, METH_VARARGS, qdq2av_doc},
  {"qxq", spice_qxq, METH_VARARGS, qxq_doc},
  {"radrec", spice_radrec, METH_VARARGS, radrec_doc},
  {"rav2xf", spice_rav2xf, METH_VARARGS, rav2xf_doc},
  {"raxisa", spice_raxisa, METH_VARARGS, raxisa_doc},
  {"rdtext", spice_rdtext, METH_VARARGS, rdtext_doc},
  {"reccyl", spice_reccyl, METH_VARARGS, reccyl_doc},
  {"recgeo", spice_recgeo, METH_VARARGS, recgeo_doc},
  {"reclat", spice_reclat, METH_VARARGS, reclat_doc},
  {"recpgr", spice_recpgr, METH_VARARGS, recpgr_doc},
  {"recrad", spice_recrad, METH_VARARGS, recrad_doc},
  {"reordd", spice_reordd, METH_VARARGS, reordd_doc},
  {"reordi", spice_reordi, METH_VARARGS, reordi_doc},
  {"reordl", spice_reordl, METH_VARARGS, reordl_doc},
  {"removc", spice_removc, METH_VARARGS, removc_doc},
  {"removd", spice_removd, METH_VARARGS, removd_doc},
  {"removi", spice_removi, METH_VARARGS, removi_doc},
  {"repmc", spice_repmc, METH_VARARGS, repmc_doc},
  {"repmct", spice_repmct, METH_VARARGS, repmct_doc},
  {"repmd", spice_repmd, METH_VARARGS, repmd_doc},
  {"repmf", spice_repmf, METH_VARARGS, repmf_doc},
  {"repmi", spice_repmi, METH_VARARGS, repmi_doc},
  {"repmot", spice_repmot, METH_VARARGS, repmot_doc},
  {"reset", spice_reset, METH_VARARGS, reset_doc},
  {"return", spice_return, METH_VARARGS, return_doc},
  {"recsph", spice_recsph, METH_VARARGS, recsph_doc},
  {"rotate", spice_rotate, METH_VARARGS, rotate_doc},
  {"rotmat", spice_rotmat, METH_VARARGS, rotmat_doc},
  {"rotvec", spice_rotvec, METH_VARARGS, rotvec_doc},
  {"rpd", spice_rpd, METH_VARARGS, rpd_doc},
  {"rquad", spice_rquad, METH_VARARGS, rquad_doc},
  {"saelgv", spice_saelgv, METH_VARARGS, saelgv_doc},
  {"scard", spice_scard, METH_VARARGS, scard_doc},
  {"scdecd", spice_scdecd, METH_VARARGS, scdecd_doc},
  {"sce2s", spice_sce2s, METH_VARARGS, sce2s_doc},
  {"sce2c", spice_sce2c, METH_VARARGS, sce2c_doc},
  {"sce2t", spice_sce2t, METH_VARARGS, sce2t_doc},
  {"scencd", spice_scencd, METH_VARARGS, scencd_doc},
  {"scfmt", spice_scfmt, METH_VARARGS, scfmt_doc},
  {"scpart", spice_scpart, METH_VARARGS, scpart_doc},
  {"scs2e", spice_scs2e, METH_VARARGS, scs2e_doc},
  {"sct2e", spice_sct2e, METH_VARARGS, sct2e_doc},
  {"sctiks", spice_sctiks, METH_VARARGS, sctiks_doc},
  {"sdiff", spice_sdiff, METH_VARARGS, sdiff_doc},
  {"set", spice_set, METH_VARARGS, set_doc},
  {"setmsg", spice_setmsg, METH_VARARGS, setmsg_doc},
  {"shelld", spice_shelld, METH_VARARGS, shelld_doc},
  {"shelli", spice_shelli, METH_VARARGS, shelli_doc},
  {"sigerr", spice_sigerr, METH_VARARGS, sigerr_doc},
  {"sincpt", spice_sincpt, METH_VARARGS, sincpt_doc},
  {"size", spice_size, METH_VARARGS, size_doc},
  {"spd", spice_spd, METH_VARARGS, spd_doc},
  {"sphcyl", spice_sphcyl, METH_VARARGS, sphcyl_doc},
  {"sphlat", spice_sphlat, METH_VARARGS, sphlat_doc},
  {"sphrec", spice_sphrec, METH_VARARGS, sphrec_doc},
  {"spk14b", spice_spk14b, METH_VARARGS, spk14b_doc},
  {"spk14e", spice_spk14e, METH_VARARGS, spk14e_doc},
  {"spkapo", spice_spkapo, METH_VARARGS, spkapo_doc},
  {"spkapp", spice_spkapp, METH_VARARGS, spkapp_doc},
  {"spkcls", spice_spkcls, METH_VARARGS, spkcls_doc},
  {"spkcov", spice_spkcov, METH_VARARGS, spkcov_doc},
  {"spkacs", spice_spkacs, METH_VARARGS, spkacs_doc},
  {"spkaps", spice_spkaps, METH_VARARGS, spkaps_doc},
  {"spkez", spice_spkez, METH_VARARGS, spkez_doc},
  {"spkezp", spice_spkezp, METH_VARARGS, spkezp_doc},
  {"spkezr", spice_spkezr, METH_VARARGS, spkezr_doc},
  {"spkgeo", spice_spkgeo, METH_VARARGS, spkgeo_doc},
  {"spkgps", spice_spkgps, METH_VARARGS, spkgps_doc},
  {"spklef", spice_spklef, METH_VARARGS, spklef_doc},
  {"spkltc", spice_spkltc, METH_VARARGS, spkltc_doc},
  {"spkobj", spice_spkobj, METH_VARARGS, spkobj_doc},
  {"spkopa", spice_spkopa, METH_VARARGS, spkopa_doc},
  {"spkopn", spice_spkopn, METH_VARARGS, spkopn_doc},
  {"spkpds", spice_spkpds, METH_VARARGS, spkpds_doc},
  {"spkpos", spice_spkpos, METH_VARARGS, spkpos_doc},
  {"spkssb", spice_spkssb, METH_VARARGS, spkssb_doc},
  {"spksub", spice_spksub, METH_VARARGS, spksub_doc},
  {"spkuds", spice_spkuds, METH_VARARGS, spkuds_doc},
  {"spkuef", spice_spkuef, METH_VARARGS, spkuef_doc},
  {"spkw15", spice_spkw15, METH_VARARGS, spkw15_doc},
  {"spkw17", spice_spkw17, METH_VARARGS, spkw17_doc},
  {"srfrec", spice_srfrec, METH_VARARGS, srfrec_doc},
  {"srfxpt", spice_srfxpt, METH_VARARGS, srfxpt_doc},
  {"ssize", spice_ssize, METH_VARARGS, ssize_doc},
  {"stelab", spice_stelab, METH_VARARGS, stelab_doc},
  {"stpool", spice_stpool, METH_VARARGS, stpool_doc},
  {"str2et", spice_str2et, METH_VARARGS, str2et_doc},
  {"subpnt", spice_subpnt, METH_VARARGS, subpnt_doc},
  {"subpt", spice_subpt, METH_VARARGS, subpt_doc},
  {"subslr", spice_subslr, METH_VARARGS, subslr_doc},
  {"subsol", spice_subsol, METH_VARARGS, subsol_doc},
  {"surfnm", spice_surfnm, METH_VARARGS, surfnm_doc},
  {"surfpt", spice_surfpt, METH_VARARGS, surfpt_doc},
  {"surfpv", spice_surfpv, METH_VARARGS, surfpv_doc},
  {"sxform", spice_sxform, METH_VARARGS, sxform_doc},
  {"szpool", spice_szpool, METH_VARARGS, szpool_doc},
  {"timdef", spice_timdef, METH_VARARGS, timdef_doc},
  {"timout", spice_timout, METH_VARARGS, timout_doc},
  {"tipbod", spice_tipbod, METH_VARARGS, tipbod_doc},
  {"tisbod", spice_tisbod, METH_VARARGS, tisbod_doc},
  {"tkvrsn", spice_tkvrsn, METH_VARARGS, tkvrsn_doc},
  {"tparse", spice_tparse, METH_VARARGS, tparse_doc},
  {"tpictr", spice_tpictr, METH_VARARGS, tpictr_doc},
  {"trace", spice_trace, METH_VARARGS, trace_doc},
  {"trcoff", spice_trcoff, METH_VARARGS, trcoff_doc},
  {"tsetyr", spice_tsetyr, METH_VARARGS, tsetyr_doc},
  {"twopi", spice_twopi, METH_VARARGS, twopi_doc},
  {"twovec", spice_twovec, METH_VARARGS, twovec_doc},
  {"tyear", spice_tyear, METH_VARARGS, tyear_doc},
  {"ucrss", spice_ucrss, METH_VARARGS, ucrss_doc},
  {"union", spice_union, METH_VARARGS, union_doc},
  {"unitim", spice_unitim, METH_VARARGS, unitim_doc},
  {"unload", spice_unload, METH_VARARGS, unload_doc},
  {"unorm", spice_unorm, METH_VARARGS, unorm_doc},
  {"unormg", spice_unormg, METH_VARARGS, unormg_doc},
  {"utc2et", spice_utc2et, METH_VARARGS, utc2et_doc},
  {"vadd", spice_vadd, METH_VARARGS, vadd_doc},
  {"vaddg", spice_vaddg, METH_VARARGS, vaddg_doc},
  {"valid", spice_valid, METH_VARARGS, valid_doc},
  {"vcrss", spice_vcrss, METH_VARARGS, vcrss_doc},
  {"vdist", spice_vdist, METH_VARARGS, vdist_doc},
  {"vdistg", spice_vdistg, METH_VARARGS, vdistg_doc},
  {"vdot", spice_vdot, METH_VARARGS, vdot_doc},
  {"vdotg", spice_vdotg, METH_VARARGS, vdotg_doc},
  {"vequ", spice_vequ, METH_VARARGS, vequ_doc},
  {"vequg", spice_vequg, METH_VARARGS, vequg_doc},
  {"vhat", spice_vhat, METH_VARARGS, vhat_doc},
  {"vhatg", spice_vhatg, METH_VARARGS, vhatg_doc},
  {"vlcom", spice_vlcom, METH_VARARGS, vlcom_doc},
  {"vlcom3", spice_vlcom3, METH_VARARGS, vlcom3_doc},
  {"vlcomg", spice_vlcomg, METH_VARARGS, vlcomg_doc},
  {"vminug", spice_vminug, METH_VARARGS, vminug_doc},
  {"vminus", spice_vminus, METH_VARARGS, vminus_doc},
  {"vnorm", spice_vnorm, METH_VARARGS, vnorm_doc},
  {"vnormg", spice_vnormg, METH_VARARGS, vnormg_doc},
  {"vpack", spice_vpack, METH_VARARGS, vpack_doc},
  {"vperp", spice_vperp, METH_VARARGS, vperp_doc},
  {"vprjp", spice_vprjp, METH_VARARGS, vprjp_doc},
  {"vprjpi", spice_vprjpi, METH_VARARGS, vprjpi_doc},
  {"vproj", spice_vproj, METH_VARARGS, vproj_doc},
  {"vrel", spice_vrel, METH_VARARGS, vrel_doc},
  {"vrelg", spice_vrelg, METH_VARARGS, vrelg_doc},
  {"vrotv", spice_vrotv, METH_VARARGS, vrotv_doc},
  {"vscl", spice_vscl, METH_VARARGS, vscl_doc},
  {"vsclg", spice_vsclg, METH_VARARGS, vsclg_doc},
  {"vsep", spice_vsep, METH_VARARGS, vsep_doc},
  {"vsub", spice_vsub, METH_VARARGS, vsub_doc},
  {"vsubg", spice_vsubg, METH_VARARGS, vsubg_doc},
  {"vsepg", spice_vsepg, METH_VARARGS, vsepg_doc},
  {"vtmv", spice_vtmv, METH_VARARGS, vtmv_doc},
  {"vupack", spice_vupack, METH_VARARGS, vupack_doc},
  {"vzero", spice_vzero, METH_VARARGS, vzero_doc},
  {"vzerog", spice_vzerog, METH_VARARGS, vzerog_doc},
  {"wncard", spice_wncard, METH_VARARGS, wncard_doc},
  {"wncomd", spice_wncomd, METH_VARARGS, wncomd_doc},
  {"wncond", spice_wncond, METH_VARARGS, wncond_doc},
  {"wndifd", spice_wndifd, METH_VARARGS, wndifd_doc},
  {"wnelmd", spice_wnelmd, METH_VARARGS, wnelmd_doc},
  {"wnexpd", spice_wnexpd, METH_VARARGS, wnexpd_doc},
  {"wnextd", spice_wnextd, METH_VARARGS, wnextd_doc},
  {"wnfetd", spice_wnfetd, METH_VARARGS, wnfetd_doc},
  {"wnfild", spice_wnfild, METH_VARARGS, wnfild_doc},
  {"wnfltd", spice_wnfltd, METH_VARARGS, wnfltd_doc},
  {"wnincd", spice_wnincd, METH_VARARGS, wnincd_doc},
  {"wninsd", spice_wninsd, METH_VARARGS, wninsd_doc},
  {"wnintd", spice_wnintd, METH_VARARGS, wnintd_doc},
  {"wnreld", spice_wnreld, METH_VARARGS, wnreld_doc},
  {"wnsumd", spice_wnsumd, METH_VARARGS, wnsumd_doc},
  {"wnunid", spice_wnunid, METH_VARARGS, wnunid_doc},
  {"wnvald", spice_wnvald, METH_VARARGS, wnvald_doc},
  {"xf2eul", spice_xf2eul, METH_VARARGS, xf2eul_doc},
  {"xf2rav", spice_xf2rav, METH_VARARGS, xf2rav_doc},
  {"xpose", spice_xpose, METH_VARARGS, xpose_doc},
  {"xpose6", spice_xpose6, METH_VARARGS, xpose6_doc},
  {"zzgfgeth", spice_zzgfgeth, METH_VARARGS, zzgfgeth_doc},
  {"zzgfsavh", spice_zzgfsavh, METH_VARARGS, zzgfsavh_doc},
  {NULL, NULL},
};

void init_spice(PyObject *self)
{
  PyObject *m = NULL;

  m = Py_InitModule("_spice", methods);

  /* Don't allow an exception to stop execution */
  erract_c("SET", 0, "RETURN");
  errdev_c("SET", 0, "NULL");

  SpiceException =     PyErr_NewException("_spice.SpiceException", PyExc_Exception, NULL);
  Py_INCREF(SpiceException);

  PyModule_AddObject(m, "SpiceException", SpiceException);
}
